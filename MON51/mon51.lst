
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	mon51.a51
	Object File:	mon51.hex
	List File:	mon51.lst



 Line  I  Addr  Code            Source

    1:				; MON51 v1.1 (c) Dave Dunfield
    2:				; Available from https://dunfield.themindfactory.com/dnldsrc.htm
    3:				;
    4:				; 8051 Monitor program
    5:				; ----------------------------------------------------------------------------
    6:				; Modified to assemble using ASEM51 v1.3
    7:				; Assemble under WIN10 using the command: ASEMW mon51
    8:				; The will assemble the file MON51.A51 to produce the hex file MON51.HEX
    9:				; and the listing file MON51.LST
   10:				; ----------------------------------------------------------------------------
   11:				; AT89S8253 Specifics:
   12:				; When using the XGecu T48 programmer, remember to set:
   13:				;  Lock Byte   - Set LB1
   14:				;  Config Byte - All 4 bits set
   15:				;              + Serial program enable ticked
   16:				;              + User Row program enable ticked
   17:				;              + x2 Clock Enable ticked
   18:				;              + External Clock enable ticked (to use external osc instead of xtal)
   19:				; ----------------------------------------------------------------------------
   20:				; RCBus 8051 Board specifics:
   21:				; On-board memory extends up to $F7FF for both program and data spaces.
   22:				; Off-board I/O space (via nIORQ) is accessed between $FC00..$FFFF (partially decoded).
   23:				; Set MONRAM to $F780.
   24:				; ----------------------------------------------------------------------------
   25:				; NEW COMMANDS:
   26:				;   Z     - Special REBOOT - execute code at $0000 in external program memory
   27:				;         + Disable internal program memory (nEA LOW)
   28:				;         + Separate program memory & data memory
   29:				;         + Reboot via deliberate watchdog timeout
   30:				; ----------------------------------------------------------------------------
   31:				;
   32:				; Comamnds:
   33:				;	A <aa>		- Alter INTERNAL memory
   34:				;	  Sub commands:  xx	- Replace & advance
   35:				;			<BS>	- Backup to LAST
   36:				;			<SP>	- Advance to NEXT
   37:				;			<CR>	- Quit
   38:				;	B [bp address]	- Display/Set breakpoints
   39:				;	C <Reg> <value>	- Change register
   40:				;	D <aaaa>,[aaaa]	- Dump EXTERNAL DATA memory
   41:				;	E <aaaa>	- Edit EXTERNAL DATA memory
   42:				;	  Sub commands: Same as 'A'lter.
   43:				;	F <s>,<e> <d>	- Fill a block of memory

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

   44:				;	G <aaaa>	- Go (begin execution)
   45:				;	I <aa>,<aa>	- Dump INTERNAL memory
   46:				;	L		- Load program into memory
   47:				;	O <aa> <value>	- Output to SFR
   48:				;	Q <aa>		- Query SFR
   49:				;	R		- Display registers
   50:				;	S		- Single-Step one instruction
   51:				;	U <aaaa>,[aaaa] - Unassemble PROGRAM memory
   52:				;	?		- Display HELP summary
   53:				;
   54:				; Setup:
   55:				; The symbol ROM defines the location of the MON51 code in memory. This
   56:				; will normally be $0000, unless you are intending to run MON51 itself
   57:				; under another debugger or other operating environment.
   58:				;
   59:				; The symbol MONRAM defines a 80 byte area of memory which must be
   60:				; available for EXCLUSIVE use by MON51. This is often set to the highest
   61:				; RAM address in the system - 80.
   62:				;
   63:				; The symbol USERRAM defines the location in memory where user programs
   64:				; will be loaded. This controls the default user PC, as well re-vectoring
   65:				; the 8051 interrupts to corresponding offsets from this address. This is
   66:				; often set to the lowest available RAM address.
   67:				;
   68:				; When compiling or assembling programs to be tested under MON51, be sure
   69:				; to configure your tools such that the application code will be generated
   70:				; at the USERRAM address, and any external data areas will occur above the
   71:				; code, but below MONRAM.
   72:				;
   73:				; NOTE: In order to download and to set breakpoints, MON51 must be able to
   74:				; write to the USERRAM memory. This is normally accomplished by ANDing the
   75:				; -PSEN and -RD signals from the CPU to generate a single CODE/DATA select
   76:				; signal. If you wish to maintain separate CODE and DATA memory, you must add
   77:				; hardware to re-direct the DATA writes to the CODE memory at specific times
   78:				; (perhaps controlled via a I/O port pin). Look for comments beginning with
   79:				; '* ???' to identify places where the monitor must write to CODE memory.
   80:				;
   81:				; The symbol BAUD determines the "reload" value used for timer1 to
   82:				; establish the system baud rate. It is calculated with this formula:
   83:				;
   84:				;		BAUD = (crystal / baud rate) / 384
   85:				;
   86:				; For example, a system for which this monitor was will be used runs at
   87:				; 11.0592 Mhz, and uses a 9600 baud console connection:
   88:				;
   89:				;		BAUD = (11059200 / 9600) / 384
   90:				;
   91:				; This calculation shows that on this system, the correct BAUD value is 3.
   92:				;
   93:				; If the above formula returns a fractional value, round it to the nearest
   94:				; integer, and determine that the actual baud rate that will be generated
   95:				; using this formula:
   96:				;
   97:				;		SPEED = (crystal / integer BAUD) / 384
   98:				;
   99:				; If the result is not within 5 percent of the desired value, that speed

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  100:				; is unobtainable with the crystal frequency you are using. In general, the
  101:				; lower the SPEED required, the better chance you will have of obtaining it.
  102:				;
  103:				; ?COPY.TXT 1991-2007 Dave Dunfield
  104:				;  -- see COPY.TXT --.
  105:				;
  106:				; Load register definitions for an ATMEL AT89S8253.
  107:				$NOMOD51
  108:				$INCLUDE(89S8253.MCU)
  109: 1			;   AT89S8253 processor definition file
  110: 1			;   ===================================
  111: 1
  112: 1	N	 80	P0	DATA	080H
  113: 1	N	 81	SP	DATA	081H
  114: 1	N	 82	DP0L	DATA	082H
  115: 1	N	 83	DP0H	DATA	083H
  116: 1	N	 84	DP1L	DATA	084H
  117: 1	N	 85	DP1H	DATA	085H
  118: 1	N	 86	SPDR	DATA	086H
  119: 1	N	 87	PCON	DATA	087H
  120: 1	N	 88	TCON	DATA	088H
  121: 1	N	 89	TMOD	DATA	089H
  122: 1	N	 8A	TL0	DATA	08AH
  123: 1	N	 8B	TL1	DATA	08BH
  124: 1	N	 8C	TH0	DATA	08CH
  125: 1	N	 8D	TH1	DATA	08DH
  126: 1	N	 8E	AUXR	DATA	08EH
  127: 1	N	 8F	CLKREG	DATA	08FH
  128: 1	N	 90	P1	DATA	090H
  129: 1	N	 96	EECON	DATA	096H
  130: 1	N	 98	SCON	DATA	098H
  131: 1	N	 99	SBUF	DATA	099H
  132: 1	N	 A0	P2	DATA	0A0H
  133: 1	N	 A6	WDTRST	DATA	0A6H
  134: 1	N	 A7	WDTCON	DATA	0A7H
  135: 1	N	 A8	IE	DATA	0A8H
  136: 1	N	 A9	SADDR	DATA	0A9H
  137: 1	N	 AA	SPSR	DATA	0AAH
  138: 1	N	 B0	P3	DATA	0B0H
  139: 1	N	 B7	IPH	DATA	0B7H
  140: 1	N	 B8	IP	DATA	0B8H
  141: 1	N	 B9	SADEN	DATA	0B9H
  142: 1	N	 C8	T2CON	DATA	0C8H
  143: 1	N	 C9	T2MOD	DATA	0C9H
  144: 1	N	 CA	RCAP2L	DATA	0CAH
  145: 1	N	 CB	RCAP2H	DATA	0CBH
  146: 1	N	 CC	TL2	DATA	0CCH
  147: 1	N	 CD	TH2	DATA	0CDH
  148: 1	N	 D0	PSW	DATA	0D0H
  149: 1	N	 D5	SPCR	DATA	0D5H
  150: 1	N	 E0	ACC	DATA	0E0H
  151: 1	N	 F0	B	DATA	0F0H
  152: 1
  153: 1	N	 88	IT0	BIT	088H
  154: 1	N	 89	IE0	BIT	089H
  155: 1	N	 8A	IT1	BIT	08AH

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  156: 1	N	 8B	IE1	BIT	08BH
  157: 1	N	 8C	TR0	BIT	08CH
  158: 1	N	 8D	TF0	BIT	08DH
  159: 1	N	 8E	TR1	BIT	08EH
  160: 1	N	 8F	TF1	BIT	08FH
  161: 1	N	 90	T2	BIT	090H
  162: 1	N	 91	T2EX	BIT	091H
  163: 1	N	 94	SS	BIT	094H
  164: 1	N	 95	MOSI	BIT	095H
  165: 1	N	 96	MISO	BIT	096H
  166: 1	N	 97	SCK	BIT	097H
  167: 1	N	 98	RI	BIT	098H
  168: 1	N	 99	TI	BIT	099H
  169: 1	N	 9A	RB8	BIT	09AH
  170: 1	N	 9B	TB8	BIT	09BH
  171: 1	N	 9C	REN	BIT	09CH
  172: 1	N	 9D	SM2	BIT	09DH
  173: 1	N	 9E	SM1	BIT	09EH
  174: 1	N	 9F	SM0	BIT	09FH
  175: 1	N	 9F	FE	BIT	09FH
  176: 1	N	 A8	EX0	BIT	0A8H
  177: 1	N	 A9	ET0	BIT	0A9H
  178: 1	N	 AA	EX1	BIT	0AAH
  179: 1	N	 AB	ET1	BIT	0ABH
  180: 1	N	 AC	ES	BIT	0ACH
  181: 1	N	 AD	ET2	BIT	0ADH
  182: 1	N	 AF	EA	BIT	0AFH
  183: 1	N	 B0	RXD	BIT	0B0H
  184: 1	N	 B1	TXD	BIT	0B1H
  185: 1	N	 B2	INT0	BIT	0B2H
  186: 1	N	 B3	INT1	BIT	0B3H
  187: 1	N	 B4	T0	BIT	0B4H
  188: 1	N	 B5	T1	BIT	0B5H
  189: 1	N	 B6	WR	BIT	0B6H
  190: 1	N	 B7	RD	BIT	0B7H
  191: 1	N	 B8	PX0	BIT	0B8H
  192: 1	N	 B9	PT0	BIT	0B9H
  193: 1	N	 BA	PX1	BIT	0BAH
  194: 1	N	 BB	PT1	BIT	0BBH
  195: 1	N	 BC	PS	BIT	0BCH
  196: 1	N	 BD	PT2	BIT	0BDH
  197: 1	N	 C8	CPRL2	BIT	0C8H
  198: 1	N	 C9	CT2	BIT	0C9H
  199: 1	N	 CA	TR2	BIT	0CAH
  200: 1	N	 CB	EXEN2	BIT	0CBH
  201: 1	N	 CC	TCLK	BIT	0CCH
  202: 1	N	 CD	RCLK	BIT	0CDH
  203: 1	N	 CE	EXF2	BIT	0CEH
  204: 1	N	 CF	TF2	BIT	0CFH
  205: 1	N	 D0	P	BIT	0D0H
  206: 1	N	 D2	OV	BIT	0D2H
  207: 1	N	 D3	RS0	BIT	0D3H
  208: 1	N	 D4	RS1	BIT	0D4H
  209: 1	N	 D5	F0	BIT	0D5H
  210: 1	N	 D6	AC	BIT	0D6H
  211: 1	N	 D7	CY	BIT	0D7H

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  212: 1
  213: 1	N      0000	RESET	CODE	000H
  214: 1	N      0003	EXTI0	CODE	003H
  215: 1	N      000B	TIMER0	CODE	00BH
  216: 1	N      0013	EXTI1	CODE	013H
  217: 1	N      001B	TIMER1	CODE	01BH
  218: 1	N      0023	SINT	CODE	023H
  219: 1	N      002B	TIMER2	CODE	02BH
  220:
  221:				; System parameters
  222:
  223:		N      0000	ROM		EQU	0000h		; Monitor program storage
  224:		N      F780	MONRAM	EQU	0F780h		; MON51 reserved RAM (80 bytes)
  225:		N      3000	USERRAM	EQU	3000h		; USER/download RAM - starts at 12K
  226:		N      0001	BAUD	EQU	1			; Baudrate divisor for TIMER1 - 38400 baud with x2 clock
  227:
  228:		N      F800	LATCH	EQU	0F800h		; 74LS259 octal latch
  229:
  230:				; Symbols below this point do not normally have to be changed
  231:		N      0020	MSSIZE	EQU	32			; Amount of internal memory to save
  232:		N      0004	NBREAK	EQU	4			; Number of breakpoints
  233:
  234:				; Internal memory locations
  235:		N      0008		ORG	0008h
  236:		N      007F	OUTFLAG	EQU	7Fh
  237:		N      0007	STACK	EQU	07h
  238:
  239:				; External (reserved) memory locations
  240:
  241:		N      F780		ORG	MONRAM
  242:
  243:				; Note: PCSAVE, SPSAVE and MRSAVE must occur together in this order
  244:	  F780	N      0002	PCSAVE:	DS	2			; Program Counter save area
  245:	  F782	N      0001	SPSAVE:	DS	1			; Stack Pointer save area
  246:	  F783	N      0025	MRSAVE:	DS	MSSIZE+5	; Memory & Register save area
  247:	  F7A8	N      0014	BRKTAB:	DS	NBREAK*5	; 5 bytes/breakpoint
  248:	  F7BC	N      0014	MBUFFER:	DS	20			; Temporary space
  249:		N      004D	MRSIZE	EQU	$-MRSAVE	; Size of monitor RAM
  250:				;
  251:				; Beginning of MON51 program code
  252:				;
  253:
  254:		N      0000		ORG	ROM				; Code goes here
  255:	  0000	02 10 55		LJMP	START		; Skip interrupt vectors
  256:				; Re-vector interrupts
  257:		N      0003		ORG	ROM+0003h		; EXT Interrupt 0
  258:	  0003	02 30 03		LJMP	USERRAM+03h
  259:	  0006	81 8E			AJMP	WRCHR
  260:	  0008	81 8C			AJMP	WRSPC
  261:		N      000B		ORG	ROM+000Bh		; Timer 0 overflow
  262:	  000B	02 30 0B		LJMP	USERRAM+0Bh
  263:	  000E	81 65			AJMP	WRLFCR
  264:	  0010	81 48			AJMP	WRHEX
  265:		N      0013		ORG	ROM+0013h		; EXT Interrupt 1
  266:	  0013	02 30 13		LJMP	USERRAM+13h
  267:	  0016	81 42			AJMP	WRDPTR

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  268:	  0018	81 5C			AJMP	WRSTR
  269:		N      001B		ORG	ROM+001Bh		; Timer1 - Single step
  270:	  001B	02 07 E6		LJMP	SSINT
  271:	  001E	81 D8			AJMP	RDCHR
  272:	  0020	81 A8			AJMP	RDNIB
  273:		N      0023		ORG	ROM+0023h		; RI+TI interrupt
  274:	  0023	02 30 23		LJMP	USERRAM+23h
  275:	  0026	81 9C			AJMP	RDHEX
  276:	  0028	81 96			AJMP	RDWORD
  277:		N      002B		ORG	ROM+002Bh		; TF2+EXF2
  278:	  002B	02 30 2B		LJMP	USERRAM+2Bh
  279:				;
  280:	  002E	81 2C			AJMP	RDRANGE
  281:	  0030	81 1F			AJMP	RDADDR
  282:	  0032	81 F1			AJMP	CHKCHR
  283:	  0034	81 FA			AJMP	FLUSH
  284:	  0036	A1 95			AJMP	COMP
  285:	  0038	A1 25			AJMP	DLOAD
  286:				; Prompt for and execute commands
  287:	  003A			FPROMPT:
  288:	  003A	91 FA			ACALL	FLUSH		; Clear out serial port
  289:	  003C			PROMPT:
  290:	  003C	75 81 07		MOV	SP,#STACK		; Set up stack
  291:	  003F	75 7F 00		MOV	OUTFLAG,#0		; Clear output flag
  292:	  0042	91 65			ACALL	WRLFCR		; New line
  293:	  0044	74 2A			MOV	A,#'*'			; Prompt character
  294:	  0046	91 8E			ACALL	WRCHR		; Write it out
  295:	  0048	91 D8			ACALL	RDCHR		; Read the command charecter
  296:	  004A	FF			MOV	R7,A			; Save command for later
  297:	  004B	91 8E			ACALL	WRCHR		; Echo it
  298:	  004D	91 8C			ACALL	WRSPC		; Separator
  299:				;
  300:				; 'D'ump EXTERNAL memory command
  301:				;
  302:	  004F			DUMPO:
  303:	  004F	BF 44 48		CJNE	R7,#'D',DUMPI	; No, try next
  304:	  0052	91 1F			ACALL	RDADDR		; Get starting address
  305:	  0054	91 2C			ACALL	RDRANGE		; Get ending address
  306:				; Display one line
  307:	  0056			DUMP1:
  308:	  0056	91 65			ACALL	WRLFCR		; New line
  309:	  0058	91 42			ACALL	WRDPTR		; Output address
  310:	  005A	C0 83			PUSH	DP0H			; Save high
  311:	  005C	C0 82			PUSH	DP0L			; Save low
  312:	  005E	7F 10			MOV	R7,#16			; 16 bytes/line
  313:				; Display the HEX dump
  314:	  0060			DUMP1A:
  315:	  0060	EF			MOV	A,R7			; Get count
  316:	  0061	54 03			ANL	A,#00000011b	; Test lower two
  317:	  0063	70 02			JNZ	DUMP1B			; No extra space
  318:	  0065	91 8C			ACALL	WRSPC		; Output a space
  319:	  0067			DUMP1B:
  320:	  0067	91 8C			ACALL	WRSPC		; Output a space
  321:	  0069	E0			MOVX	A,@DPTR	; Get byte
  322:	  006A	91 48			ACALL	WRHEX		; Write in hex
  323:	  006C	A3			INC	DPTR			; Advance to next

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  324:	  006D	DF F1			DJNZ	R7,DUMP1A	; Do em all
  325:	  006F	91 8C			ACALL	WRSPC		; Output a spave
  326:	  0071	91 8C			ACALL	WRSPC		; Another space
  327:				; Display the ASCII dump
  328:	  0073	D0 82			POP	DP0L				; Restore low
  329:	  0075	D0 83			POP	DP0H				; Restore high
  330:	  0077	7F 10			MOV	R7,#16			; Length of line
  331:	  0079	7B 20			MOV	R3,#' '			; Low bounds
  332:	  007B	7C 7F			MOV	R4,#127			; High bounds
  333:	  007D			DUMP1C:
  334:	  007D	E0			MOVX	A,@DPTR	; Get byte
  335:	  007E	B1 95			ACALL	COMP		; Do the compare
  336:	  0080	50 02			JNC	DUMP1D			; OK to output
  337:	  0082	74 2E			MOV	A,#'.'			; Convert to '.'
  338:	  0084			DUMP1D:
  339:	  0084	91 8E			ACALL	WRCHR		; Write it out
  340:	  0086	A3			INC	DPTR			; Next location
  341:	  0087	DF F4			DJNZ	R7,DUMP1C	; Do them all
  342:				; Stop looking if we are over
  343:	  0089	C3			CLR	C				; Insure no borrow
  344:	  008A	ED			MOV	A,R5			; Get Low
  345:	  008B	95 82			SUBB	A,DP0L		; Convert
  346:	  008D	EE			MOV	A,R6			; Get high
  347:	  008E	95 83			SUBB	A,DP0H		; Test it
  348:	  0090	50 C4			JNC	DUMP1			; More to Go
  349:				; Return to the main command line
  350:	  0092			DUMP1E:
  351:	  0092	01 3C			AJMP	PROMPT		; Back for more
  352:				; Report an error
  353:	  0094			ERROR1:
  354:	  0094	74 3F			MOV	A,#'?'			; Error
  355:	  0096	91 8E			ACALL	WRCHR		; Output
  356:	  0098			PROMPT1:
  357:	  0098	01 3C			AJMP	PROMPT		; Next command
  358:				;
  359:				; 'I'internal memory dump
  360:				;
  361:	  009A			DUMPI:
  362:	  009A	BF 49 27		CJNE	R7,#'I',EDITE	; No, try next
  363:	  009D	91 9C			ACALL	RDHEX		; Get address
  364:	  009F	40 F3			JC	ERROR1			; Invalid
  365:	  00A1	F8			MOV	R0,A			; Save in index
  366:	  00A2	74 2C			MOV	A,#','			; Separator
  367:	  00A4	91 8E			ACALL	WRCHR		; Output it
  368:	  00A6	91 9C			ACALL	RDHEX		; Get end
  369:	  00A8	40 EA			JC	ERROR1			; Invalid
  370:	  00AA	FC			MOV	R4,A			; Write it
  371:				; Display one line
  372:	  00AB			DUMP2:
  373:	  00AB	91 65			ACALL	WRLFCR		; New line
  374:	  00AD	E8			MOV	A,R0			; Get high byte
  375:	  00AE	91 48			ACALL	WRHEX		; Output
  376:	  00B0	7D 08			MOV	R5,#8			; Size of line
  377:	  00B2	91 8C			ACALL	WRSPC		; Output a space
  378:				; Display the HEX dump
  379:	  00B4			DUMP2A:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  380:	  00B4	91 8C			ACALL	WRSPC		; Output a space
  381:	  00B6	F1 37			ACALL	RDINTM		; Read internal memory
  382:	  00B8	91 48			ACALL	WRHEX		; Write in hex
  383:	  00BA	E8			MOV	A,R0			; Get address
  384:	  00BB	C3			CLR	C				; Insure no borrow
  385:	  00BC	9C			SUBB	A,R4		; Calculate remaining
  386:	  00BD	50 D3			JNC	DUMP1E			; We are all done
  387:	  00BF	08			INC	R0				; Advance to next
  388:	  00C0	DD F2			DJNZ	R5,DUMP2A	; Do em all
  389:	  00C2	80 E7			SJMP	DUMP2		; New line
  390:				;
  391:				; 'E'dit external memory
  392:				;
  393:	  00C4			EDITE:
  394:	  00C4	BF 45 27		CJNE	R7,#'E',EDITI	; No, try edit internl
  395:	  00C7	91 1F			ACALL	RDADDR		; Get a HEX value
  396:	  00C9			EDIT1:
  397:	  00C9	91 65			ACALL	WRLFCR		; New line
  398:	  00CB	91 42			ACALL	WRDPTR		; Output address
  399:	  00CD	91 8C			ACALL	WRSPC		; Output seperator
  400:	  00CF	E0			MOVX	A,@DPTR		; Get value
  401:	  00D0	91 48			ACALL	WRHEX		; Output
  402:	  00D2	74 2D			MOV	A,#'-'			; Prompt
  403:	  00D4	91 8E			ACALL	WRCHR		; Output
  404:	  00D6	91 9C			ACALL	RDHEX		; Get value
  405:	  00D8	40 04			JC	EDIT1B			; Error
  406:	  00DA	F0			MOVX	@DPTR,A		; Write it
  407:	  00DB			EDIT1A:
  408:	  00DB	A3			INC	DPTR			; Advance to next
  409:	  00DC	80 EB			SJMP	EDIT1		; And proceed
  410:	  00DE			EDIT1B:
  411:	  00DE	60 FB			JZ	EDIT1A			; Space, advance
  412:	  00E0	14			DEC	A				; Test for next
  413:	  00E1	70 B5			JNZ	PROMPT1			; And continue
  414:	  00E3	15 82			DEC	DP0L				; Reduce low
  415:	  00E5	E5 82			MOV	A,DP0L			; Get value
  416:	  00E7	B4 FF DF		CJNE	A,#0FFh,EDIT1	; No overflow
  417:	  00EA	15 83			DEC	DP0H				; Backspace
  418:	  00EC	80 DB			SJMP	EDIT1		; And proceed
  419:				;
  420:				; 'A'lter internal memory
  421:				;
  422:	  00EE			EDITI:
  423:	  00EE	BF 41 25		CJNE	R7,#'A',LOAD	; No, try next
  424:	  00F1	91 9C			ACALL	RDHEX		; Get a HEX value
  425:	  00F3	40 9F			JC	ERROR1			; Invalid
  426:	  00F5	F8			MOV	R0,A			; Save address
  427:	  00F6			EDIT2:
  428:	  00F6	91 65			ACALL	WRLFCR		; New line
  429:	  00F8	E8			MOV	A,R0			; Get address
  430:	  00F9	91 48			ACALL	WRHEX		; Output address
  431:	  00FB	91 8C			ACALL	WRSPC		; Output seperator
  432:	  00FD	F1 37			ACALL	RDINTM		; Read internal memory
  433:	  00FF	91 48			ACALL	WRHEX		; Output
  434:	  0101	74 2D			MOV	A,#'-'			; Prompt
  435:	  0103	91 8E			ACALL	WRCHR		; Output

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  436:	  0105	91 9C			ACALL	RDHEX		; Get value
  437:	  0107	40 05			JC	EDIT2B			; Error
  438:	  0109	F1 50			ACALL	WRINTM		; Write internal memory
  439:	  010B			EDIT2A:
  440:	  010B	08			INC	R0				; Advance to next
  441:	  010C	80 E8			SJMP	EDIT2		; And proceed
  442:	  010E			EDIT2B:
  443:	  010E	60 FB			JZ	EDIT2A			; Space, advance
  444:	  0110	14			DEC	A				; Test for next
  445:	  0111	70 85			JNZ	PROMPT1			; And continue
  446:	  0113	18			DEC	R0				; Backspace
  447:	  0114	80 E0			SJMP	EDIT2		; And proceed
  448:				;
  449:				; Load an image from the serial port
  450:				;
  451:	  0116			LOAD:
  452:	  0116	BF 4C 16		CJNE	R7,#'L',GOCMD	; No, try next
  453:	  0119	91 65			ACALL	WRLFCR		; New line
  454:	  011B	E4			CLR	A				; Get zero
  455:	  011C	F9			MOV	R1,A			; Zero LOW
  456:	  011D	FA			MOV	R2,A			; Zero HIGH
  457:	  011E			LOAD1:
  458:	  011E	B1 25			ACALL	DLOAD		; Get a record
  459:	  0120	50 FC			JNC	LOAD1			; And keep getting em
  460:	  0122	EA			MOV	A,R2			; Get HIGH
  461:	  0123	91 48			ACALL	WRHEX		; Output
  462:	  0125	E9			MOV	A,R1			; Get LOW
  463:	  0126	91 48			ACALL	WRHEX		; Output
  464:	  0128	90 08 51		MOV	DPTR,#M_BYTES	; Point to ' Bytes' message
  465:	  012B	91 5C			ACALL	WRSTR		; Output string
  466:	  012D	01 3A			AJMP	FPROMPT		; End of the line
  467:				;
  468:				; Go (begin execution) at the specified address)
  469:				;
  470:	  012F			GOCMD:
  471:	  012F	BF 47 7C		CJNE	R7,#'G',STEP	; No, try next
  472:	  0132	91 00			ACALL	GETPC		; Get address
  473:	  0134	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
  474:	  0137	E0			MOVX	A,@DPTR		; Get HIGH PC
  475:	  0138	FA			MOV	R2,A			; Save for later
  476:	  0139	A3			INC	DPTR			; Advance
  477:	  013A	E0			MOVX	A,@DPTR		; Get LOW PC
  478:	  013B	F9			MOV	R1,A			; Save for later
  479:	  013C	F1 B2			ACALL	TESTBRK		; Check for breakpoint conflict
  480:	  013E	91 65			ACALL	WRLFCR		; New line
  481:				; Insert breakpoints in user code
  482:	  0140	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint table
  483:	  0143	78 00			MOV	R0,#0			; Zero counter
  484:	  0145			GOC1:
  485:	  0145	E0			MOVX	A,@DPTR		; Get HIGH address
  486:	  0146	FC			MOV	R4,A			; Save for later
  487:	  0147	A3			INC	DPTR			; Advance
  488:	  0148	E0			MOVX	A,@DPTR		; Get LOW address
  489:	  0149	FB			MOV	R3,A			; Save for later
  490:	  014A	A3			INC	DPTR			; Advance
  491:	  014B	4C			ORL	A,R4			; Breakpoint set?

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  492:	  014C	60 12			JZ	GOC2			; No, skip it
  493:	  014E	F1 07			ACALL	SDP43		; R4:3 <> DPTR
  494:	  0150	7F 12			MOV	R7,#12h		; LCALL Instruction
  495:	  0152	31 A6			ACALL	PATCHBP		; Patch breakpoint
  496:	  0154	7F 07			MOV	R7,#HIGH(BREAKPT)	; HIGH address
  497:	  0156	31 A6			ACALL	PATCHBP		; Patch breakpoint
  498:	  0158	7F 6D			MOV	R7,#LOW(BREAKPT)		; LOW address
  499:	  015A	31 A6			ACALL	PATCHBP		; Patch breakpoint
  500:	  015C	F1 07			ACALL	SDP43		; Swap back
  501:	  015E	80 03			SJMP	GOC3		; And proceed
  502:	  0160			GOC2:
  503:	  0160	A3			INC	DPTR			; Skip 1
  504:	  0161	A3			INC	DPTR			; Skip 2
  505:	  0162	A3			INC	DPTR			; Skip 3
  506:	  0163			GOC3:
  507:	  0163	08			INC	R0				; Skip 4
  508:	  0164	B8 04 DE		CJNE	R0,#NBREAK,GOC1
  509:				; Restore the user registers & execute at user PC
  510:	  0167	90 F7 89		MOV	DPTR,#MRSAVE+6	; Point to memory save area
  511:	  016A	78 01			MOV	R0,#1			; Start at location1
  512:	  016C			GOC4:
  513:	  016C	E0			MOVX	A,@DPTR		; Get value
  514:	  016D	F6			MOV	@R0,A			; Save in memory
  515:	  016E	A3			INC	DPTR			; Advance to next
  516:	  016F	08			INC	R0				; Advance pointer
  517:	  0170	B8 20 F9		CJNE	R0,#MSSIZE,GOC4	; Do them all
  518:				; Restore users STACK pointer
  519:	  0173	90 F7 82		MOV	DPTR,#SPSAVE	; Point to SP save area
  520:	  0176	E0			MOVX	A,@DPTR		; Restore
  521:	  0177	F5 81			MOV	SP,A			; Set User SP
  522:				; Restore users program counter
  523:	  0179	90 F7 80		MOV	DPTR,#PCSAVE	; Point to save area
  524:	  017C	E0			MOVX	A,@DPTR		; Get HIGH pc
  525:	  017D	F5 F0			MOV	B,A				; Save for later
  526:	  017F	A3			INC	DPTR			; Advance
  527:	  0180	E0			MOVX	A,@DPTR		; Get LOW pc
  528:	  0181	C0 E0			PUSH	ACC			; Save LOW
  529:	  0183	C0 F0			PUSH	B			; Save HIGH
  530:				; Restore users registers
  531:	  0185	90 F7 83		MOV	DPTR,#MRSAVE	; Point to memory save area
  532:	  0188	E0			MOVX	A,@DPTR		; Restore 'A'
  533:	  0189	C0 E0			PUSH	ACC
  534:	  018B	A3			INC	DPTR
  535:	  018C	E0			MOVX	A,@DPTR		; Restore 'B'
  536:	  018D	F5 F0			MOV	B,A
  537:	  018F	A3			INC	DPTR
  538:	  0190	E0			MOVX	A,@DPTR		; Restore PSW
  539:	  0191	F5 D0			MOV	PSW,A
  540:	  0193	A3			INC	DPTR
  541:	  0194	E0			MOVX	A,@DPTR		; Restore DP0H
  542:	  0195	C0 E0			PUSH	ACC
  543:	  0197	A3			INC	DPTR
  544:	  0198	E0			MOVX	A,@DPTR		; Restore DP0L
  545:	  0199	C0 E0			PUSH	ACC
  546:	  019B	A3			INC	DPTR
  547:	  019C	E0			MOVX	A,@DPTR		; Restore R0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  548:	  019D	F5 00			MOV	0,A				; Restore memory
  549:	  019F	D0 82			POP	DP0L				; Restore DP0L
  550:	  01A1	D0 83			POP	DP0H				; Restore DP0H
  551:	  01A3	D0 E0			POP	ACC				; Restore ACC
  552:	  01A5	22			RET					; Dispatch to user program
  553:				; Patch user program with breakpoint
  554:	  01A6			PATCHBP:
  555:	  01A6	E4			CLR	A				; Zero offset
  556:	  01A7	93			MOVC	A,@A+DPTR	; Get byte of code
  557:	  01A8	F1 03			ACALL	WR43		; Write to table
  558:	  01AA	EF			MOV	A,R7			; LCALL Instruction
  559:				; ??? Write to code memory
  560:	  01AB	F0			MOVX	@DPTR,A	; Patch code
  561:	  01AC	A3			INC	DPTR			; Skip to next
  562:	  01AD	22			RET
  563:				;
  564:				; Single step one instruction
  565:				;
  566:	  01AE			STEP:
  567:	  01AE	BF 53 62		CJNE	R7,#'S',RDUMP	; No, try next
  568:	  01B1	90 F7 80		MOV	DPTR,#PCSAVE	; Point to saved PC
  569:	  01B4	E0			MOVX	A,@DPTR		; Get HIGH
  570:	  01B5	A3			INC	DPTR			; Advance
  571:	  01B6	FA			MOV	R2,A			; Save
  572:	  01B7	E0			MOVX	A,@DPTR		; Get LOW
  573:	  01B8	F9			MOV	R1,A			; Save
  574:	  01B9	B1 A4			ACALL	DODISS		; Display on screen
  575:	  01BB	91 FA			ACALL	FLUSH		; Wait for TX complete
  576:				; Setup timer-1 for single step interrupt
  577:	  01BD	C2 8E			CLR	TCON.6			; Stop timer1
  578:	  01BF	E5 89			MOV	A,TMOD			; Get timer mode
  579:	  01C1	54 0F			ANL	A,#00001111b	; Zero timer1 mode
  580:	  01C3	45 10			ORL	A,00010000b	; Timer1 16 bit
  581:	  01C5	F5 89			MOV	TMOD,A			; Resave new timer mode
  582:	  01C7	75 8D FF		MOV	TH1,#0FFh		; -1
  583:	  01CA	75 8B FE		MOV	TL1,#0FEh		; -2
  584:	  01CD	C2 8F			CLR	TCON.7			; Clear timer1 int pend
  585:				; Restore the user register memory
  586:	  01CF	90 F7 89		MOV	DPTR,#MRSAVE+6	; Point to memory save area
  587:	  01D2	78 01			MOV	R0,#1			; Start at location1
  588:	  01D4			STEP1:
  589:	  01D4	E0			MOVX	A,@DPTR		; Get value
  590:	  01D5	F6			MOV	@R0,A			; Save in memory
  591:	  01D6	A3			INC	DPTR			; Advance to next
  592:	  01D7	08			INC	R0				; Advance pointer
  593:	  01D8	B8 20 F9		CJNE	R0,#MSSIZE,STEP1 ; Do them all
  594:				; Restore users STACK pointer
  595:	  01DB	90 F7 82		MOV	DPTR,#SPSAVE	; Point to SP save area
  596:	  01DE	E0			MOVX	A,@DPTR		; Restore
  597:	  01DF	F5 81			MOV	SP,A			; Set User SP
  598:				; Restore users program counter
  599:	  01E1	90 F7 80		MOV	DPTR,#PCSAVE	; Point to save area
  600:	  01E4	E0			MOVX	A,@DPTR		; Get HIGH pc
  601:	  01E5	F5 F0			MOV	B,A				; Save for later
  602:	  01E7	A3			INC	DPTR			; Advance
  603:	  01E8	E0			MOVX	A,@DPTR		; Get LOW pc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  604:	  01E9	C0 E0			PUSH	ACC			; Save LOW
  605:	  01EB	C0 F0			PUSH	B			; Save HIGH
  606:				; Restore users registers
  607:	  01ED	90 F7 83		MOV	DPTR,#MRSAVE	; Point to memory save area
  608:	  01F0	E0			MOVX	A,@DPTR		; Restore 'A'
  609:	  01F1	C0 E0			PUSH	ACC
  610:	  01F3	A3			INC	DPTR
  611:	  01F4	E0			MOVX	A,@DPTR		; Restore 'B'
  612:	  01F5	F5 F0			MOV	B,A
  613:	  01F7	A3			INC	DPTR
  614:	  01F8	E0			MOVX	A,@DPTR		; Restore PSW
  615:	  01F9	F5 D0			MOV	PSW,A
  616:	  01FB	A3			INC	DPTR
  617:	  01FC	E0			MOVX	A,@DPTR		; Restore DP0H
  618:	  01FD	C0 E0			PUSH	ACC
  619:	  01FF	A3			INC	DPTR
  620:	  0200	E0			MOVX	A,@DPTR		; Restore DP0L
  621:	  0201	C0 E0			PUSH	ACC
  622:	  0203	A3			INC	DPTR
  623:	  0204	E0			MOVX	A,@DPTR		; Restore R0
  624:	  0205	F5 00			MOV	0,A				; Restore memory
  625:	  0207	D0 82			POP	DP0L				; Restore DP0L
  626:	  0209	D0 83			POP	DP0H				; Restore DP0H
  627:	  020B	D0 E0			POP	ACC				; Restore ACC
  628:				; Activate the timer
  629:	  020D	43 A8 88		ORL	IE,#10001000b	; Enable Timer1 interrupt
  630:	  0210	D2 8E			SETB	TCON.6		; Enable timer1
  631:	  0212	22			RET					; Execute user program
  632:				;
  633:				; Dump user registers
  634:				;
  635:	  0213			RDUMP:
  636:	  0213	BF 52 2F		CJNE	R7,#'R',CHREG	; No, try next
  637:	  0216	90 F7 85		MOV	DPTR,#MRSAVE+2	; Point to user PSW
  638:	  0219	E0			MOVX	A,@DPTR		; Get user PSW
  639:	  021A	FE			MOV	R6,A			; Save for later
  640:	  021B	90 09 5A		MOV	DPTR,#RNTABLE	; Point to register names
  641:	  021E	78 00			MOV	R0,#0			; Zero offset
  642:				; Display next register from bank
  643:	  0220			RDUMP1:
  644:	  0220	91 5C			ACALL	WRSTR		; Output value
  645:	  0222	C0 83			PUSH	DP0H			; Save HIGH
  646:	  0224	C0 82			PUSH	DP0L			; Save LOW
  647:	  0226	75 83 F7		MOV	DP0H,#HIGH(PCSAVE)	; Point to memory buffer
  648:	  0229	74 80			MOV	A,#LOW(PCSAVE)		; Point to low
  649:	  022B	28			ADD	A,R0			; Include offset
  650:	  022C	08			INC	R0				; Advance offset
  651:	  022D	F5 82			MOV	DP0L,A			; Save low value
  652:	  022F	E0			MOVX	A,@DPTR		; Get value
  653:	  0230	D0 82			POP	DP0L				; Restore LOW
  654:	  0232	D0 83			POP	DP0H				; Restore HIGH
  655:	  0234	91 48			ACALL	WRHEX		; Output value
  656:				; Test for second line... = Registers
  657:	  0236	E4			CLR	A				; Zero offset
  658:	  0237	93			MOVC	A,@A+DPTR	; More data?
  659:	  0238	B4 0A 05		CJNE	A,#0Ah,RDUMP2	; Not special case

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  660:	  023B	EE			MOV	A,R6			; Get user PSW
  661:	  023C	54 18			ANL	A,#00011000b	; Save only rbank
  662:	  023E	28			ADD	A,R0			; Offset to bank
  663:	  023F	F8			MOV	R0,A			; Resave
  664:	  0240			RDUMP2:
  665:	  0240	30 E7 DD		JNB	ACC.7,RDUMP1		; Yes, output
  666:	  0243	01 3C			AJMP	PROMPT		; Next command
  667:				;
  668:				; Change user register
  669:				;
  670:	  0245			CHREG:
  671:	  0245	BF 43 53		CJNE	R7,#'C',FILL	; Change resgister?
  672:	  0248	91 D8			ACALL	RDCHR		; Get register name
  673:	  024A	FF			MOV	R7,A			; Save for later
  674:	  024B	91 8E			ACALL	WRCHR		; Echo it
  675:	  024D	91 8C			ACALL	WRSPC		; Output
  676:	  024F	90 F7 80		MOV	DPTR,#PCSAVE	; Point to table
  677:	  0252	BF 50 02		CJNE	R7,#'P',$+5	; PC?
  678:	  0255	80 21			SJMP	CHRE2		; Save two bytes
  679:	  0257	A3			INC	DPTR
  680:	  0258	A3			INC	DPTR
  681:	  0259	BF 53 02		CJNE	R7,#'S',$+5	; SP?
  682:	  025C	80 37			SJMP	CHRE1		; Save one byte
  683:	  025E	A3			INC	DPTR
  684:	  025F	BF 41 02		CJNE	R7,#'A',$+5	; ACC?
  685:	  0262	80 31			SJMP	CHRE1		; Save one byte
  686:	  0264	A3			INC	DPTR
  687:	  0265	BF 42 02		CJNE	R7,#'B',$+5	; B?
  688:	  0268	80 2B			SJMP	CHRE1		; Save one byte
  689:	  026A	A3			INC	DPTR
  690:	  026B	E0			MOVX	A,@DPTR		; Get PSW
  691:	  026C	54 18			ANL	A,#00011000b	; Save Register bits
  692:	  026E	FE			MOV	R6,A			; Save PSW
  693:	  026F	BF 57 02		CJNE	R7,#'W',$+5	; PSW?
  694:	  0272	80 21			SJMP	CHRE1		; Save one byte
  695:	  0274	A3			INC	DPTR
  696:	  0275	BF 44 0D		CJNE	R7,#'D',CHRE4	; DPTR?
  697:				; Write a 16 bit register value
  698:	  0278			CHRE2:
  699:	  0278	91 96			ACALL	RDWORD		; Get WORD
  700:	  027A	40 1D			JC	ERROR2			; Error
  701:	  027C	C5 F0			XCH	A,B				; Get High
  702:	  027E	F0			MOVX	@DPTR,A		; Write to memory
  703:	  027F	A3			INC	DPTR			; Advance
  704:	  0280	E5 F0			MOV	A,B				; Get second byte
  705:	  0282			CHRE3:
  706:	  0282	F0			MOVX	@DPTR,A		; Save
  707:	  0283	01 3C			AJMP	PROMPT
  708:				; Set R0-R7 in current register bank
  709:	  0285			CHRE4:
  710:	  0285	EF			MOV	A,R7			; Get char back
  711:	  0286	7B 30			MOV	R3,#'0'			; Low bound
  712:	  0288	7C 38			MOV	R4,#'7'+1		; High bound
  713:	  028A	B1 95			ACALL	COMP		; In range?
  714:	  028C	40 0B			JC	ERROR2			; No, report error
  715:	  028E	94 30			SUBB	A,#'0'		; Convert to binary

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  716:	  0290	4E			ORL	A,R6			; Offset to bank
  717:	  0291	24 88			ADD	A,#LOW(MRSAVE+5)		; Point to registers
  718:	  0293	F5 82			MOV	DP0L,A			; Set up DP0L
  719:				; Write an 8 bit register value
  720:	  0295			CHRE1:
  721:	  0295	91 9C			ACALL	RDHEX		; Get BYTE
  722:	  0297	50 E9			JNC	CHRE3			; Ok to write
  723:				; Not a recognized command
  724:	  0299			ERROR2:
  725:	  0299	01 94			AJMP	ERROR1		; Report error
  726:				;
  727:				; Fill memory
  728:				;
  729:	  029B			FILL:
  730:	  029B	BF 46 19		CJNE	R7,#'F',UNASS	; Fill?
  731:	  029E	91 1F			ACALL	RDADDR		; Get address
  732:	  02A0	91 2C			ACALL	RDRANGE		; Get range
  733:	  02A2	91 8C			ACALL	WRSPC		; Output space
  734:	  02A4	91 9C			ACALL	RDHEX		; Get byte value
  735:	  02A6	40 F1			JC	ERROR2			; Report error
  736:	  02A8	FF			MOV	R7,A			; Save data
  737:	  02A9			FILL1:
  738:	  02A9	EF			MOV	A,R7			; Get byte
  739:	  02AA	F0			MOVX	@DPTR,A		; Write to data
  740:	  02AB	A3			INC	DPTR			; Advance to next
  741:	  02AC	C3			CLR	C				; Insure no borrow
  742:	  02AD	ED			MOV	A,R5			; Get Low
  743:	  02AE	95 82			SUBB	A,DP0L		; Convert
  744:	  02B0	EE			MOV	A,R6			; Get high
  745:	  02B1	95 83			SUBB	A,DP0H		; Test it
  746:	  02B3	50 F4			JNC	FILL1			; More to Go
  747:	  02B5	01 3C			AJMP	PROMPT		; Next command
  748:				;
  749:				; Un-assemble memory
  750:				;
  751:	  02B7			UNASS:
  752:	  02B7	BF 55 15		CJNE	R7,#'U',BRKPT	; No, try next
  753:	  02BA	91 1F			ACALL	RDADDR		; Get address
  754:	  02BC	AA 83			MOV	R2,DP0H			; Set high byte
  755:	  02BE	A9 82			MOV	R1,DP0L			; Set low byte
  756:	  02C0	91 2C			ACALL	RDRANGE		; Get ending address
  757:	  02C2			UNASS1:
  758:	  02C2	91 65			ACALL	WRLFCR		; New line
  759:	  02C4	B1 A4			ACALL	DODISS		; Output text
  760:	  02C6	C3			CLR	C				; Insure no borrow
  761:	  02C7	ED			MOV	A,R5			; Get Low
  762:	  02C8	99			SUBB	A,R1		; Convert
  763:	  02C9	EE			MOV	A,R6			; Get high
  764:	  02CA	9A			SUBB	A,R2		; Test it
  765:	  02CB	50 F5			JNC	UNASS1			; More to Go
  766:	  02CD	01 3C			AJMP	PROMPT		; Back for more
  767:				;
  768:				; Examine/Change breakpoints
  769:				;
  770:	  02CF			BRKPT:
  771:	  02CF	BF 42 67		CJNE	R7,#'B',QUERY	; Breakpoint?

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  772:	  02D2	91 D8			ACALL	RDCHR		; Get character
  773:	  02D4	B4 20 25		CJNE	A,#' ',BRKPT2	; Set breakpoint
  774:				; Display the breakpoints
  775:	  02D7	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to table
  776:	  02DA	7F 00			MOV	R7,#0			; Count
  777:	  02DC			BRKPT1:
  778:	  02DC	74 42			MOV	A,#'B'			; Get 'B'
  779:	  02DE	91 8E			ACALL	WRCHR		; Output
  780:	  02E0	EF			MOV	A,R7			; Get number
  781:	  02E1	24 30			ADD	A,#'0'			; Convert to ASCII
  782:	  02E3	91 8E			ACALL	WRCHR		; Output
  783:	  02E5	74 3D			MOV	A,#'='			; Seperator
  784:	  02E7	91 8E			ACALL	WRCHR		; Output
  785:	  02E9	E0			MOVX	A,@DPTR		; Get address
  786:	  02EA	A3			INC	DPTR			; Skip to next
  787:	  02EB	91 48			ACALL	WRHEX		; Output
  788:	  02ED	E0			MOVX	A,@DPTR		; Get next address
  789:	  02EE	A3			INC	DPTR			; Skip to next
  790:	  02EF	91 48			ACALL	WRHEX		; Output
  791:	  02F1	A3			INC	DPTR			; Skip opcode
  792:	  02F2	A3			INC	DPTR			; ""
  793:	  02F3	A3			INC	DPTR			; ""
  794:	  02F4	91 8C			ACALL	WRSPC		; Space over
  795:	  02F6	0F			INC	R7				; Advance count
  796:	  02F7	BF 04 E2		CJNE	R7,#NBREAK,BRKPT1 ; Show them all
  797:	  02FA	01 3C			AJMP	PROMPT
  798:				; Set a breakpoint
  799:	  02FC			BRKPT2:
  800:	  02FC	7B 30			MOV	R3,#'0'			; Lower limit
  801:	  02FE	7C 34			MOV	R4,#'0'+NBREAK	; Upper limit
  802:	  0300	B1 95			ACALL	COMP		; In range?
  803:	  0302	40 95			JC	ERROR2			; Error
  804:	  0304	91 8E			ACALL	WRCHR		; Echo it
  805:	  0306	C3			CLR	C				; Zero carry
  806:	  0307	94 30			SUBB	A,#'0'		; Convert to binary
  807:	  0309	FE			MOV	R6,A			; Copy
  808:	  030A	91 8C			ACALL	WRSPC		; Space over
  809:	  030C	91 96			ACALL	RDWORD		; Get word
  810:	  030E	40 89			JC	ERROR2			; Report error
  811:	  0310	C0 E0			PUSH	ACC			; Save for later
  812:	  0312	C0 F0			PUSH	B			; Save for later
  813:	  0314	AA F0			MOV	R2,B			; Set HIGH
  814:	  0316	F9			MOV	R1,A			; Set LOW
  815:	  0317	F1 B2			ACALL	TESTBRK		; Check for conflicts
  816:	  0319	C9			XCH	A,R1			; Get value
  817:	  031A	24 02			ADD	A,#2			; Adjust for new break
  818:	  031C	C9			XCH	A,R1
  819:	  031D	CA			XCH	A,R2
  820:	  031E	34 00			ADDC	A,#0
  821:	  0320	CA			XCH	A,R2
  822:	  0321	F1 B2			ACALL	TESTBRK		; Check again
  823:	  0323	EE			MOV	A,R6			; Get
  824:	  0324	23			RL	A				; X2
  825:	  0325	23			RL	A				; X4
  826:	  0326	54 FC			ANL	A,#11111100b	; Mask wrap
  827:	  0328	2E			ADD	A,R6			; X5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  828:	  0329	24 A8			ADD	A,#LOW(BRKTAB)		; Point to breakpoint table
  829:	  032B	F5 82			MOV	DP0L,A			; Set LOW address
  830:	  032D	75 83 F7		MOV	DP0H,#HIGH(BRKTAB)	; Set HIGH address
  831:	  0330	D0 E0			POP	ACC				; Restore HIGH
  832:	  0332	F0			MOVX	@DPTR,A		; Set HIGH
  833:	  0333	A3			INC	DPTR			; Advance
  834:	  0334	D0 E0			POP	ACC				; Restore LOW
  835:	  0336	F0			MOVX	@DPTR,A		; Set LOW
  836:	  0337	01 3C			AJMP	PROMPT
  837:				;
  838:				; Query SFR register
  839:				;
  840:	  0339			QUERY:
  841:	  0339	BF 51 21		CJNE	R7,#'Q',OUTPUT	; Query?
  842:	  033C	71 46			ACALL	GETSFR		; Get SFR address
  843:	  033E	78 E5			MOV	R0,#0E5h		; Indicate reading (MOV A,d)
  844:	  0340	71 6B			ACALL	DOXSUB		; Read the data
  845:	  0342	91 48			ACALL	WRHEX		; And display the value
  846:	  0344	01 3C			AJMP	PROMPT
  847:				; Get SFR address and display
  848:	  0346			GETSFR:
  849:	  0346	91 9C			ACALL	RDHEX		; Get address
  850:	  0348	F9			MOV	R1,A			; Save address
  851:	  0349	7C F7			MOV	R4,#HIGH(MBUFFER)	; Point to buffer
  852:	  034B	7B BC			MOV	R3,#LOW(MBUFFER)		; Point
  853:	  034D	D1 C3			ACALL	DIRECT		; Get value
  854:	  034F	E4			CLR	A				; Get zero
  855:	  0350	F1 03			ACALL	WR43		; Zero terminate
  856:	  0352	91 8C			ACALL	WRSPC		; Space over
  857:	  0354	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
  858:	  0357	91 5C			ACALL	WRSTR		; Output
  859:	  0359	74 3D			MOV	A,#'='			; Indicator
  860:	  035B	81 8E			AJMP	WRCHR		; Output
  861:
  862:				;
  863:				; Write SFR register
  864:				;
  865:	  035D			OUTPUT:
  866:	  035D	BF 4F 1B		CJNE	R7,#'O',XLOOP	; Output request
  867:	  0360	71 46			ACALL	GETSFR		; Get address
  868:	  0362	91 9C			ACALL	RDHEX		; Get data
  869:	  0364	FA			MOV	R2,A			; Save data
  870:	  0365	78 F5			MOV	R0,#0F5h		; Indicate writing (MOV d,A)
  871:	  0367	71 6B			ACALL	DOXSUB		; Write the data
  872:	  0369	01 3C			AJMP	PROMPT
  873:				; ??? Build subroutine in code memory to Read/Write SFR
  874:				; ??? Entry: R0 = $E5/$F5 R1=Address R2=Data(write only)
  875:	  036B			DOXSUB:
  876:	  036B	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
  877:	  036E	E8			MOV	A,R0			; Get prefix
  878:	  036F	F0			MOVX	@DPTR,A		; Write it
  879:	  0370	A3			INC	DPTR			; Advance to next
  880:	  0371	E9			MOV	A,R1			; Get address
  881:	  0372	F0			MOVX	@DPTR,A		; Write it
  882:	  0373	A3			INC	DPTR			; Advance to next
  883:	  0374	74 22			MOV	A,#22h			; 'RET' instruction

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

  884:	  0376	F0			MOVX	@DPTR,A		; Write it
  885:	  0377	EA			MOV	A,R2			; Get value
  886:	  0378	02 F7 BC		LJMP	MBUFFER		; Execute subroutine
  887:				;
  888:				; LOOP commands
  889:				;
  890:	  037B			XLOOP:
  891:	  037B	BF 58 33		CJNE	R7,#'X',WRITE	; No, try next
  892:	  037E	91 D8			ACALL	RDCHR		; Read the command charecter
  893:	  0380	FF			MOV	R7,A			; Save command for later
  894:	  0381	91 8E			ACALL	WRCHR		; Echo it
  895:	  0383	91 8C			ACALL	WRSPC		; Seperator
  896:	  0385	BF 52 0A		CJNE	R7,#'R',XLW
  897:	  0388	91 1F			ACALL	RDADDR		; Read address
  898:	  038A			XLR1:
  899:	  038A	E0			MOVX	A,@DPTR		; Read value
  900:	  038B	91 F1			ACALL	CHKCHR		; Check for character
  901:	  038D	B4 1B FA		CJNE	A,#1Bh,XLR1	; Do all
  902:	  0390	01 3C			AJMP	PROMPT
  903:	  0392			XLW:
  904:	  0392	BF 57 0E		CJNE	R7,#'W',XLC
  905:	  0395	91 1F			ACALL	RDADDR		; Get address
  906:	  0397	91 8C			ACALL	WRSPC		; Space over
  907:	  0399	91 9C			ACALL	RDHEX		; Get data
  908:	  039B			XLW1:
  909:	  039B	F0			MOVX	@DPTR,A		; Write value
  910:	  039C	91 F1			ACALL	CHKCHR		; Check for character
  911:	  039E	B4 1B FA		CJNE	A,#1Bh,XLW1	; Do all
  912:	  03A1	01 3C			AJMP	PROMPT
  913:	  03A3			XLC:
  914:	  03A3	BF 43 1D		CJNE	R7,#'C',ERROR3
  915:	  03A6	91 1F			ACALL	RDADDR		; Get address
  916:	  03A8			XLC1:
  917:	  03A8	E4			CLR	A				; Zero offset
  918:	  03A9	93			MOVC	A,@A+DPTR	; Read it
  919:	  03AA	91 F1			ACALL	CHKCHR		; Character?
  920:	  03AC	B4 1B F9		CJNE	A,#1Bh,XLC1	; Do all
  921:	  03AF	01 3C			AJMP	PROMPT
  922:				;
  923:				; Single write to memory
  924:				;
  925:	  03B1			WRITE:
  926:	  03B1	BF 57 11		CJNE	R7,#'W',help
  927:	  03B4	12 04 1F		LCALL	RDADDR		; Get a HEX value
  928:	  03B7	12 04 8C		LCALL	WRSPC
  929:	  03BA	12 04 9C		LCALL	RDHEX
  930:	  03BD	40 04			JC	error3
  931:	  03BF	F0			MOVX	@DPTR,A
  932:	  03C0	02 00 3C		LJMP	PROMPT
  933:	  03C3			ERROR3:
  934:	  03C3	01 94			AJMP	ERROR1
  935:				;
  936:				; Help request
  937:				;
  938:	  03C5			HELP:
  939:	  03C5	BF 3F 28		CJNE	R7,#'?',REBOOT	; Help?

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

  940:	  03C8	90 0E 66		MOV	DPTR,#HTEXT		; Point to help text
  941:	  03CB			HELP1:
  942:	  03CB	91 65			ACALL	WRLFCR		; New line
  943:	  03CD	7F 19			MOV	R7,#25			; Width of screen
  944:	  03CF			HELP2:
  945:	  03CF	E4			CLR	A				; Zero offset
  946:	  03D0	93			MOVC	A,@A+DPTR	; Get char
  947:	  03D1	A3			INC	DPTR			; Advance
  948:	  03D2	60 0F			JZ	HELP4			; No suffix
  949:	  03D4	B4 7C 11		CJNE	A,#'|',HELP5	; Normal char
  950:	  03D7			HELP3:
  951:	  03D7	91 8C			ACALL	WRSPC		; Output a space
  952:	  03D9	DF FC			DJNZ	R7,HELP3	; And proceed
  953:	  03DB	74 2D			MOV	A,#'-'			; Seperator
  954:	  03DD	91 8E			ACALL	WRCHR		; Output
  955:	  03DF	91 8C			ACALL	WRSPC		; Another space
  956:	  03E1	91 5C			ACALL	WRSTR		; Output rest of
  957:	  03E3			HELP4:
  958:	  03E3	93			MOVC	A,@A+DPTR	; Get char (A already zero)
  959:	  03E4	70 E5			JNZ	HELP1			; Do all lines
  960:	  03E6	01 3C			AJMP	PROMPT		; Next command
  961:	  03E8			HELP5:
  962:	  03E8	91 8E			ACALL	WRCHR		; Echo character
  963:	  03EA	1F			DEC	R7				; Reduce count
  964:	  03EB	80 E2			SJMP	HELP2		; Handle next
  965:	  03ED			WGO:
  966:	  03ED	02 03 B1		LJMP	WRITE
  967:				;
  968:				; Reboot
  969:				;
  970:	  03F0			REBOOT:
  971:	  03F0	BF 5A D0		CJNE	R7,#'Z',ERROR3	; Help?
  972:	  03F3	90 F8 00		MOV		DPTR,#LATCH
  973:	  03F6	74 01			MOV		A,#01
  974:	  03F8	F0			MOVX	@DPTR,A		; Set nEA pin low
  975:	  03F9	A3			INC		DPTR
  976:	  03FA	F0			MOVX	@DPTR,A		; Separate program memory & data memory
  977:	  03FB	75 A7 C9		MOV		WDTCON,#0C9h	; Enable WDT with 1 second timeout
  978:	  03FE			REBOOT1:
  979:	  03FE	80 FE			SJMP	REBOOT1		; wait for WDT to timeout
  980:				;
  981:				; Get PC value... SP = current
  982:				;
  983:	  0400			GETPC:
  984:	  0400	91 96			ACALL	RDWORD		; Get value
  985:	  0402	40 0B			JC	GETP1			; Its OK
  986:	  0404	90 F7 80		MOV	DPTR,#PCSAVE	; Get value
  987:	  0407	C5 F0			XCH	A,B				; A = high
  988:	  0409	F0			MOVX	@DPTR,A		; Write HIGH
  989:	  040A	A3			INC	DPTR			; Advance
  990:	  040B	E5 F0			MOV	A,B				; Get LOW
  991:	  040D	F0			MOVX	@DPTR,A		; Set it
  992:	  040E	22			RET
  993:	  040F			GETP1:
  994:	  040F	70 B2			JNZ	ERROR3			; Not space
  995:	  0411	90 08 58		MOV	DPTR,#M_PC		; Point to '->' message

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

  996:	  0414	91 5C			ACALL	WRSTR		; Output
  997:	  0416	90 F7 80		MOV	DPTR,#PCSAVE	; Point to it
  998:	  0419	91 1B			ACALL	GETP2		; Output first byte
  999:	  041B			GETP2:
 1000:	  041B	E0			MOVX	A,@DPTR		; Get value
 1001:	  041C	A3			INC	DPTR			; Advance
 1002:	  041D	81 48			AJMP	WRHEX		; And proceed
 1003:				;
 1004:				; Read an address, abort on error
 1005:				;
 1006:	  041F			RDADDR:
 1007:	  041F	91 9C			ACALL	RDHEX		; Read high byte
 1008:	  0421	40 A0			JC	ERROR3			; Report error
 1009:	  0423	F5 83			MOV	DP0H,A			; Set DP0H
 1010:	  0425	91 9C			ACALL	RDHEX		; Read low byte
 1011:	  0427	40 9A			JC	ERROR3			; Report error
 1012:	  0429	F5 82			MOV	DP0L,A			; Set DP0L
 1013:	  042B	22			RET
 1014:				;
 1015:				; Read closing portion of range
 1016:				;
 1017:	  042C			RDRANGE:
 1018:	  042C	74 2C			MOV	A,#','			; Seperator
 1019:	  042E	91 8E			ACALL	WRCHR		; Output
 1020:	  0430	91 96			ACALL	RDWORD		; Get byte
 1021:	  0432	FD			MOV	R5,A			; Save LOW
 1022:	  0433	AE F0			MOV	R6,B			; Save HIGH
 1023:	  0435	50 5E			JNC	RET1			; Its OK
 1024:	  0437	70 8A			JNZ	ERROR3			; Report error
 1025:	  0439	74 FF			MOV	A,#0FFh			; Get FF
 1026:	  043B	FD			MOV	R5,A			; Assume END
 1027:	  043C	FE			MOV	R6,A			; Assume END
 1028:	  043D	91 48			ACALL	WRHEX		; Output
 1029:	  043F	ED			MOV	A,R5			; Get FF back
 1030:	  0440	80 06			SJMP	WRHEX		; Output
 1031:				;
 1032:				; Write the value of DPTR in hex
 1033:				;
 1034:	  0442			WRDPTR:
 1035:	  0442	E5 83			MOV	A,DP0H			; Get high
 1036:	  0444	91 48			ACALL	WRHEX		; Output if
 1037:	  0446	E5 82			MOV	A,DP0L			; Get low
 1038:				;
 1039:				; Write byte in A to the serial port in HEX
 1040:				;
 1041:	  0448			WRHEX:
 1042:	  0448	C0 E0			PUSH	ACC			; Save value
 1043:	  044A	C4			SWAP	A			; Get high nibble
 1044:	  044B	91 4F			ACALL	WRHEX1		; Output it
 1045:	  044D	D0 E0			POP	ACC				; Get low nibble
 1046:	  044F			WRHEX1:
 1047:	  044F	54 0F			ANL	A,#00001111b	; Use low digit only
 1048:	  0451	24 30			ADD	A,#'0'			; Convert to ASCII
 1049:	  0453	B4 3A 00		CJNE	A,#'0'+10,$+3	; Non-Destructive compare
 1050:	  0456	40 36			JC	WRCHR			; A = 0-9
 1051:	  0458	24 07			ADD	A,#7			; Convert HEX digits

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1052:	  045A	80 32			SJMP	WRCHR		; And write the character
 1053:				;
 1054:				; Write the string (DPTR) to the serial port
 1055:				;
 1056:	  045C			WRSTR:
 1057:	  045C	E4			CLR	A				; Zero offset
 1058:	  045D	93			MOVC	A,@A+DPTR	; Get character (From ROM)
 1059:	  045E	A3			INC	DPTR			; Advance to next
 1060:	  045F	60 34			JZ	RET1			; End of string
 1061:	  0461	91 8E			ACALL	WRCHR		; Write it out
 1062:	  0463	80 F7			SJMP	WRSTR		; And go again
 1063:				;
 1064:				; Write a newline (LFCR) to the serial port
 1065:				;
 1066:	  0465			WRLFCR:
 1067:	  0465	91 F1			ACALL	CHKCHR		; Any characters received?
 1068:	  0467	B4 1B 02		CJNE	A,#1Bh,WRLFCR1	; Escape?
 1069:	  046A	01 3C			AJMP	PROMPT		; Yes, abort command
 1070:	  046C			WRLFCR1:
 1071:	  046C	B4 20 0A		CJNE	A,#' ',WRLFCR2	; Halt output
 1072:	  046F	E5 7F			MOV	A,OUTFLAG		; Get output flag
 1073:	  0471	20 E7 10		JB	ACC.7,WRLFCR4		; Already set
 1074:	  0474	43 7F 80		ORL	OUTFLAG,#80h	; Set flag
 1075:	  0477	80 EC			SJMP	WRLFCR		; And proceed
 1076:	  0479			WRLFCR2:
 1077:	  0479	B4 0D 03		CJNE	A,#0Dh,WRLFCR3	; No, wait for it
 1078:	  047C	53 7F 7F		ANL	OUTFLAG,#7Fh	; Clear flag
 1079:	  047F			WRLFCR3:
 1080:	  047F	E5 7F			MOV	A,OUTFLAG		; Get output flag
 1081:	  0481	20 E7 E1		JB	ACC.7,WRLFCR		; Inhibited
 1082:	  0484			WRLFCR4:
 1083:	  0484	74 0A			MOV	A,#'J'-40h		; Get LINE-FEED
 1084:	  0486	91 8E			ACALL	WRCHR		; Output it
 1085:	  0488	74 0D			MOV	A,#'M'-40h		; Get CARRIAGE RETURN
 1086:	  048A	80 02			SJMP	WRCHR		; And output it
 1087:				;
 1088:				; Write a space to the serial port
 1089:				;
 1090:	  048C			WRSPC:
 1091:	  048C	74 20			MOV	A,#' '			; Get a space
 1092:				;
 1093:				; Write a character to the serial port
 1094:				;
 1095:	  048E			WRCHR:
 1096:	  048E	30 99 FD		JNB	SCON.1,$		; Wait for the bit
 1097:	  0491	C2 99			CLR	SCON.1			; Indicte we are sending
 1098:	  0493	F5 99			MOV	SBUF,A			; Write out char
 1099:	  0495			RET1:
 1100:	  0495	22			RET
 1101:				;
 1102:				; Read a word into B:A from the serial port
 1103:				;
 1104:	  0496			RDWORD:
 1105:	  0496	91 9C			ACALL	RDHEX		; Get a byte
 1106:	  0498	40 FB			JC	RET1			; Error, exit
 1107:	  049A	F5 F0			MOV	B,A				; Save high byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1108:				;
 1109:				; Read a byte from the serial port
 1110:				;
 1111:	  049C			RDHEX:
 1112:	  049C	91 A8			ACALL	RDNIB		; Read a nibble
 1113:	  049E	40 F5			JC	RET1			; Error, exit
 1114:	  04A0	C4			SWAP	A			; Get in high nibble
 1115:	  04A1	FF			MOV	R7,A			; Save for later
 1116:	  04A2	91 A8			ACALL	RDNIB		; Read next nibble
 1117:	  04A4	40 EF			JC	RET1			; Error, exit
 1118:	  04A6	4F			ORL	A,R7			; Include high nibble
 1119:	  04A7	22			RET
 1120:				;
 1121:				; Read a nibble in HEX from the serial port
 1122:				;
 1123:	  04A8			RDNIB:
 1124:	  04A8	91 D8			ACALL	RDCHR		; Get character
 1125:				; Handle numeric digits '0'-'9'
 1126:	  04AA	7B 30			MOV	R3,#'0'			; Lower bound
 1127:	  04AC	7C 3A			MOV	R4,#'9'+1		; Higher bound
 1128:	  04AE	B1 95			ACALL	COMP		; Do the compare
 1129:	  04B0	40 05			JC	RDNIB1			; Failed
 1130:	  04B2	91 8E			ACALL	WRCHR		; Echo it
 1131:	  04B4	94 30			SUBB	A,#'0'		; Convert
 1132:	  04B6	22			RET
 1133:				; Handle HEX digits 'A'-'F'
 1134:	  04B7			RDNIB1:
 1135:	  04B7	7B 41			MOV	R3,#'A'			; Lower bound
 1136:	  04B9	7C 47			MOV	R4,#'F'+1		; Higher bound
 1137:	  04BB	B1 95			ACALL	COMP		; Do the compare
 1138:	  04BD	40 05			JC	RDNIB2			; Report error
 1139:	  04BF	91 8E			ACALL	WRCHR		; Echo the character
 1140:	  04C1	94 37			SUBB	A,#'0'+7	; Convert
 1141:	  04C3	22			RET
 1142:				; Not valid, return with ERROR only if SPACE or CR
 1143:	  04C4			RDNIB2:
 1144:	  04C4	B4 20 03		CJNE	A,#' ',RDNIB3	; Not space, continue
 1145:	  04C7	E4			CLR	A				; Zero = space
 1146:	  04C8	D3			SETB	C			; Indicate special condtion
 1147:	  04C9	22			RET
 1148:	  04CA			RDNIB3:
 1149:	  04CA	B4 08 04		CJNE	A,#08h,RDNIB4	; Not BS, continue
 1150:	  04CD	74 01			MOV	A,#1			; One = Backspace
 1151:	  04CF	D3			SETB	C			; Indicate special condition
 1152:	  04D0	22			RET
 1153:	  04D1			RDNIB4:
 1154:	  04D1	B4 0D D4		CJNE	A,#0Dh,RDNIB	; Not CR, continue
 1155:	  04D4	74 02			MOV	A,#2			; Two = Carriage return
 1156:	  04D6			RDNIB5:
 1157:	  04D6	D3			SETB	C			; Indicate special condition
 1158:	  04D7	22			RET
 1159:				;
 1160:				; Read a character from the serial port
 1161:				;
 1162:	  04D8			RDCHR:
 1163:	  04D8	30 98 FD		JNB	SCON.0,$		; Wait for the bit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1164:	  04DB	C2 98			CLR	SCON.0			; Indicate we receved it
 1165:	  04DD	E5 99			MOV	A,SBUF			; Read the data
 1166:				; Convert the data to upper case
 1167:	  04DF	C0 E0			PUSH	ACC			; Save original
 1168:	  04E1	24 9F			ADD	A,#-'a'			; First test
 1169:	  04E3	50 09			JNC	RDCHR1			; < 'a', leave alone
 1170:	  04E5	94 19			SUBB	A,#25		; Second test
 1171:	  04E7	50 05			JNC	RDCHR1			; > 'z', leave alone
 1172:	  04E9	D0 E0			POP	ACC				; Restore char
 1173:	  04EB	94 1F			SUBB	A,#1Fh		; Convert to UPPER
 1174:	  04ED	22			RET
 1175:	  04EE			RDCHR1:
 1176:	  04EE	D0 E0			POP	ACC				; Restore
 1177:	  04F0	22			RET
 1178:				;
 1179:				; Check for a character received
 1180:				;
 1181:	  04F1			CHKCHR:
 1182:	  04F1	E4			CLR	A				; Assume zero
 1183:	  04F2	30 98 04		JNB	SCON.0,CHKC1	; No data, return
 1184:	  04F5	C2 98			CLR	SCON.0			; Indicate we received it
 1185:	  04F7	E5 99			MOV	A,SBUF			; Read the data
 1186:	  04F9			CHKC1:
 1187:	  04F9	22			RET
 1188:				;
 1189:				; Flush the serial port (Wait till all chars received/sent)
 1190:				;
 1191:	  04FA			FLUSH:
 1192:	  04FA	7F 00			MOV	R7,#0			; Delay count
 1193:	  04FC			FLUSH1:
 1194:	  04FC	91 F1			ACALL	CHKCHR		; Any data?
 1195:	  04FE	70 FA			JNZ	FLUSH			; Reset the timer
 1196:	  0500	30 99 F7		JNB	SCON.1,FLUSH	; Wait for TX complete
 1197:	  0503	DF F7			DJNZ	R7,FLUSH1	; Wait for expiry
 1198:	  0505	22			RET
 1199:				;
 1200:				; Read a byte without echo
 1201:				;
 1202:	  0506			DLBYTE:
 1203:	  0506	B1 0E			ACALL	DLNIB		; Get first digit
 1204:	  0508	C4			SWAP	A			; Get in high digit
 1205:	  0509	FD			MOV	R5,A			; Save for later
 1206:	  050A	B1 0E			ACALL	DLNIB		; Get low digit
 1207:	  050C	4D			ORL	A,R5			; Include high
 1208:	  050D	22			RET
 1209:				;
 1210:				; Read a nibble without echo
 1211:				;
 1212:	  050E			DLNIB:
 1213:	  050E	91 D8			ACALL	RDCHR		; Read a character
 1214:	  0510	7B 30			MOV	R3,#'0'			; Lower bound
 1215:	  0512	7C 3A			MOV	R4,#'9'+1		; Upper bound
 1216:	  0514	B1 95			ACALL	COMP		; Perform the compare
 1217:	  0516	50 0A			JNC	DLNIB1			; Invalid
 1218:	  0518	7B 41			MOV	R3,#'A'			; Lower bound
 1219:	  051A	7C 47			MOV	R4,#'F'+1		; Upper bound

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1220:	  051C	B1 95			ACALL	COMP		; Perform the compare
 1221:	  051E	40 18			JC	DLERR			; Report error
 1222:	  0520	94 07			SUBB	A,#7		; Convert HEX
 1223:	  0522			DLNIB1:
 1224:	  0522	94 30			SUBB	A,#'0'		; Convert NUMBERS
 1225:	  0524	22			RET
 1226:				;
 1227:				; Read a MHX record from the serial port
 1228:				;
 1229:	  0525			DLOAD:
 1230:	  0525	91 D8			ACALL	RDCHR		; Read a character
 1231:	  0527	B4 53 3D		CJNE	A,#'S',DLINT	; Try intel record
 1232:				; Download a MOTOROLA HEX format record
 1233:	  052A			DLMOT:
 1234:	  052A	91 D8			ACALL	RDCHR		; Read another char
 1235:	  052C	C3			CLR	C				; No borrow in
 1236:	  052D	94 30			SUBB	A,#'0'		; Header record
 1237:	  052F	60 F4			JZ	DLOAD			; Yes, ignore it
 1238:	  0531	14			DEC	A				; Type 1 (data record)
 1239:	  0532	60 0B			JZ	DLMOT1			; Yes, grab it
 1240:	  0534	94 08			SUBB	A,#8		; Type 9 (EOF)
 1241:	  0536			DLEOF:
 1242:	  0536	60 9E			JZ	RDNIB5			; Yes end of file (Set C)
 1243:				; Error in download
 1244:	  0538			DLERR:
 1245:	  0538	90 08 5B		MOV	DPTR,#M_LOAD	; Point to '?Load error' message
 1246:	  053B	91 5C			ACALL	WRSTR		; Output
 1247:	  053D	01 3A			AJMP	FPROMPT		; And continue
 1248:	  053F			DLMOT1:
 1249:	  053F	B1 06			ACALL	DLBYTE		; Get length
 1250:	  0541	FE			MOV	R6,A			; Start checksum
 1251:	  0542	24 FD			ADD	A,#-3			; Convert to actual length
 1252:	  0544	FF			MOV	R7,A			; Save length
 1253:	  0545	29			ADD	A,R1			; Add to LOW length
 1254:	  0546	F9			MOV	R1,A			; Save
 1255:	  0547	EA			MOV	A,R2			; Get HIGH length
 1256:	  0548	34 00			ADDC	A,#0		; Adjust for carry
 1257:	  054A	FA			MOV	R2,A			; Resave
 1258:	  054B	B1 06			ACALL	DLBYTE		; Get byte of address
 1259:	  054D	F5 83			MOV	DP0H,A			; Save high
 1260:	  054F	2E			ADD	A,R6			; Include in checksum
 1261:	  0550	FE			MOV	R6,A			; Resave checksum
 1262:	  0551	B1 06			ACALL	DLBYTE		; Get low byte of address
 1263:	  0553	F5 82			MOV	DP0L,A			; Save low
 1264:	  0555	2E			ADD	A,R6			; Include in checksum
 1265:	  0556	FE			MOV	R6,A			; And re-save
 1266:	  0557			DLMOT2:
 1267:	  0557	B1 06			ACALL	DLBYTE		; Get a byte
 1268:				; ??? Write to code memory
 1269:	  0559	F0			MOVX	@DPTR,A	; Write to memory
 1270:	  055A	A3			INC	DPTR			; Advance to next
 1271:	  055B	2E			ADD	A,R6			; Include in checksum
 1272:	  055C	FE			MOV	R6,A			; And re-save
 1273:	  055D	DF F8			DJNZ	R7,DLMOT2	; Do whole record
 1274:	  055F	B1 06			ACALL	DLBYTE		; Get checksum
 1275:	  0561	2E			ADD	A,R6			; Include calculated value

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1276:	  0562	04			INC	A				; Convert
 1277:	  0563	70 D3			JNZ	DLERR			; Failed!
 1278:	  0565	C3			CLR	C				; Indicte RX OK
 1279:	  0566	22			RET
 1280:				; Download an INTEL format record
 1281:	  0567			DLINT:
 1282:	  0567	B4 3A BB		CJNE	A,#':',DLOAD	; Not INTEL, ignore
 1283:	  056A	B1 06			ACALL	DLBYTE		; Get count
 1284:	  056C	FE			MOV	R6,A			; Start checksum
 1285:	  056D	FF			MOV	R7,A			; Record length
 1286:	  056E	60 C6			JZ	DLEOF			; End of file
 1287:	  0570	29			ADD	A,R1			; Add LOW length
 1288:	  0571	F9			MOV	R1,A			; Resave
 1289:	  0572	EA			MOV	A,R2			; Get HIGH length
 1290:	  0573	34 00			ADDC	A,#0		; Adjust for high
 1291:	  0575	FA			MOV	R2,A			; Resave
 1292:	  0576	B1 06			ACALL	DLBYTE		; Get HIGH address
 1293:	  0578	F5 83			MOV	DP0H,A			; Set up DPTR
 1294:	  057A	2E			ADD	A,R6			; Include in checksum
 1295:	  057B	FE			MOV	R6,A			; Resave
 1296:	  057C	B1 06			ACALL	DLBYTE		; Get LOW address
 1297:	  057E	F5 82			MOV	DP0L,A			; Set up DPTR
 1298:	  0580	2E			ADD	A,R6			; Include checksum
 1299:	  0581	FE			MOV	R6,A			; Resave
 1300:	  0582	B1 06			ACALL	DLBYTE		; Read RECORD type
 1301:	  0584	2E			ADD	A,R6			; Incldue in checksum
 1302:	  0585	FE			MOV	R6,A			; Resave
 1303:	  0586			DLINT1:
 1304:	  0586	B1 06			ACALL	DLBYTE		; Read a data byte
 1305:				; ??? Write to code memory
 1306:	  0588	F0			MOVX	@DPTR,A	; Write to memory
 1307:	  0589	A3			INC	DPTR			; Advance to next
 1308:	  058A	2E			ADD	A,R6			; Include in checksum
 1309:	  058B	FE			MOV	R6,A			; Resave
 1310:	  058C	DF F8			DJNZ	R7,DLINT1	; Do them all
 1311:	  058E	B1 06			ACALL	DLBYTE		; Get record checksum
 1312:	  0590	2E			ADD	A,R6			; Include in checksum
 1313:	  0591	70 A5			JNZ	DLERR			; Report error
 1314:	  0593	C3			CLR	C				; Indicate success
 1315:	  0594	22			RET
 1316:				;
 1317:				; Compare the ACCUMULATOR with R3&R4
 1318:				; Sets the C flag if ACC <R3 or >=R4
 1319:				;
 1320:	  0595			COMP:
 1321:	  0595	C0 E0			PUSH	ACC			; Save ACC
 1322:	  0597	C3			CLR	C				; Clear carry
 1323:	  0598	9B			SUBB	A,R3		; Test
 1324:	  0599	40 06			JC	COMP1			; < R3, report no
 1325:	  059B	D0 E0			POP	ACC				; Restore A
 1326:	  059D	C0 E0			PUSH	ACC			; And re-stack
 1327:	  059F	9C			SUBB	A,R4		; Test
 1328:	  05A0	B3			CPL	C				; C = A >= R4
 1329:	  05A1			COMP1:
 1330:	  05A1	D0 E0			POP	ACC				; Restore A
 1331:	  05A3			RET2:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1332:	  05A3	22			RET
 1333:				;
 1334:				; Disassemble to screen
 1335:				;
 1336:	  05A4			DODISS:
 1337:	  05A4	7C F7			MOV	R4,#HIGH(MBUFFER)	; Get HIGH output address
 1338:	  05A6	7B BC			MOV	R3,#LOW(MBUFFER)		; Get LOW output address
 1339:	  05A8	C0 02			PUSH	2			; Save HIGH output
 1340:	  05AA	C0 01			PUSH	1			; Save LOW output
 1341:	  05AC	B1 D9			ACALL	DISASS		; Do dis-assembly
 1342:	  05AE	D0 82			POP	DP0L				; Get LOW
 1343:	  05B0	D0 83			POP	DP0H				; Get HIGH
 1344:	  05B2	91 42			ACALL	WRDPTR		; Output address
 1345:	  05B4	7F 05			MOV	R7,#5			; Max # spaces
 1346:	  05B6			DODISS1:
 1347:	  05B6	91 8C			ACALL	WRSPC		; Space over
 1348:	  05B8	E4			CLR	A				; Zero OFFSET
 1349:	  05B9	93			MOVC	A,@A+DPTR	; Get value
 1350:	  05BA	A3			INC	DPTR			; Advance
 1351:	  05BB	91 48			ACALL	WRHEX		; Output
 1352:	  05BD	1F			DEC	R7				; Reduce count
 1353:	  05BE	E9			MOV	A,R1			; Get LOW
 1354:	  05BF	B5 82 F4		CJNE	A,DP0L,DODISS1	; More...
 1355:	  05C2	EA			MOV	A,R2			; Get HIGH
 1356:	  05C3	B5 83 F0		CJNE	A,DP0H,DODISS1	; More...
 1357:	  05C6			DODISS2:
 1358:	  05C6	91 8C			ACALL	WRSPC		; Space
 1359:	  05C8	91 8C			ACALL	WRSPC		; Space
 1360:	  05CA	91 8C			ACALL	WRSPC		; Space
 1361:	  05CC	DF F8			DJNZ	R7,DODISS2	; Do them ALL
 1362:	  05CE	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
 1363:	  05D1			DODISS3:
 1364:	  05D1	E0			MOVX	A,@DPTR	; Get character
 1365:	  05D2	A3			INC	DPTR			; Advance
 1366:	  05D3	60 CE			JZ	RET2			; Exit
 1367:	  05D5	91 8E			ACALL	WRCHR		; Output char
 1368:	  05D7	80 F8			SJMP	DODISS3		; Continue
 1369:				;
 1370:				; Disassemble opcode
 1371:				; R2:1 = Input pointer, R4:3 = Output pointer R5:7 = Temp locs
 1372:	  05D9			DISASS:
 1373:	  05D9	C0 83			PUSH	DP0H			; Save DP0H
 1374:	  05DB	C0 82			PUSH	DP0L			; Save DP0L
 1375:	  05DD	C0 05			PUSH	5			; Save R5
 1376:	  05DF	C0 07			PUSH	7			; Save R7
 1377:	  05E1	F1 10			ACALL	LAR21Z		; Read opcode
 1378:	  05E3	90 09 A5		MOV	DPTR,#OTABLE	; Point to lookup table
 1379:	  05E6	FD			MOV	R5,A			; Save for later
 1380:				; Look for instruction in table
 1381:	  05E7			dis1:
 1382:	  05E7	E4			CLR	A				; Zero offset
 1383:	  05E8	93			MOVC	A,@A+DPTR	; Get value from table
 1384:	  05E9	5D			ANL	A,R5			; Mask for variables
 1385:	  05EA	F5 F0			MOV	B,A				; Save for compare
 1386:	  05EC	A3			INC	DPTR			; Advance to test
 1387:	  05ED	E4			CLR	A				; Zero offset

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1388:	  05EE	93			MOVC	A,@A+DPTR	; Get byte from table
 1389:	  05EF	A3			INC	DPTR			; Advance
 1390:	  05F0	B5 F0 0E		CJNE	A,B,dis2	; Not correct instruction
 1391:				; This is the instruction
 1392:	  05F3			dis3:
 1393:	  05F3	7F 06			MOV	R7,#6			; Counter
 1394:	  05F5			dis4:
 1395:	  05F5	E4			CLR	A				; Zero offset
 1396:	  05F6	93			MOVC	A,@A+DPTR	; Get byte to output
 1397:	  05F7	A3			INC	DPTR			; Advance to next
 1398:	  05F8	B4 20 0D		CJNE	A,#' ',dis5	; Not space, its OK
 1399:	  05FB			dis41:
 1400:	  05FB	F1 03			ACALL	WR43		; Output to string
 1401:	  05FD	DF FC			DJNZ	R7,dis41	; Do them all
 1402:	  05FF	80 F4			SJMP	dis4		; next byte
 1403:				; Not it, try next
 1404:	  0601			dis2:
 1405:	  0601	E4			CLR	A				; Zero offset
 1406:	  0602	93			MOVC	A,@A+DPTR	; Get byte
 1407:	  0603	A3			INC	DPTR			; Advance
 1408:	  0604	70 FB			JNZ	dis2			; No, keep looking
 1409:	  0606	80 DF			SJMP	dis1		; Go again
 1410:				; Test for 'r'egister ID
 1411:	  0608			dis5:
 1412:	  0608	B4 72 0D		CJNE	A,#'r',dis6	; Register?
 1413:	  060B	74 52			MOV	A,#'R'			; Stuff in 'R'
 1414:	  060D	F1 03			ACALL	WR43		; Output it
 1415:	  060F	ED			MOV	A,R5			; Get opcode back
 1416:	  0610			dis51:
 1417:	  0610	54 07			ANL	A,#07h			; Save 'R' bits
 1418:	  0612	24 30			ADD	A,#'0'			; Convert to ASCII
 1419:	  0614	F1 03			ACALL	WR43		; Write it
 1420:	  0616	80 DD			SJMP	dis4		; And proceed
 1421:				; Test for 'i'ndirect id
 1422:	  0618			dis6:
 1423:	  0618	B4 69 15		CJNE	A,#'i',dis7	; Indirect?
 1424:	  061B	74 5B			MOV	A,#'['			; Opening brace
 1425:	  061D	F1 03			ACALL	WR43		; Output
 1426:	  061F	74 52			MOV	A,#'R'			; Register indicator
 1427:	  0621	F1 03			ACALL	WR43		; Output
 1428:	  0623	ED			MOV	A,R5			; Get opcode
 1429:	  0624	54 01			ANL	A,#01h			; Save ID
 1430:	  0626	24 30			ADD	A,#'0'			; Convert to ASCII
 1431:	  0628	F1 03			ACALL	WR43		; Output
 1432:	  062A	74 5D			MOV	A,#']'			; Closing brace
 1433:	  062C	F1 03			ACALL	WR43		; Output
 1434:	  062E	80 C5			SJMP	dis4		; Save
 1435:				; Test for 'm'emory reference
 1436:	  0630			dis7:
 1437:	  0630	B4 6D 0A		CJNE	A,#'m',dis8	; Memory reference?
 1438:	  0633	74 23			MOV	A,#'#'			; Indicate immediiate
 1439:	  0635	F1 03			ACALL	WR43		; Output
 1440:	  0637	F1 10			ACALL	LAR21Z		; Get value
 1441:	  0639	D1 EE			ACALL	WRHEXS		; Output in hex
 1442:	  063B	80 B8			SJMP	dis4		; And proceed
 1443:				; Test for 'x'tended address

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1444:	  063D			dis8:
 1445:	  063D	B4 78 0A		CJNE	A,#'x',dis9	; Xtended?
 1446:	  0640	F1 10			ACALL	LAR21Z		; Get value
 1447:	  0642	D1 EE			ACALL	WRHEXS		; Output in hex
 1448:	  0644	F1 10			ACALL	LAR21Z		; Get value
 1449:	  0646	D1 EE			ACALL	WRHEXS		; Output
 1450:	  0648	80 AB			SJMP	dis4		; And proceed
 1451:				; Test for 'j' relative jump address
 1452:	  064A			dis9:
 1453:	  064A	B4 6A 10		CJNE	A,#'j',dis10	; Jump address?
 1454:	  064D	F1 10			ACALL	LAR21Z		; Get value
 1455:	  064F	F1 2E			ACALL	CBW			; Sign extend
 1456:	  0651	29			ADD	A,R1			; Add LOW
 1457:	  0652	C5 F0			XCH	A,B				; B = low
 1458:	  0654	3A			ADDC	A,R2		; Add HIGH
 1459:	  0655			dis91:
 1460:	  0655	D1 EE			ACALL	WRHEXS		; Output HIGH
 1461:	  0657	E5 F0			MOV	A,B				; Get LOW
 1462:	  0659	D1 EE			ACALL	WRHEXS		; output
 1463:	  065B	80 98			SJMP	dis4		; And proceed
 1464:				; Test for 'a' absolute address
 1465:	  065D			dis10:
 1466:	  065D	B4 61 17		CJNE	A,#'a',dis11	; ABS address?
 1467:	  0660	F1 10			ACALL	LAR21Z		; Get value
 1468:	  0662	C0 E0			PUSH	ACC			; Save LOW
 1469:	  0664	EA			MOV	A,R2			; Get high address
 1470:	  0665	54 F8			ANL	A,#0F8h			; Save high bits
 1471:	  0667	F5 F0			MOV	B,A				; Save for later
 1472:	  0669	ED			MOV	A,R5			; Get opcode
 1473:	  066A	03			RR	A				; Shift
 1474:	  066B	03			RR	A				; To
 1475:	  066C	03			RR	A				; Get
 1476:	  066D	03			RR	A				; Insert
 1477:	  066E	03			RR	A				; Bits
 1478:	  066F	54 07			ANL	A,#00000111b	; Save only lower three
 1479:	  0671	45 F0			ORL	A,B				; Include extra bits
 1480:	  0673	D0 F0			POP	B				; Restore LOW
 1481:	  0675	80 DE			SJMP	dis91		; Display
 1482:				; Test for 'd' direct memory address
 1483:	  0677			dis11:
 1484:	  0677	B4 64 06		CJNE	A,#'d',dis12	; Direct memory address?
 1485:	  067A	F1 10			ACALL	LAR21Z		; Get address
 1486:	  067C			dis111:
 1487:	  067C	D1 C3			ACALL	DIRECT		; display direct address
 1488:	  067E			dis112:
 1489:	  067E	A1 F5			AJMP	dis4		; And proceed
 1490:				; Test for 'b' bit address
 1491:	  0680			dis12:
 1492:	  0680	B4 62 1A		CJNE	A,#'b',dis13	; No, try next
 1493:	  0683	F1 10			ACALL	LAR21Z		; Get value
 1494:	  0685	C0 E0			PUSH	ACC			; Save for later
 1495:	  0687	54 F8			ANL	A,#0F8h			; Remove bit position
 1496:	  0689	20 E7 07		JB	ACC.7,dis121		; Negative, its ok
 1497:	  068C	03			RR	A				; Over
 1498:	  068D	03			RR	A				; To low bit
 1499:	  068E	03			RR	A				; address range

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1500:	  068F	54 1F			ANL	A,#00011111b	; Mask bits
 1501:	  0691	24 20			ADD	A,#20h			; Convert
 1502:	  0693			dis121:
 1503:	  0693	D1 C3			ACALL	DIRECT		; Write address
 1504:	  0695	74 2E			MOV	A,#'.'			; Separator
 1505:	  0697	F1 03			ACALL	WR43		; write it
 1506:	  0699	D0 E0			POP	ACC				; Restore
 1507:	  069B	C1 10			AJMP	dis51		; Write & return
 1508:				; Test for 'e' - special direct
 1509:	  069D			dis13:
 1510:	  069D	B4 65 09		CJNE	A,#'e',dis14	; Special direct?
 1511:	  06A0	75 F0 00		MOV	B,#0			; High = 0
 1512:	  06A3	74 01			MOV	A,#1			; Offset = 1
 1513:	  06A5	F1 13			ACALL	LAR21		; Get value
 1514:	  06A7	80 D3			SJMP	dis111		; And proceed
 1515:				; Test for 'f' - special direct
 1516:	  06A9			dis14:
 1517:	  06A9	B4 66 09		CJNE	A,#'f',dis15	; Special direct?
 1518:	  06AC	74 FF			MOV	A,#-1			; Offset -1
 1519:	  06AE	75 F0 FF		MOV	B,#-1			; Offset -1
 1520:	  06B1	F1 13			ACALL	LAR21		; Get data
 1521:	  06B3	80 C7			SJMP	dis111		; and prcoeed
 1522:				; Normal data, output to buffer
 1523:	  06B5			dis15:
 1524:	  06B5	F1 03			ACALL	WR43		; Output
 1525:	  06B7	1F			DEC	R7				; Reduce count
 1526:	  06B8	70 C4			JNZ	dis112			; Go till end
 1527:	  06BA	D0 07			POP	7				; Restore R7
 1528:	  06BC	D0 05			POP	5				; Restore R5
 1529:	  06BE	D0 82			POP	DP0L				; Restore DP0L
 1530:	  06C0	D0 83			POP	DP0H				; Restore DP0H
 1531:	  06C2	22			RET
 1532:				;
 1533:				; Look up opcode in the direct memory access table
 1534:				; Write to R4:3+
 1535:				;
 1536:	  06C3			DIRECT:
 1537:	  06C3	F5 F0			MOV	B,A				; Save a copy
 1538:	  06C5	C0 83			PUSH	DP0H			; Save LOW
 1539:	  06C7	C0 82			PUSH	DP0L			; Save HIGH
 1540:	  06C9	90 0D FB		MOV	DPTR,#DTABLE	; Point to table
 1541:	  06CC			dir1:
 1542:	  06CC	E4			CLR	A				; Zero offset
 1543:	  06CD	93			MOVC	A,@A+DPTR	; Get value
 1544:	  06CE	A3			INC	DPTR			; Advance
 1545:	  06CF	60 17			JZ	dir4			; End of list
 1546:	  06D1	30 E7 F8		JNB	ACC.7,dir1		; Still in entry
 1547:	  06D4	B5 F0 F5		CJNE	A,B,dir1	; This is not it
 1548:	  06D7			dir2:
 1549:	  06D7	E4			CLR	A				; Zero offset
 1550:	  06D8	93			MOVC	A,@A+DPTR	; Get data
 1551:	  06D9	A3			INC	DPTR			; Advance to next
 1552:	  06DA	60 07			JZ	dir3			; End of list
 1553:	  06DC	20 E7 04		JB	ACC.7,dir3		; End of list
 1554:	  06DF	F1 03			ACALL	WR43		; Write to buffer
 1555:	  06E1	80 F4			SJMP	dir2		; Do them all

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1556:	  06E3			dir3:
 1557:	  06E3	D0 82			POP	DP0L				; Restore LOW
 1558:	  06E5	D0 83			POP	DP0H				; Restore HIGH
 1559:	  06E7	22			RET
 1560:	  06E8			dir4:
 1561:	  06E8	D0 82			POP	DP0L				; Restore LOW
 1562:	  06EA	D0 83			POP	DP0H				; Restore HIGH
 1563:	  06EC	E5 F0			MOV	A,B				; Get value back
 1564:				;
 1565:				; Write byte in AL to [R4:3+] in hex
 1566:				;
 1567:	  06EE			WRHEXS:
 1568:	  06EE	C0 E0			PUSH	ACC			; Save for later
 1569:	  06F0	03			RR	A				; Shift high nibble
 1570:	  06F1	03			RR	A				; Into low nibble
 1571:	  06F2	03			RR	A				; For output
 1572:	  06F3	03			RR	A				; first
 1573:	  06F4	D1 F8			ACALL	WRHEXS1		; Output it
 1574:	  06F6	D0 E0			POP	ACC				; Restore LOW
 1575:	  06F8			WRHEXS1:
 1576:	  06F8	54 0F			ANL	A,#00001111b	; Save only high digit
 1577:	  06FA	24 30			ADD	A,#'0'			; Convert to ASCII
 1578:	  06FC	B4 3A 00		CJNE	A,#'0'+10,$+3	; In range?
 1579:	  06FF	40 02			JC	WR43			; Yes, its OK
 1580:	  0701	24 07			ADD	A,#7			; Convert alphas
 1581:				; Write byte to [R4:3+]
 1582:	  0703			WR43:
 1583:	  0703	F1 07			ACALL	SDP43		; Swap into DPTR
 1584:	  0705	F0			MOVX	@DPTR,A		; Write data
 1585:	  0706	A3			INC	DPTR			; Advance
 1586:	  0707			SDP43:
 1587:	  0707	CC			XCH	A,R4			; Get R4
 1588:	  0708	C5 83			XCH	A,DP0H			; Swap with DP0H
 1589:	  070A	CC			XCH	A,R4			; Replace R4
 1590:	  070B	CB			XCH	A,R3			; Get R3
 1591:	  070C	C5 82			XCH	A,DP0L			; Swap with DP0H
 1592:	  070E	CB			XCH	A,R3			; Replace R3
 1593:	  070F	22			RET
 1594:				; Load 0[R2:3+]
 1595:	  0710			LAR21Z:
 1596:	  0710	E4			CLR	A				; Zero LOW
 1597:	  0711	F5 F0			MOV	B,A				; Zero HIGH
 1598:				; Load BA[R2:3+]
 1599:	  0713			LAR21:
 1600:	  0713	C0 83			PUSH	DP0H			; Save DP0H
 1601:	  0715	C0 82			PUSH	DP0L			; Save DP0L
 1602:	  0717	29			ADD	A,R1			; Get low value
 1603:	  0718	F5 82			MOV	DP0L,A			; Resave
 1604:	  071A	EA			MOV	A,R2			; Get high
 1605:	  071B	35 F0			ADDC	A,B			; Adjust for overflow
 1606:	  071D	F5 83			MOV	DP0H,A			; Resave
 1607:	  071F	E4			CLR	A				; Zero offset
 1608:	  0720	93			MOVC	A,@A+DPTR	; Load value
 1609:	  0721	D0 82			POP	DP0L				; Restore DP0L
 1610:	  0723	D0 83			POP	DP0H				; Restore DP0H
 1611:	  0725			INC23:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1612:	  0725	C9			XCH	A,R1			; Get LOW
 1613:	  0726	24 01			ADD	A,#1			; Advance
 1614:	  0728	C9			XCH	A,R1			; Replace
 1615:	  0729	CA			XCH	A,R2			; Get HIGH
 1616:	  072A	34 00			ADDC	A,#0		; Cary high
 1617:	  072C	CA			XCH	A,R2			; Replace
 1618:	  072D	22			RET
 1619:				; Convert a byte to word
 1620:	  072E			CBW:
 1621:	  072E	75 F0 00		MOV	B,#0			; Assume zero
 1622:	  0731	30 E7 02		JNB	ACC.7,$+5			; Its OK
 1623:	  0734	15 F0			DEC	B				; Convert to -1
 1624:	  0736	22			RET
 1625:				;
 1626:				; Read user internal memory @R0
 1627:				;
 1628:	  0737			RDINTM:
 1629:	  0737	B8 20 00		CJNE	R0,#MSSIZE,$+3	; Non-destruction compare
 1630:	  073A	40 02			JC	RDINTM1			; Special case
 1631:	  073C	E6			MOV	A,@R0			; Read it
 1632:	  073D	22			RET
 1633:	  073E			RDINTM1:
 1634:	  073E	C0 83			PUSH	DP0H			; Save Data pointer
 1635:	  0740	C0 82			PUSH	DP0L
 1636:	  0742	75 83 F7		MOV	DP0H,#HIGH(MRSAVE)	; Point to high address
 1637:	  0745	74 88			MOV	A,#LOW(MRSAVE)+5		; Set up low address
 1638:	  0747	28			ADD	A,R0			; Offset to desired location
 1639:	  0748	F5 82			MOV	DP0L,A			; Set up low
 1640:	  074A	E0			MOVX	A,@DPTR	; Read value
 1641:	  074B	D0 82			POP	DP0L
 1642:	  074D	D0 83			POP	DP0H
 1643:	  074F	22			RET
 1644:				;
 1645:				; Write user internal memory @R0
 1646:				;
 1647:	  0750			WRINTM:
 1648:	  0750	B8 20 00		CJNE	R0,#MSSIZE,$+3	; Non-destruction compare
 1649:	  0753	40 02			JC	WRINTM1			; Special case
 1650:	  0755	F6			MOV	@R0,A			; Write it
 1651:	  0756	22			RET
 1652:	  0757			WRINTM1:
 1653:	  0757	C0 83			PUSH	DP0H			; Save data pointer
 1654:	  0759	C0 82			PUSH	DP0L
 1655:	  075B	C0 E0			PUSH	ACC			; Save value to write
 1656:	  075D	75 83 F7		MOV	DP0H,#HIGH(MRSAVE)	; Point to high address
 1657:	  0760	74 88			MOV	A,#LOW(MRSAVE)+5		; Set up low address
 1658:	  0762	28			ADD	A,R0			; Offset to desired location
 1659:	  0763	F5 82			MOV	DP0L,A			; Set up low
 1660:	  0765	D0 E0			POP	ACC				; Get value to write
 1661:	  0767	F0			MOVX	@DPTR,A	; Write value
 1662:	  0768	D0 82			POP	DP0L
 1663:	  076A	D0 83			POP	DP0H
 1664:	  076C	22			RET
 1665:				;
 1666:				; Breakpoint has been encountered
 1667:				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1668:	  076D			BREAKPT:
 1669:	  076D	F1 FF			ACALL	SAVEREG		; Save user registers
 1670:				; Replace any breakpointed code
 1671:	  076F	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint
 1672:	  0772	78 00			MOV	R0,#0			; Set to zero
 1673:	  0774			BREAK1:
 1674:	  0774	E0			MOVX	A,@DPTR	; Get HIGH address
 1675:	  0775	A3			INC	DPTR			; Advance
 1676:	  0776	FC			MOV	R4,A			; Save
 1677:	  0777	E0			MOVX	A,@DPTR	; Get LOW address
 1678:	  0778	A3			INC	DPTR			; Advance
 1679:	  0779	FB			MOV	R3,A			; Save
 1680:	  077A	4C			ORL	A,R4			; Is this one used?
 1681:	  077B	60 0A			JZ	BREAK3			; No, skip it
 1682:				; Breakpoint... Replace user code
 1683:	  077D	7F 03			MOV	R7,#3			; Move three bytes
 1684:	  077F			BREAK2:
 1685:	  077F	E0			MOVX	A,@DPTR	; Get code byte
 1686:	  0780	A3			INC	DPTR			; Advance
 1687:				; ??? Write to code memory
 1688:	  0781	F1 03			ACALL	WR43		; Write to code
 1689:	  0783	DF FA			DJNZ	R7,BREAK2	; Write it all
 1690:	  0785	80 03			SJMP	BREAK4		; And proceed
 1691:				; No breakpoint set... skip to next
 1692:	  0787			BREAK3:
 1693:	  0787	A3			INC	DPTR			; Skip code
 1694:	  0788	A3			INC	DPTR
 1695:	  0789	A3			INC	DPTR
 1696:	  078A			BREAK4:
 1697:	  078A	08			INC	R0				; Advance code
 1698:	  078B	B8 04 E6		CJNE	R0,#NBREAK,BREAK1 ; Do them all
 1699:				; Continue with breakpoint processing
 1700:	  078E	90 08 67		MOV	DPTR,#M_BREAK	; Point to 'Break at ' message
 1701:	  0791	91 5C			ACALL	WRSTR		; Output
 1702:				; Adjust PC by -3 to compensate for breakpoint return address
 1703:	  0793	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1704:	  0796	E0			MOVX	A,@DPTR	; Get HIGH value
 1705:	  0797	A3			INC	DPTR			; Advance
 1706:	  0798	F5 F0			MOV	B,A				; B = HIGH
 1707:	  079A	E0			MOVX	A,@DPTR	; Get LOW value
 1708:	  079B	C3			CLR	C				; Zero carry
 1709:	  079C	94 03			SUBB	A,#3		; Backup by 3
 1710:	  079E	C5 F0			XCH	A,B				; Get HIGH
 1711:	  07A0	94 00			SUBB	A,#0		; Include carry
 1712:	  07A2	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1713:	  07A5	F0			MOVX	@DPTR,A	; Write new HIGH
 1714:	  07A6	91 48			ACALL	WRHEX		; Output
 1715:	  07A8	A3			INC	DPTR			; Advance
 1716:	  07A9	E5 F0			MOV	A,B				; Get LOW
 1717:	  07AB	C5 F0			XCH	A,B				; Get LOW
 1718:	  07AD	F0			MOVX	@DPTR,A	; Write new LOW
 1719:	  07AE	91 48			ACALL	WRHEX		; Output
 1720:	  07B0	01 3C			AJMP	PROMPT
 1721:				;
 1722:				; Test for see if breakpoint conflict at address R2:1
 1723:				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1724:	  07B2			TESTBRK:
 1725:	  07B2	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint table
 1726:	  07B5	78 00			MOV	R0,#0			; Init count
 1727:	  07B7			TSTBR1:
 1728:	  07B7	E0			MOVX	A,@DPTR	; Get HIGH value
 1729:	  07B8	A3			INC	DPTR			; Advance
 1730:	  07B9	FC			MOV	R4,A			; Save HIGH
 1731:	  07BA	E0			MOVX	A,@DPTR	; Get LOW value
 1732:	  07BB	A3			INC	DPTR			; ; Advance
 1733:	  07BC	FB			MOV	R3,A			; Continue
 1734:	  07BD	A3			INC	DPTR			; Skip
 1735:	  07BE	A3			INC	DPTR			; Code
 1736:	  07BF	A3			INC	DPTR			; Bytes
 1737:	  07C0	4C			ORL	A,R4			; Breakpoint set?
 1738:	  07C1	60 17			JZ	TSTBR3			; No, skip it
 1739:	  07C3	7F 03			MOV	R7,#3			; Test three times
 1740:	  07C5			TSTBR2:
 1741:	  07C5	C3			CLR	C				; Zero carry
 1742:	  07C6	E9			MOV	A,R1			; Get LOW
 1743:	  07C7	9B			SUBB	A,R3		; Do LOW
 1744:	  07C8	F5 F0			MOV	B,A				; Save for later
 1745:	  07CA	EA			MOV	A,R2			; Get HIGH
 1746:	  07CB	9C			SUBB	A,R4		; Do HIGH
 1747:	  07CC	45 F0			ORL	A,B				; Same?
 1748:	  07CE	60 0F			JZ	TSTBR4			; We found a collision
 1749:	  07D0	EB			MOV	A,R3			; Get LOW BP address
 1750:	  07D1	24 01			ADD	A,#1			; Advance
 1751:	  07D3	FB			MOV	R3,A			; Resave
 1752:	  07D4	EC			MOV	A,R4			; Get HIGH BP address
 1753:	  07D5	34 00			ADDC	A,#0		; Include carry
 1754:	  07D7	FC			MOV	R4,A			; Resave
 1755:	  07D8	DF EB			DJNZ	R7,TSTBR2	; Keep going
 1756:	  07DA			TSTBR3:
 1757:	  07DA	08			INC	R0				; Advance count
 1758:	  07DB	B8 04 D9		CJNE	R0,#NBREAK,TSTBR1 ; Do them all
 1759:	  07DE	22			RET
 1760:	  07DF			TSTBR4:
 1761:	  07DF	90 08 71		MOV	DPTR,#M_CONFL	; Point to 'Breakpoint Conflict!' message
 1762:	  07E2	91 5C			ACALL	WRSTR		; Output
 1763:	  07E4	01 3C			AJMP	PROMPT		; Abort command
 1764:				;
 1765:				; Single step interrupt has been encounted
 1766:				;
 1767:	  07E6			SSINT:
 1768:	  07E6	C2 AB			CLR	IE.3			; Disable timer-1 interrupt
 1769:	  07E8	F1 FF			ACALL	SAVEREG		; Save user registers
 1770:				; Reset timer1 for baud rate generation
 1771:	  07EA	E5 89			MOV	A,TMOD			; Get timer mode
 1772:	  07EC	54 0F			ANL	A,#00001111b	; Zero timer1 mode
 1773:	  07EE	44 20			ORL	A,#00100000b	; T1 = 8 bit auto-reload
 1774:	  07F0	F5 89			MOV	TMOD,A			; Resave new timer mode
 1775:	  07F2	75 8D FF		MOV	TH1,#-BAUD		; Timer1 reload value
 1776:	  07F5	75 8B FF		MOV	TL1,#-BAUD		; Timer1 initial value
 1777:	  07F8	C2 8F			CLR	TCON.7			; Clear timer1 int pend
 1778:	  07FA	F1 FE			ACALL	IRET		; Reset interrupt system
 1779:	  07FC	01 3C			AJMP	PROMPT		; Re-enter monitor

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1780:	  07FE			IRET:
 1781:	  07FE	32			RETI
 1782:				;
 1783:				; Save the user registers & switch to montor stack
 1784:				;
 1785:	  07FF			SAVEREG:
 1786:	  07FF	C0 82			PUSH	DP0L			; Save DPTR
 1787:	  0801	C0 83			PUSH	DP0H			; ""
 1788:				; Save A,B PSW & DPTR
 1789:	  0803	90 F7 83		MOV	DPTR,#MRSAVE	; Point to save area
 1790:	  0806	F0			MOVX	@DPTR,A	; Save ACC
 1791:	  0807	A3			INC	DPTR
 1792:	  0808	E5 F0			MOV	A,B				; Save 'B'
 1793:	  080A	F0			MOVX	@DPTR,A
 1794:	  080B	A3			INC	DPTR
 1795:	  080C	E5 D0			MOV	A,PSW			; Save PSW
 1796:	  080E	F0			MOVX	@DPTR,A
 1797:	  080F	A3			INC	DPTR
 1798:	  0810	53 D0 E7		ANL	PSW,#11100111b	; Insure RB=0
 1799:	  0813	D0 E0			POP	ACC				; Save DP0H
 1800:	  0815	F0			MOVX	@DPTR,A
 1801:	  0816	A3			INC	DPTR
 1802:	  0817	D0 E0			POP	ACC				; Save DP0L
 1803:	  0819	F0			MOVX	@DPTR,A
 1804:				; Save the return address so we can get back to monitor
 1805:	  081A	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to temp space
 1806:	  081D	D0 E0			POP	ACC				; Get HIGH ret addr
 1807:	  081F	F0			MOVX	@DPTR,A	; Save it
 1808:	  0820	A3			INC	DPTR			; Advance
 1809:	  0821	D0 E0			POP	ACC				; Get LOW ret addr
 1810:	  0823	F0			MOVX	@DPTR,A	; Save it
 1811:				; Save R0-R7 + n bytes of stack space
 1812:	  0824	90 F7 88		MOV	DPTR,#MRSAVE+5	; Point to registers
 1813:	  0827	E8			MOV	A,R0			; Save R0
 1814:	  0828	F0			MOVX	@DPTR,A
 1815:	  0829	A3			INC	DPTR
 1816:	  082A	78 01			MOV	R0,#1			; Point to R1
 1817:	  082C			SAVER1:
 1818:	  082C	E6			MOV	A,@R0			; Get data
 1819:	  082D	F0			MOVX	@DPTR,A		; Write to memory
 1820:	  082E	A3			INC	DPTR			; Advance pointer
 1821:	  082F	08			INC	R0				; Next internal
 1822:	  0830	B8 20 F9		CJNE	R0,#MSSIZE,SAVER1 ; Do them all
 1823:				; Save the users PC
 1824:	  0833	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1825:	  0836	D0 E0			POP	ACC				; Get HIGH pc
 1826:	  0838	F0			MOVX	@DPTR,A	; Save PC
 1827:	  0839	A3			INC	DPTR			; Advance
 1828:	  083A	D0 E0			POP	ACC				; Get LOW PC
 1829:	  083C	F0			MOVX	@DPTR,A	; Advance
 1830:	  083D	A3			INC	DPTR			; Advance
 1831:				; Save the users stack pointer
 1832:	  083E	E5 81			MOV	A,SP			; Get SP
 1833:	  0840	F0			MOVX	@DPTR,A	; Save for later
 1834:				; Return to caller by jumping to original routine
 1835:	  0841	75 81 07		MOV	SP,#STACK		; Reset to our stack pointer

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 1836:	  0844	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to temporary location
 1837:	  0847	E0			MOVX	A,@DPTR	; Get value
 1838:	  0848	F5 F0			MOV	B,A				; Save for later
 1839:	  084A	A3			INC	DPTR			; Advance
 1840:	  084B	E0			MOVX	A,@DPTR	; Get rest of value
 1841:	  084C	C0 E0			PUSH	ACC			; Save for return
 1842:	  084E	C0 F0			PUSH	B			; ""
 1843:	  0850	22			RET					; Back to caller
 1844:				;
 1845:				; Text Messages
 1846:				;
 1847:	  0851	20 42 79 74	M_BYTES:	DB	' Bytes',0
	  0855	65 73 00
 1848:	  0858	2D 3E 00	M_PC:		DB	'->',0
 1849:	  085B	3F 4C 6F 61	M_LOAD:		DB	'?Load error',0
	  085F	64 20 65 72
	  0863	72 6F 72 00
 1850:	  0867	42 72 65 61	M_BREAK:	DB	'Break at ',0
	  086B	6B 20 61 74
	  086F	20 00
 1851:	  0871	0A 0D 42 72	M_CONFL:	DB	0Ah,0Dh,'Breakpoint conflict!',0
	  0875	65 61 6B 70
	  0879	6F 69 6E 74
	  087D	20 63 6F 6E
	  0881	66 6C 69 63
	  0885	74 21 00
 1852:	  0888	0A 0D 4D 4F	M_HELLO:	DB	0Ah,0Dh,'MON51 v1.1 (c) Dave Dunfield',0Ah,0Dh
	  088C	4E 35 31 20
	  0890	76 31 2E 31
	  0894	20 28 63 29
	  0898	20 44 61 76
	  089C	65 20 44 75
	  08A0	6E 66 69 65
	  08A4	6C 64 0A 0D
 1853:	  08A8	4F 72 69 67				DB	'Original code at https://dunfield.themindfactory.com',0Ah,0Dh
	  08AC	69 6E 61 6C
	  08B0	20 63 6F 64
	  08B4	65 20 61 74
	  08B8	20 68 74 74
	  08BC	70 73 3A 2F
	  08C0	2F 64 75 6E
	  08C4	66 69 65 6C
	  08C8	64 2E 74 68
	  08CC	65 6D 69 6E
	  08D0	64 66 61 63
	  08D4	74 6F 72 79
	  08D8	2E 63 6F 6D
	  08DC	0A 0D
 1854:	  08DE	53 65 65 20				DB	'See COPY.TXT at the above address for more information.',0Ah,0Dh
	  08E2	43 4F 50 59
	  08E6	2E 54 58 54
	  08EA	20 61 74 20
	  08EE	74 68 65 20
	  08F2	61 62 6F 76
	  08F6	65 20 61 64
	  08FA	64 72 65 73

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

	  08FE	73 20 66 6F
	  0902	72 20 6D 6F
	  0906	72 65 20 69
	  090A	6E 66 6F 72
	  090E	6D 61 74 69
	  0912	6F 6E 2E 0A
	  0916	0D
 1855:	  0917	0A 0D 2D 20				DB	0Ah,0Dh,'- New Z command added',0Ah,0Dh
	  091B	4E 65 77 20
	  091F	5A 20 63 6F
	  0923	6D 6D 61 6E
	  0927	64 20 61 64
	  092B	64 65 64 0A
	  092F	0D
 1856:	  0930	2D 20 55 73				DB	'- User Program space starts at address 0x',0
	  0934	65 72 20 50
	  0938	72 6F 67 72
	  093C	61 6D 20 73
	  0940	70 61 63 65
	  0944	20 73 74 61
	  0948	72 74 73 20
	  094C	61 74 20 61
	  0950	64 64 72 65
	  0954	73 73 20 30
	  0958	78 00
 1857:				;
 1858:				; Table of register names to output
 1859:				;
 1860:	  095A			RNTABLE:
 1861:	  095A	50 43 3D 00		DB	'PC=',0
 1862:	  095E	00			DB	'',0
 1863:	  095F	20 53 50 3D		DB	' SP=',0
	  0963	00
 1864:	  0964	20 41 3D 00		DB	' A=',0
 1865:	  0968	20 42 3D 00		DB	' B=',0
 1866:	  096C	20 50 53 57		DB	' PSW=',0
	  0970	3D 00
 1867:	  0972	20 44 50 54		DB	' DPTR=',0
	  0976	52 3D 00
 1868:	  0979	00			DB	'',0
 1869:				; Note 'RDUMP' keys on a leading $0A to detect register bank
 1870:	  097A	0A 0D 00		DB	0Ah,0Dh,0
 1871:	  097D	52 30 3D 00		DB	'R0=',0
 1872:	  0981	20 52 31 3D		DB	' R1=',0
	  0985	00
 1873:	  0986	20 52 32 3D		DB	' R2=',0
	  098A	00
 1874:	  098B	20 52 33 3D		DB	' R3=',0
	  098F	00
 1875:	  0990	20 52 34 3D		DB	' R4=',0
	  0994	00
 1876:	  0995	20 52 35 3D		DB	' R5=',0
	  0999	00
 1877:	  099A	20 52 36 3D		DB	' R6=',0
	  099E	00
 1878:	  099F	20 52 37 3D		DB	' R7=',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

	  09A3	00
 1879:	  09A4	FF			DB	0FFh		; End of list
 1880:				;
 1881:				; Dissassembly opcode table
 1882:				;
 1883:	  09A5			OTABLE:
 1884:	  09A5	1F 11 41 43		DB	1Fh,11h,'A','C','A','L','L',' ','a',0
	  09A9	41 4C 4C 20
	  09AD	61 00
 1885:	  09AF	F8 28 41 44		DB	0F8h,28h,'A','D','D',' ','A',',','r',0
	  09B3	44 20 41 2C
	  09B7	72 00
 1886:	  09B9	FF 25 41 44		DB	0FFh,25h,'A','D','D',' ','A',',','d',0
	  09BD	44 20 41 2C
	  09C1	64 00
 1887:	  09C3	FE 26 41 44		DB	0FEh,26h,'A','D','D',' ','A',',','i',0
	  09C7	44 20 41 2C
	  09CB	69 00
 1888:	  09CD	FF 24 41 44		DB	0FFh,24h,'A','D','D',' ','A',',','m',0
	  09D1	44 20 41 2C
	  09D5	6D 00
 1889:	  09D7	F8 38 41 44		DB	0F8h,38h,'A','D','D','C',' ','A',',','r',0
	  09DB	44 43 20 41
	  09DF	2C 72 00
 1890:	  09E2	FF 35 41 44		DB	0FFh,35h,'A','D','D','C',' ','A',',','d',0
	  09E6	44 43 20 41
	  09EA	2C 64 00
 1891:	  09ED	FE 36 41 44		DB	0FEh,36h,'A','D','D','C',' ','A',',','i',0
	  09F1	44 43 20 41
	  09F5	2C 69 00
 1892:	  09F8	FF 34 41 44		DB	0FFh,34h,'A','D','D','C',' ','A',',','m',0
	  09FC	44 43 20 41
	  0A00	2C 6D 00
 1893:	  0A03	1F 01 41 4A		DB	1Fh,01h,'A','J','M','P',' ','a',0
	  0A07	4D 50 20 61
	  0A0B	00
 1894:	  0A0C	F8 58 41 4E		DB	0F8h,58h,'A','N','L',' ','A',',','r',0
	  0A10	4C 20 41 2C
	  0A14	72 00
 1895:	  0A16	FF 55 41 4E		DB	0FFh,55h,'A','N','L',' ','A',',','d',0
	  0A1A	4C 20 41 2C
	  0A1E	64 00
 1896:	  0A20	FE 56 41 4E		DB	0FEh,56h,'A','N','L',' ','A',',','i',0
	  0A24	4C 20 41 2C
	  0A28	69 00
 1897:	  0A2A	FF 54 41 4E		DB	0FFh,54h,'A','N','L',' ','A',',','m',0
	  0A2E	4C 20 41 2C
	  0A32	6D 00
 1898:	  0A34	FF 52 41 4E		DB	0FFh,52h,'A','N','L',' ','d',',','A',0
	  0A38	4C 20 64 2C
	  0A3C	41 00
 1899:	  0A3E	FF 53 41 4E		DB	0FFh,53h,'A','N','L',' ','d',',','m',0
	  0A42	4C 20 64 2C
	  0A46	6D 00
 1900:	  0A48	FF 82 41 4E		DB	0FFh,82h,'A','N','L',' ','C',',','b',0
	  0A4C	4C 20 43 2C

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

	  0A50	62 00
 1901:	  0A52	FF B0 41 4E		DB	0FFh,0B0h,'A','N','L',' ','C',',','/','b',0
	  0A56	4C 20 43 2C
	  0A5A	2F 62 00
 1902:	  0A5D	FF B5 43 4A		DB	0FFh,0B5h,'C','J','N','E',' ','A',',','d',',','j',0
	  0A61	4E 45 20 41
	  0A65	2C 64 2C 6A
	  0A69	00
 1903:	  0A6A	FF B4 43 4A		DB	0FFh,0B4h,'C','J','N','E',' ','A',',','m',',','j',0
	  0A6E	4E 45 20 41
	  0A72	2C 6D 2C 6A
	  0A76	00
 1904:	  0A77	F8 B8 43 4A		DB	0F8h,0B8h,'C','J','N','E',' ','r',',','m',',','j',0
	  0A7B	4E 45 20 72
	  0A7F	2C 6D 2C 6A
	  0A83	00
 1905:	  0A84	FE B6 43 4A		DB	0FEh,0B6h,'C','J','N','E',' ','i',',','m',',','j',0
	  0A88	4E 45 20 69
	  0A8C	2C 6D 2C 6A
	  0A90	00
 1906:	  0A91	FF E4 43 4C		DB	0FFh,0E4h,'C','L','R',' ','A',0
	  0A95	52 20 41 00
 1907:	  0A99	FF C3 43 4C		DB	0FFh,0C3h,'C','L','R',' ','C',0
	  0A9D	52 20 43 00
 1908:	  0AA1	FF C2 43 4C		DB	0FFh,0C2h,'C','L','R',' ','b',0
	  0AA5	52 20 62 00
 1909:	  0AA9	FF F4 43 50		DB	0FFh,0F4h,'C','P','L',' ','A',0
	  0AAD	4C 20 41 00
 1910:	  0AB1	FF B3 43 50		DB	0FFh,0B3h,'C','P','L',' ','C',0
	  0AB5	4C 20 43 00
 1911:	  0AB9	FF B2 43 50		DB	0FFh,0B2h,'C','P','L',' ','b',0
	  0ABD	4C 20 62 00
 1912:	  0AC1	FF D4 44 41		DB	0FFh,0D4h,'D','A',' ','A',0
	  0AC5	20 41 00
 1913:	  0AC8	FF 14 44 45		DB	0FFh,14h,'D','E','C',' ','A',0
	  0ACC	43 20 41 00
 1914:	  0AD0	F8 18 44 45		DB	0F8h,18h,'D','E','C',' ','r',0
	  0AD4	43 20 72 00
 1915:	  0AD8	FF 15 44 45		DB	0FFh,15h,'D','E','C',' ','d',0
	  0ADC	43 20 64 00
 1916:	  0AE0	FE 16 44 45		DB	0FEh,16h,'D','E','C',' ','i',0
	  0AE4	43 20 69 00
 1917:	  0AE8	FF 84 44 49		DB	0FFh,84h,'D','I','V',' ','A','B',0
	  0AEC	56 20 41 42
	  0AF0	00
 1918:	  0AF1	F8 D8 44 4A		DB	0F8h,0D8h,'D','J','N','Z',' ','r',',','j',0
	  0AF5	4E 5A 20 72
	  0AF9	2C 6A 00
 1919:	  0AFC	FF D5 44 4A		DB	0FFh,0D5h,'D','J','N','Z',' ','d',',','j',0
	  0B00	4E 5A 20 64
	  0B04	2C 6A 00
 1920:	  0B07	FF 04 49 4E		DB	0FFh,04h,'I','N','C',' ','A',0
	  0B0B	43 20 41 00
 1921:	  0B0F	F8 08 49 4E		DB	0F8h,08h,'I','N','C',' ','r',0
	  0B13	43 20 72 00
 1922:	  0B17	FF 05 49 4E		DB	0FFh,05h,'I','N','C',' ','d',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

	  0B1B	43 20 64 00
 1923:	  0B1F	FE 06 49 4E		DB	0FEh,06h,'I','N','C',' ','i',0
	  0B23	43 20 69 00
 1924:	  0B27	FF A3 49 4E		DB	0FFh,0A3h,'I','N','C',' ','D','P','T','R',0
	  0B2B	43 20 44 50
	  0B2F	54 52 00
 1925:	  0B32	FF 20 4A 42		DB	0FFh,20h,'J','B',' ','b',',','j',0
	  0B36	20 62 2C 6A
	  0B3A	00
 1926:	  0B3B	FF 10 4A 42		DB	0FFh,10h,'J','B','C',' ','b',',','j',0
	  0B3F	43 20 62 2C
	  0B43	6A 00
 1927:	  0B45	FF 40 4A 43		DB	0FFh,40h,'J','C',' ','j',0
	  0B49	20 6A 00
 1928:	  0B4C	FF 73 4A 4D		DB	0FFh,73h,'J','M','P',' ','[','A','+','D','P','T','R',']',0
	  0B50	50 20 5B 41
	  0B54	2B 44 50 54
	  0B58	52 5D 00
 1929:	  0B5B	FF 30 4A 4E		DB	0FFh,30h,'J','N','B',' ','b',',','j',0
	  0B5F	42 20 62 2C
	  0B63	6A 00
 1930:	  0B65	FF 50 4A 4E		DB	0FFh,50h,'J','N','C',' ','j',0
	  0B69	43 20 6A 00
 1931:	  0B6D	FF 70 4A 4E		DB	0FFh,70h,'J','N','Z',' ','j',0
	  0B71	5A 20 6A 00
 1932:	  0B75	FF 60 4A 5A		DB	0FFh,60h,'J','Z',' ','j',0
	  0B79	20 6A 00
 1933:	  0B7C	FF 12 4C 43		DB	0FFh,12h,'L','C','A','L','L',' ','x',0
	  0B80	41 4C 4C 20
	  0B84	78 00
 1934:	  0B86	FF 02 4C 4A		DB	0FFh,02h,'L','J','M','P',' ','x',0
	  0B8A	4D 50 20 78
	  0B8E	00
 1935:	  0B8F	F8 E8 4D 4F		DB	0F8h,0E8h,'M','O','V',' ','A',',','r',0
	  0B93	56 20 41 2C
	  0B97	72 00
 1936:	  0B99	FF E5 4D 4F		DB	0FFh,0E5h,'M','O','V',' ','A',',','d',0
	  0B9D	56 20 41 2C
	  0BA1	64 00
 1937:	  0BA3	FE E6 4D 4F		DB	0FEh,0E6h,'M','O','V',' ','A',',','i',0
	  0BA7	56 20 41 2C
	  0BAB	69 00
 1938:	  0BAD	FF 74 4D 4F		DB	0FFh,74h,'M','O','V',' ','A',',','m',0
	  0BB1	56 20 41 2C
	  0BB5	6D 00
 1939:	  0BB7	F8 F8 4D 4F		DB	0F8h,0F8h,'M','O','V',' ','r',',','A',0
	  0BBB	56 20 72 2C
	  0BBF	41 00
 1940:	  0BC1	F8 A8 4D 4F		DB	0F8h,0A8h,'M','O','V',' ','r',',','d',0
	  0BC5	56 20 72 2C
	  0BC9	64 00
 1941:	  0BCB	F8 78 4D 4F		DB	0F8h,78h,'M','O','V',' ','r',',','m',0
	  0BCF	56 20 72 2C
	  0BD3	6D 00
 1942:	  0BD5	FF F5 4D 4F		DB	0FFh,0F5h,'M','O','V',' ','d',',','A',0
	  0BD9	56 20 64 2C

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

	  0BDD	41 00
 1943:	  0BDF	F8 88 4D 4F		DB	0F8h,88h,'M','O','V',' ','d',',','r',0
	  0BE3	56 20 64 2C
	  0BE7	72 00
 1944:	  0BE9	FF 85 4D 4F		DB	0FFh,85h,'M','O','V',' ','e',',','f',0
	  0BED	56 20 65 2C
	  0BF1	66 00
 1945:	  0BF3	FE 86 4D 4F		DB	0FEh,86h,'M','O','V',' ','d',',','i',0
	  0BF7	56 20 64 2C
	  0BFB	69 00
 1946:	  0BFD	FF 75 4D 4F		DB	0FFh,75h,'M','O','V',' ','d',',','m',0
	  0C01	56 20 64 2C
	  0C05	6D 00
 1947:	  0C07	FE F6 4D 4F		DB	0FEh,0F6h,'M','O','V',' ','i',',','A',0
	  0C0B	56 20 69 2C
	  0C0F	41 00
 1948:	  0C11	FE A6 4D 4F		DB	0FEh,0A6h,'M','O','V',' ','i',',','d',0
	  0C15	56 20 69 2C
	  0C19	64 00
 1949:	  0C1B	FE 76 4D 4F		DB	0FEh,76h,'M','O','V',' ','i',',','m',0
	  0C1F	56 20 69 2C
	  0C23	6D 00
 1950:	  0C25	FF A2 4D 4F		DB	0FFh,0A2h,'M','O','V',' ','C',',','b',0
	  0C29	56 20 43 2C
	  0C2D	62 00
 1951:	  0C2F	FF 92 4D 4F		DB	0FFh,92h,'M','O','V',' ','b',',','C',0
	  0C33	56 20 62 2C
	  0C37	43 00
 1952:	  0C39	FF 90 4D 4F		DB	0FFh,90h,'M','O','V',' ','D','P','T','R',',','#','x',0
	  0C3D	56 20 44 50
	  0C41	54 52 2C 23
	  0C45	78 00
 1953:	  0C47	FF 93 4D 4F		DB	0FFh,93h,'M','O','V','C',' ','A',',','[','A','+','D','P','T','R',']',0
	  0C4B	56 43 20 41
	  0C4F	2C 5B 41 2B
	  0C53	44 50 54 52
	  0C57	5D 00
 1954:	  0C59	FF 83 4D 4F		DB	0FFh,83h,'M','O','V','C',' ','A',',','[','A','+','P','C',']',0
	  0C5D	56 43 20 41
	  0C61	2C 5B 41 2B
	  0C65	50 43 5D 00
 1955:	  0C69	FE E2 4D 4F		DB	0FEh,0E2h,'M','O','V','X',' ','A',',','i',0
	  0C6D	56 58 20 41
	  0C71	2C 69 00
 1956:	  0C74	FF E0 4D 4F		DB	0FFh,0E0h,'M','O','V','X',' ','A',',','[','D','P','T','R',']',0
	  0C78	56 58 20 41
	  0C7C	2C 5B 44 50
	  0C80	54 52 5D 00
 1957:	  0C84	FE F2 4D 4F		DB	0FEh,0F2h,'M','O','V','X',' ','i',',','A',0
	  0C88	56 58 20 69
	  0C8C	2C 41 00
 1958:	  0C8F	FF F0 4D 4F		DB	0FFh,0F0h,'M','O','V','X',' ','[','D','P','T','R',']',',','A',0
	  0C93	56 58 20 5B
	  0C97	44 50 54 52
	  0C9B	5D 2C 41 00
 1959:	  0C9F	FF A4 4D 55		DB	0FFh,0A4h,'M','U','L',' ','A','B',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

	  0CA3	4C 20 41 42
	  0CA7	00
 1960:	  0CA8	FF 00 4E 4F		DB	0FFh,00h,'N','O','P',0
	  0CAC	50 00
 1961:	  0CAE	F8 48 4F 52		DB	0F8h,48h,'O','R','L',' ','A',',','r',0
	  0CB2	4C 20 41 2C
	  0CB6	72 00
 1962:	  0CB8	FF 45 4F 52		DB	0FFh,45h,'O','R','L',' ','A',',','d',0
	  0CBC	4C 20 41 2C
	  0CC0	64 00
 1963:	  0CC2	FE 46 4F 52		DB	0FEh,46h,'O','R','L',' ','A',',','i',0
	  0CC6	4C 20 41 2C
	  0CCA	69 00
 1964:	  0CCC	FF 44 4F 52		DB	0FFh,44h,'O','R','L',' ','A',',','m',0
	  0CD0	4C 20 41 2C
	  0CD4	6D 00
 1965:	  0CD6	FF 42 4F 52		DB	0FFh,42h,'O','R','L',' ','d',',','A',0
	  0CDA	4C 20 64 2C
	  0CDE	41 00
 1966:	  0CE0	FF 43 4F 52		DB	0FFh,43h,'O','R','L',' ','d',',','m',0
	  0CE4	4C 20 64 2C
	  0CE8	6D 00
 1967:	  0CEA	FF 72 4F 52		DB	0FFh,72h,'O','R','L',' ','C',',','b',0
	  0CEE	4C 20 43 2C
	  0CF2	62 00
 1968:	  0CF4	FF A0 4F 52		DB	0FFh,0A0h,'O','R','L',' ','C',',','/','b',0
	  0CF8	4C 20 43 2C
	  0CFC	2F 62 00
 1969:	  0CFF	FF D0 50 4F		DB	0FFh,0D0h,'P','O','P',' ','d',0
	  0D03	50 20 64 00
 1970:	  0D07	FF C0 50 55		DB	0FFh,0C0h,'P','U','S','H',' ','d',0
	  0D0B	53 48 20 64
	  0D0F	00
 1971:	  0D10	FF 22 52 45		DB	0FFh,22h,'R','E','T',0
	  0D14	54 00
 1972:	  0D16	FF 32 52 45		DB	0FFh,32h,'R','E','T','I',0
	  0D1A	54 49 00
 1973:	  0D1D	FF 23 52 4C		DB	0FFh,23h,'R','L',' ','A',0
	  0D21	20 41 00
 1974:	  0D24	FF 33 52 4C		DB	0FFh,33h,'R','L','C',' ','A',0
	  0D28	43 20 41 00
 1975:	  0D2C	FF 03 52 52		DB	0FFh,03h,'R','R',' ','A',0
	  0D30	20 41 00
 1976:	  0D33	FF 13 52 52		DB	0FFh,13h,'R','R','C',' ','A',0
	  0D37	43 20 41 00
 1977:	  0D3B	FF D3 53 45		DB	0FFh,0D3h,'S','E','T','B',' ','C',0
	  0D3F	54 42 20 43
	  0D43	00
 1978:	  0D44	FF D2 53 45		DB	0FFh,0D2h,'S','E','T','B',' ','b',0
	  0D48	54 42 20 62
	  0D4C	00
 1979:	  0D4D	FF 80 53 4A		DB	0FFh,80h,'S','J','M','P',' ','j',0
	  0D51	4D 50 20 6A
	  0D55	00
 1980:	  0D56	F8 98 53 55		DB	0F8h,98h,'S','U','B','B',' ','A',',','r',0
	  0D5A	42 42 20 41

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

	  0D5E	2C 72 00
 1981:	  0D61	FF 95 53 55		DB	0FFh,95h,'S','U','B','B',' ','A',',','d',0
	  0D65	42 42 20 41
	  0D69	2C 64 00
 1982:	  0D6C	FE 96 53 55		DB	0FEh,96h,'S','U','B','B',' ','A',',','i',0
	  0D70	42 42 20 41
	  0D74	2C 69 00
 1983:	  0D77	FF 94 53 55		DB	0FFh,94h,'S','U','B','B',' ','A',',','m',0
	  0D7B	42 42 20 41
	  0D7F	2C 6D 00
 1984:	  0D82	FF C4 53 57		DB	0FFh,0C4h,'S','W','A','P',' ','A',0
	  0D86	41 50 20 41
	  0D8A	00
 1985:	  0D8B	F8 C8 58 43		DB	0F8h,0C8h,'X','C','H',' ','A',',','r',0
	  0D8F	48 20 41 2C
	  0D93	72 00
 1986:	  0D95	FF C5 58 43		DB	0FFh,0C5h,'X','C','H',' ','A',',','d',0
	  0D99	48 20 41 2C
	  0D9D	64 00
 1987:	  0D9F	FE C6 58 43		DB	0FEh,0C6h,'X','C','H',' ','A',',','i',0
	  0DA3	48 20 41 2C
	  0DA7	69 00
 1988:	  0DA9	FE D6 58 43		DB	0FEh,0D6h,'X','C','H','D',' ','A',',','i',0
	  0DAD	48 44 20 41
	  0DB1	2C 69 00
 1989:	  0DB4	F8 68 58 52		DB	0F8h,68h,'X','R','L',' ','A',',','r',0
	  0DB8	4C 20 41 2C
	  0DBC	72 00
 1990:	  0DBE	FF 65 58 52		DB	0FFh,65h,'X','R','L',' ','A',',','d',0
	  0DC2	4C 20 41 2C
	  0DC6	64 00
 1991:	  0DC8	FE 66 58 52		DB	0FEh,66h,'X','R','L',' ','A',',','i',0
	  0DCC	4C 20 41 2C
	  0DD0	69 00
 1992:	  0DD2	FF 64 58 52		DB	0FFh,64h,'X','R','L',' ','A',',','m',0
	  0DD6	4C 20 41 2C
	  0DDA	6D 00
 1993:	  0DDC	FF 62 58 52		DB	0FFh,62h,'X','R','L',' ','d',',','A',0
	  0DE0	4C 20 64 2C
	  0DE4	41 00
 1994:	  0DE6	FF 63 58 52		DB	0FFh,63h,'X','R','L',' ','d',',','m',0
	  0DEA	4C 20 64 2C
	  0DEE	6D 00
 1995:	  0DF0	00 00 3F 49		DB	0,0,'?','I','L','L','E','G','A','L',0
	  0DF4	4C 4C 45 47
	  0DF8	41 4C 00
 1996:				;
 1997:				; Direct memory address table
 1998:				;
 1999:	  0DFB			DTABLE:
 2000:	  0DFB	E0 41			DB	0E0h,'A'
 2001:	  0DFD	F0 42			DB	0F0h,'B'
 2002:	  0DFF	D0 50 53 57		DB	0D0h,'P','S','W'
 2003:	  0E03	81 53 50		DB	81h,'S','P'
 2004:	  0E06	82 44 50 4C		DB	82h,'D','P','L'
 2005:	  0E0A	83 44 50 48		DB	83h,'D','P','H'

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2006:	  0E0E	80 50 30		DB	80h,'P','0'
 2007:	  0E11	90 50 31		DB	90h,'P','1'
 2008:	  0E14	A0 50 32		DB	0A0h,'P','2'
 2009:	  0E17	B0 50 33		DB	0B0h,'P','3'
 2010:	  0E1A	B8 49 50		DB	0B8h,'I','P'
 2011:	  0E1D	A8 49 45		DB	0A8h,'I','E'
 2012:	  0E20	89 54 4D 4F		DB	89h,'T','M','O','D'
	  0E24	44
 2013:	  0E25	C8 54 32 43		DB	0C8h,'T','2','C','O','N'
	  0E29	4F 4E
 2014:	  0E2B	88 54 43 4F		DB	88h,'T','C','O','N'
	  0E2F	4E
 2015:	  0E30	8C 54 48 30		DB	8Ch,'T','H','0'
 2016:	  0E34	8A 54 4C 30		DB	8Ah,'T','L','0'
 2017:	  0E38	8D 54 48 31		DB	8Dh,'T','H','1'
 2018:	  0E3C	8B 54 4C 31		DB	8Bh,'T','L','1'
 2019:	  0E40	CD 54 48 32		DB	0CDh,'T','H','2'
 2020:	  0E44	CC 54 4C 32		DB	0CCh,'T','L','2'
 2021:	  0E48	CB 52 43 41		DB	0CBh,'R','C','A','P','2','H'
	  0E4C	50 32 48
 2022:	  0E4F	CA 52 43 41		DB	0CAh,'R','C','A','P','2','L'
	  0E53	50 32 4C
 2023:	  0E56	98 53 43 4F		DB	98h,'S','C','O','N'
	  0E5A	4E
 2024:	  0E5B	99 53 42 55		DB	99h,'S','B','U','F'
	  0E5F	46
 2025:	  0E60	87 50 43 4F		DB	87h,'P','C','O','N'
	  0E64	4E
 2026:	  0E65	00			DB	0
 2027:				;
 2028:				; Help text
 2029:				;
 2030:	  0E66			HTEXT:
 2031:	  0E66	4D 4F 4E 35		DB	'MON51 Commands:'
	  0E6A	31 20 43 6F
	  0E6E	6D 6D 61 6E
	  0E72	64 73 3A
 2032:	  0E75	0A 00			DB	0Ah,0
 2033:	  0E77	41 20 3C 61		DB	'A <aa>|Alter internal',0
	  0E7B	61 3E 7C 41
	  0E7F	6C 74 65 72
	  0E83	20 69 6E 74
	  0E87	65 72 6E 61
	  0E8B	6C 00
 2034:	  0E8D	42 20 5B 6E		DB	'B [n aaaa]|Breakpoints',0
	  0E91	20 61 61 61
	  0E95	61 5D 7C 42
	  0E99	72 65 61 6B
	  0E9D	70 6F 69 6E
	  0EA1	74 73 00
 2035:	  0EA4	43 20 3C 72		DB	'C <r> <data>|Change register',0
	  0EA8	3E 20 3C 64
	  0EAC	61 74 61 3E
	  0EB0	7C 43 68 61
	  0EB4	6E 67 65 20
	  0EB8	72 65 67 69

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

	  0EBC	73 74 65 72
	  0EC0	00
 2036:	  0EC1	44 20 3C 61		DB	'D <aaaa>,[aaaa]|Dump external',0
	  0EC5	61 61 61 3E
	  0EC9	2C 5B 61 61
	  0ECD	61 61 5D 7C
	  0ED1	44 75 6D 70
	  0ED5	20 65 78 74
	  0ED9	65 72 6E 61
	  0EDD	6C 00
 2037:	  0EDF	45 20 3C 61		DB	'E <aaaa>|Edit external',0
	  0EE3	61 61 61 3E
	  0EE7	7C 45 64 69
	  0EEB	74 20 65 78
	  0EEF	74 65 72 6E
	  0EF3	61 6C 00
 2038:	  0EF6	46 20 3C 61		DB	'F <aaaa>,[aaaa] <dd>|Fill external',0
	  0EFA	61 61 61 3E
	  0EFE	2C 5B 61 61
	  0F02	61 61 5D 20
	  0F06	3C 64 64 3E
	  0F0A	7C 46 69 6C
	  0F0E	6C 20 65 78
	  0F12	74 65 72 6E
	  0F16	61 6C 00
 2039:	  0F19	47 20 5B 61		DB	'G [aaaa]|Go (execute)',0
	  0F1D	61 61 61 5D
	  0F21	7C 47 6F 20
	  0F25	28 65 78 65
	  0F29	63 75 74 65
	  0F2D	29 00
 2040:	  0F2F	49 20 3C 61		DB	'I <aa>,<aa>|dump Internal',0
	  0F33	61 3E 2C 3C
	  0F37	61 61 3E 7C
	  0F3B	64 75 6D 70
	  0F3F	20 49 6E 74
	  0F43	65 72 6E 61
	  0F47	6C 00
 2041:	  0F49	4C 7C 64 6F		DB	'L|downLoad',0
	  0F4D	77 6E 4C 6F
	  0F51	61 64 00
 2042:	  0F54	4F 20 3C 61		DB	'O <aa> <data>|Output to SFR',0
	  0F58	61 3E 20 3C
	  0F5C	64 61 74 61
	  0F60	3E 7C 4F 75
	  0F64	74 70 75 74
	  0F68	20 74 6F 20
	  0F6C	53 46 52 00
 2043:	  0F70	51 20 3C 61		DB	'Q <aa>|Query SFR',0
	  0F74	61 3E 7C 51
	  0F78	75 65 72 79
	  0F7C	20 53 46 52
	  0F80	00
 2044:	  0F81	52 7C 64 75		DB	'R|dump Registers',0
	  0F85	6D 70 20 52
	  0F89	65 67 69 73

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

	  0F8D	74 65 72 73
	  0F91	00
 2045:	  0F92	53 7C 53 69		DB	'S|Single-Step',0
	  0F96	6E 67 6C 65
	  0F9A	2D 53 74 65
	  0F9E	70 00
 2046:	  0FA0	55 20 3C 61		DB	'U <aaaa>,[aaaa]|Un-assemble',0
	  0FA4	61 61 61 3E
	  0FA8	2C 5B 61 61
	  0FAC	61 61 5D 7C
	  0FB0	55 6E 2D 61
	  0FB4	73 73 65 6D
	  0FB8	62 6C 65 00
 2047:	  0FBC	57 20 3C 61		DB	'W <aaaa> <data>|Single write',0
	  0FC0	61 61 61 3E
	  0FC4	20 3C 64 61
	  0FC8	74 61 3E 7C
	  0FCC	53 69 6E 67
	  0FD0	6C 65 20 77
	  0FD4	72 69 74 65
	  0FD8	00
 2048:	  0FD9	58 20 43 20		DB	'X C <aaaa>|LoopRead Code',0
	  0FDD	3C 61 61 61
	  0FE1	61 3E 7C 4C
	  0FE5	6F 6F 70 52
	  0FE9	65 61 64 20
	  0FED	43 6F 64 65
	  0FF1	00
 2049:	  0FF2	58 20 52 20		DB	'X R <aaaa>|LoopRead XDATA',0
	  0FF6	3C 61 61 61
	  0FFA	61 3E 7C 4C
	  0FFE	6F 6F 70 52
	  1002	65 61 64 20
	  1006	58 44 41 54
	  100A	41 00
 2050:	  100C	58 20 57 20		DB	'X W <aaaa> <data>|LoopWrite XDATA',0
	  1010	3C 61 61 61
	  1014	61 3E 20 3C
	  1018	64 61 74 61
	  101C	3E 7C 4C 6F
	  1020	6F 70 57 72
	  1024	69 74 65 20
	  1028	58 44 41 54
	  102C	41 00
 2051:	  102E	5A 7C 52 65		DB	'Z|Reboot - internal Prog Mem disabled',0
	  1032	62 6F 6F 74
	  1036	20 2D 20 69
	  103A	6E 74 65 72
	  103E	6E 61 6C 20
	  1042	50 72 6F 67
	  1046	20 4D 65 6D
	  104A	20 64 69 73
	  104E	61 62 6C 65
	  1052	64 00
 2052:	  1054	00			DB	0
 2053:				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2054:				; Initialize the timer 1 for auto-reload at 32xN
 2055:				;
 2056:	  1055			START:
 2057:	  1055	75 89 20		MOV	TMOD,#00100000b	; T1=8 bit auto-reload
 2058:	  1058	75 8D FF		MOV	TH1,#-BAUD		; Timer 1 reload value
 2059:	  105B	75 8B FF		MOV	TL1,#-BAUD		; Timer 1 initial value
 2060:	  105E	75 88 49		MOV	TCON,#01001001b	; Run 1, Hold 0
 2061:				; Initialize the serial port
 2062:	  1061	75 98 52		MOV	SCON,#01010010b	; Mode 1, REN, TXRDY, RXEMPTY
 2063:				; Main program - First, initialize memory
 2064:	  1064			MAIN:
 2065:	  1064	90 F7 80		MOV	DPTR,#PCSAVE	; Point to monitor RAM
 2066:	  1067	74 30			MOV	A,#HIGH(USERRAM)		; High default PC
 2067:	  1069	F0			MOVX	@DPTR,A	; Set it
 2068:	  106A	A3			INC	DPTR			; Advance
 2069:	  106B	74 00			MOV	A,#LOW(USERRAM)		; Low default PC
 2070:	  106D	F0			MOVX	@DPTR,A	; Set it
 2071:	  106E	A3			INC	DPTR			; Advance
 2072:	  106F	74 07			MOV	A,#7			; Default stack
 2073:	  1071	F0			MOVX	@DPTR,A	; Set it
 2074:	  1072	A3			INC	DPTR			; Advance
 2075:	  1073	7F 4D			MOV	R7,#MRSIZE		; Indicate size
 2076:	  1075	E4			CLR	A				; Zero
 2077:	  1076			CLEAR1:
 2078:	  1076	F0			MOVX	@DPTR,A	; Zero location
 2079:	  1077	A3			INC	DPTR			; Advance
 2080:	  1078	DF FC			DJNZ	R7,CLEAR1	; Keep going
 2081:	  107A	90 08 88		MOV	DPTR,#M_HELLO	; Point to startup message
 2082:	  107D	12 04 5C		LCALL	WRSTR		; Write it
 2083:	  1080	90 30 00		MOV	DPTR,#USERRAM	; Get start of USER program space
 2084:	  1083	12 04 42		LCALL	WRDPTR		; Write it
 2085:	  1086	02 00 3A		LJMP	FPROMPT		; And execute
 2086:
 2087:					END
 2088:





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 210
ACC				  DATA	      E0	 150
AUXR				  DATA	      8E	 126
B				  DATA	      F0	 151
BAUD				  NUMBER    0001	 226
BREAK1				  CODE	    0774	1673
BREAK2				  CODE	    077F	1684
BREAK3				  CODE	    0787	1692
BREAK4				  CODE	    078A	1696
BREAKPT				  CODE	    076D	1668
BRKPT				  CODE	    02CF	 770
BRKPT1				  CODE	    02DC	 777
BRKPT2				  CODE	    02FC	 799
BRKTAB				  CODE	    F7A8	 247
CBW				  CODE	    072E	1620
CHKC1				  CODE	    04F9	1186
CHKCHR				  CODE	    04F1	1181
CHRE1				  CODE	    0295	 720
CHRE2				  CODE	    0278	 698
CHRE3				  CODE	    0282	 705
CHRE4				  CODE	    0285	 709
CHREG				  CODE	    0245	 670
CLEAR1				  CODE	    1076	2077
CLKREG				  DATA	      8F	 127
COMP				  CODE	    0595	1320
COMP1				  CODE	    05A1	1329
CPRL2				  BIT	      C8	 197
CT2				  BIT	      C9	 198
CY				  BIT	      D7	 211
DIR1				  CODE	    06CC	1541
DIR2				  CODE	    06D7	1548
DIR3				  CODE	    06E3	1556
DIR4				  CODE	    06E8	1560
DIRECT				  CODE	    06C3	1536
DIS1				  CODE	    05E7	1381
DIS10				  CODE	    065D	1465
DIS11				  CODE	    0677	1483
DIS111				  CODE	    067C	1486
DIS112				  CODE	    067E	1488
DIS12				  CODE	    0680	1491
DIS121				  CODE	    0693	1502
DIS13				  CODE	    069D	1509
DIS14				  CODE	    06A9	1516
DIS15				  CODE	    06B5	1523
DIS2				  CODE	    0601	1404
DIS3				  CODE	    05F3	1392
DIS4				  CODE	    05F5	1394
DIS41				  CODE	    05FB	1399

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIS5				  CODE	    0608	1411
DIS51				  CODE	    0610	1416
DIS6				  CODE	    0618	1422
DIS7				  CODE	    0630	1436
DIS8				  CODE	    063D	1444
DIS9				  CODE	    064A	1452
DIS91				  CODE	    0655	1459
DISASS				  CODE	    05D9	1372
DLBYTE				  CODE	    0506	1202
DLEOF				  CODE	    0536	1241
DLERR				  CODE	    0538	1244
DLINT				  CODE	    0567	1281
DLINT1				  CODE	    0586	1303
DLMOT				  CODE	    052A	1233
DLMOT1				  CODE	    053F	1248
DLMOT2				  CODE	    0557	1266
DLNIB				  CODE	    050E	1212
DLNIB1				  CODE	    0522	1223
DLOAD				  CODE	    0525	1229
DODISS				  CODE	    05A4	1336
DODISS1				  CODE	    05B6	1346
DODISS2				  CODE	    05C6	1357
DODISS3				  CODE	    05D1	1363
DOXSUB				  CODE	    036B	 875
DP0H				  DATA	      83	 115
DP0L				  DATA	      82	 114
DP1H				  DATA	      85	 117
DP1L				  DATA	      84	 116
DTABLE				  CODE	    0DFB	1999
DUMP1				  CODE	    0056	 307
DUMP1A				  CODE	    0060	 314
DUMP1B				  CODE	    0067	 319
DUMP1C				  CODE	    007D	 333
DUMP1D				  CODE	    0084	 338
DUMP1E				  CODE	    0092	 350
DUMP2				  CODE	    00AB	 372
DUMP2A				  CODE	    00B4	 379
DUMPI				  CODE	    009A	 361
DUMPO				  CODE	    004F	 302
EA				  BIT	      AF	 182
EDIT1				  CODE	    00C9	 396
EDIT1A				  CODE	    00DB	 407
EDIT1B				  CODE	    00DE	 410
EDIT2				  CODE	    00F6	 427
EDIT2A				  CODE	    010B	 439
EDIT2B				  CODE	    010E	 442
EDITE				  CODE	    00C4	 393
EDITI				  CODE	    00EE	 422
EECON				  DATA	      96	 129
ERROR1				  CODE	    0094	 353
ERROR2				  CODE	    0299	 724
ERROR3				  CODE	    03C3	 933
ES				  BIT	      AC	 180
ET0				  BIT	      A9	 177
ET1				  BIT	      AB	 179
ET2				  BIT	      AD	 181

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
EX0				  BIT	      A8	 176
EX1				  BIT	      AA	 178
EXEN2				  BIT	      CB	 200
EXF2				  BIT	      CE	 203
EXTI0				  CODE	    0003	 214
EXTI1				  CODE	    0013	 216
F0				  BIT	      D5	 209
FE				  BIT	      9F	 175
FILL				  CODE	    029B	 729
FILL1				  CODE	    02A9	 737
FLUSH				  CODE	    04FA	1191
FLUSH1				  CODE	    04FC	1193
FPROMPT				  CODE	    003A	 287
GETP1				  CODE	    040F	 993
GETP2				  CODE	    041B	 999
GETPC				  CODE	    0400	 983
GETSFR				  CODE	    0346	 848
GOC1				  CODE	    0145	 484
GOC2				  CODE	    0160	 502
GOC3				  CODE	    0163	 506
GOC4				  CODE	    016C	 512
GOCMD				  CODE	    012F	 470
HELP				  CODE	    03C5	 938
HELP1				  CODE	    03CB	 941
HELP2				  CODE	    03CF	 944
HELP3				  CODE	    03D7	 950
HELP4				  CODE	    03E3	 957
HELP5				  CODE	    03E8	 961
HTEXT				  CODE	    0E66	2030
IE				  DATA	      A8	 135
IE0				  BIT	      89	 154
IE1				  BIT	      8B	 156
INC23				  CODE	    0725	1611
INT0				  BIT	      B2	 185
INT1				  BIT	      B3	 186
IP				  DATA	      B8	 140
IPH				  DATA	      B7	 139
IRET				  CODE	    07FE	1780
IT0				  BIT	      88	 153
IT1				  BIT	      8A	 155
LAR21				  CODE	    0713	1599
LAR21Z				  CODE	    0710	1595
LATCH				  NUMBER    F800	 228
LOAD				  CODE	    0116	 451
LOAD1				  CODE	    011E	 457
MAIN				  CODE	    1064	2064
MBUFFER				  CODE	    F7BC	 248
MISO				  BIT	      96	 165
MONRAM				  NUMBER    F780	 224
MOSI				  BIT	      95	 164
MRSAVE				  CODE	    F783	 246
MRSIZE				  NUMBER    004D	 249
MSSIZE				  NUMBER    0020	 231
M_BREAK				  CODE	    0867	1850
M_BYTES				  CODE	    0851	1847
M_CONFL				  CODE	    0871	1851

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
M_HELLO				  CODE	    0888	1852
M_LOAD				  CODE	    085B	1849
M_PC				  CODE	    0858	1848
NBREAK				  NUMBER    0004	 232
OTABLE				  CODE	    09A5	1883
OUTFLAG				  NUMBER    007F	 236
OUTPUT				  CODE	    035D	 865
OV				  BIT	      D2	 206
P				  BIT	      D0	 205
P0				  DATA	      80	 112
P1				  DATA	      90	 128
P2				  DATA	      A0	 132
P3				  DATA	      B0	 138
PATCHBP				  CODE	    01A6	 554
PCON				  DATA	      87	 119
PCSAVE				  CODE	    F780	 244
PROMPT				  CODE	    003C	 289
PROMPT1				  CODE	    0098	 356
PS				  BIT	      BC	 195
PSW				  DATA	      D0	 148
PT0				  BIT	      B9	 192
PT1				  BIT	      BB	 194
PT2				  BIT	      BD	 196
PX0				  BIT	      B8	 191
PX1				  BIT	      BA	 193
QUERY				  CODE	    0339	 840
RB8				  BIT	      9A	 169
RCAP2H				  DATA	      CB	 145
RCAP2L				  DATA	      CA	 144
RCLK				  BIT	      CD	 202
RD				  BIT	      B7	 190
RDADDR				  CODE	    041F	1006
RDCHR				  CODE	    04D8	1162
RDCHR1				  CODE	    04EE	1175
RDHEX				  CODE	    049C	1111
RDINTM				  CODE	    0737	1628
RDINTM1				  CODE	    073E	1633
RDNIB				  CODE	    04A8	1123
RDNIB1				  CODE	    04B7	1134
RDNIB2				  CODE	    04C4	1143
RDNIB3				  CODE	    04CA	1148
RDNIB4				  CODE	    04D1	1153
RDNIB5				  CODE	    04D6	1156
RDRANGE				  CODE	    042C	1017
RDUMP				  CODE	    0213	 635
RDUMP1				  CODE	    0220	 643
RDUMP2				  CODE	    0240	 664
RDWORD				  CODE	    0496	1104
REBOOT				  CODE	    03F0	 970
REBOOT1				  CODE	    03FE	 978
REN				  BIT	      9C	 171
RESET				  CODE	    0000	 213
RET1				  CODE	    0495	1099
RET2				  CODE	    05A3	1331
RI				  BIT	      98	 167
RNTABLE				  CODE	    095A	1860

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ROM				  NUMBER    0000	 223
RS0				  BIT	      D3	 207
RS1				  BIT	      D4	 208
RXD				  BIT	      B0	 183
SADDR				  DATA	      A9	 136
SADEN				  DATA	      B9	 141
SAVER1				  CODE	    082C	1817
SAVEREG				  CODE	    07FF	1785
SBUF				  DATA	      99	 131
SCK				  BIT	      97	 166
SCON				  DATA	      98	 130
SDP43				  CODE	    0707	1586
SINT				  CODE	    0023	 218
SM0				  BIT	      9F	 174
SM1				  BIT	      9E	 173
SM2				  BIT	      9D	 172
SP				  DATA	      81	 113
SPCR				  DATA	      D5	 149
SPDR				  DATA	      86	 118
SPSAVE				  CODE	    F782	 245
SPSR				  DATA	      AA	 137
SS				  BIT	      94	 163
SSINT				  CODE	    07E6	1767
STACK				  NUMBER    0007	 237
START				  CODE	    1055	2056
STEP				  CODE	    01AE	 566
STEP1				  CODE	    01D4	 588
T0				  BIT	      B4	 187
T1				  BIT	      B5	 188
T2				  BIT	      90	 161
T2CON				  DATA	      C8	 142
T2EX				  BIT	      91	 162
T2MOD				  DATA	      C9	 143
TB8				  BIT	      9B	 170
TCLK				  BIT	      CC	 201
TCON				  DATA	      88	 120
TESTBRK				  CODE	    07B2	1724
TF0				  BIT	      8D	 158
TF1				  BIT	      8F	 160
TF2				  BIT	      CF	 204
TH0				  DATA	      8C	 124
TH1				  DATA	      8D	 125
TH2				  DATA	      CD	 147
TI				  BIT	      99	 168
TIMER0				  CODE	    000B	 215
TIMER1				  CODE	    001B	 217
TIMER2				  CODE	    002B	 219
TL0				  DATA	      8A	 122
TL1				  DATA	      8B	 123
TL2				  DATA	      CC	 146
TMOD				  DATA	      89	 121
TR0				  BIT	      8C	 157
TR1				  BIT	      8E	 159
TR2				  BIT	      CA	 199
TSTBR1				  CODE	    07B7	1727
TSTBR2				  CODE	    07C5	1740

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TSTBR3				  CODE	    07DA	1756
TSTBR4				  CODE	    07DF	1760
TXD				  BIT	      B1	 184
UNASS				  CODE	    02B7	 751
UNASS1				  CODE	    02C2	 757
USERRAM				  NUMBER    3000	 225
WDTCON				  DATA	      A7	 134
WDTRST				  DATA	      A6	 133
WGO				  CODE	    03ED	 965
WR				  BIT	      B6	 189
WR43				  CODE	    0703	1582
WRCHR				  CODE	    048E	1095
WRDPTR				  CODE	    0442	1034
WRHEX				  CODE	    0448	1041
WRHEX1				  CODE	    044F	1046
WRHEXS				  CODE	    06EE	1567
WRHEXS1				  CODE	    06F8	1575
WRINTM				  CODE	    0750	1647
WRINTM1				  CODE	    0757	1652
WRITE				  CODE	    03B1	 925
WRLFCR				  CODE	    0465	1066
WRLFCR1				  CODE	    046C	1070
WRLFCR2				  CODE	    0479	1076
WRLFCR3				  CODE	    047F	1079
WRLFCR4				  CODE	    0484	1082
WRSPC				  CODE	    048C	1090
WRSTR				  CODE	    045C	1056
XLC				  CODE	    03A3	 913
XLC1				  CODE	    03A8	 916
XLOOP				  CODE	    037B	 890
XLR1				  CODE	    038A	 898
XLW				  CODE	    0392	 903
XLW1				  CODE	    039B	 908
