
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	mon51.a51
	Object File:	mon51.hex
	List File:	mon51.lst



 Line  I  Addr  Code            Source

    1:				; MON51 v1.1 (c) Dave Dunfield
    2:				; Available from https://dunfield.themindfactory.com/dnldsrc.htm
    3:				;
    4:				; 8051 Monitor program
    5:				; ----------------------------------------------------------------------------
    6:				; Modified to assemble using ASEM51 v1.3
    7:				; Assemble under WIN10 using the command: ASEMW mon51
    8:				; The will assemble the file MON51.A51 to produce the hex file MON51.HEX
    9:				; and the listing file MON51.LST
   10:				; ----------------------------------------------------------------------------
   11:				; AT89S8253 Specifics:
   12:				; When using the XGecu T48 programmer, remember to set:
   13:				;  Lock Byte - No lock bit
   14:				;  Config Byte - All 4 bits set
   15:				;              + Serial program enable ticked
   16:				;              + User Row program enable ticked
   17:				;              + x2 Clock Enable ticked
   18:				;              + External Clock enable ticked (to use external osc instead of xtal)
   19:				; ----------------------------------------------------------------------------
   20:				; RCBus 8051 Board specifics:
   21:				; On-board memory extends up to $F7FF for both program and data spaces.
   22:				; Off-board I/O space (via nIORQ) is accessed between $FC00..$FFFF (partially decoded).
   23:				; Set MONRAM to $F780.
   24:				; ----------------------------------------------------------------------------
   25:				;
   26:				;
   27:				; Comamnds:
   28:				;	A <aa>		- Alter INTERNAL memory
   29:				;	  Sub commands:  xx	- Replace & advance
   30:				;			<BS>	- Backup to LAST
   31:				;			<SP>	- Advance to NEXT
   32:				;			<CR>	- Quit
   33:				;	B [bp address]	- Display/Set breakpoints
   34:				;	C <Reg> <value>	- Change register
   35:				;	D <aaaa>,[aaaa]	- Dump EXTERNAL DATA memory
   36:				;	E <aaaa>	- Edit EXTERNAL DATA memory
   37:				;	  Sub commands: Same as 'A'lter.
   38:				;	F <s>,<e> <d>	- Fill a block of memory
   39:				;	G <aaaa>	- Go (begin execution)
   40:				;	I <aa>,<aa>	- Dump INTERNAL memory
   41:				;	L		- Load program into memory
   42:				;	O <aa> <value>	- Output to SFR
   43:				;	Q <aa>		- Query SFR

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

   44:				;	R		- Display registers
   45:				;	S		- Single-Step one instruction
   46:				;	U <aaaa>,[aaaa] - Unassemble PROGRAM memory
   47:				;	?		- Display HELP summary
   48:				;
   49:				; Setup:
   50:				; The symbol ROM defines the location of the MON51 code in memory. This
   51:				; will normally be $0000, unless you are intending to run MON51 itself
   52:				; under another debugger or other operating environment.
   53:				;
   54:				; The symbol MONRAM defines a 80 byte area of memory which must be
   55:				; available for EXCLUSIVE use by MON51. This is often set to the highest
   56:				; RAM address in the system - 80.
   57:				;
   58:				; The symbol USERRAM defines the location in memory where user programs
   59:				; will be loaded. This controls the default user PC, as well re-vectoring
   60:				; the 8051 interrupts to corresponding offsets from this address. This is
   61:				; often set to the lowest available RAM address.
   62:				;
   63:				; When compiling or assembling programs to be tested under MON51, be sure
   64:				; to configure your tools such that the application code will be generated
   65:				; at the USERRAM address, and any external data areas will occur above the
   66:				; code, but below MONRAM.
   67:				;
   68:				; NOTE: In order to download and to set breakpoints, MON51 must be able to
   69:				; write to the USERRAM memory. This is normally accomplished by ANDing the
   70:				; -PSEN and -RD signals from the CPU to generate a single CODE/DATA select
   71:				; signal. If you wish to maintain separate CODE and DATA memory, you must add
   72:				; hardware to re-direct the DATA writes to the CODE memory at specific times
   73:				; (perhaps controlled via a I/O port pin). Look for comments beginning with
   74:				; '* ???' to identify places where the monitor must write to CODE memory.
   75:				;
   76:				; The symbol BAUD determines the "reload" value used for timer1 to
   77:				; establish the system baud rate. It is calculated with this formula:
   78:				;
   79:				;		BAUD = (crystal / baud rate) / 384
   80:				;
   81:				; For example, a system for which this monitor was will be used runs at
   82:				; 11.0592 Mhz, and uses a 9600 baud console connection:
   83:				;
   84:				;		BAUD = (11059200 / 9600) / 384
   85:				;
   86:				; This calculation shows that on this system, the correct BAUD value is 3.
   87:				;
   88:				; If the above formula returns a fractional value, round it to the nearest
   89:				; integer, and determine that the actual baud rate that will be generated
   90:				; using this formula:
   91:				;
   92:				;		SPEED = (crystal / integer BAUD) / 384
   93:				;
   94:				; If the result is not within 5 percent of the desired value, that speed
   95:				; is unobtainable with the crystal frequency you are using. In general, the
   96:				; lower the SPEED required, the better chance you will have of obtaining it.
   97:				;
   98:				; ?COPY.TXT 1991-2007 Dave Dunfield
   99:				;  -- see COPY.TXT --.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  100:				;
  101:				; Load register definitions for an ATMEL AT89S8253.
  102:				$NOMOD51
  103:				$INCLUDE(89S8253.MCU)
  104: 1			;   AT89S8253 processor definition file
  105: 1			;   ===================================
  106: 1
  107: 1	N	 80	P0	DATA	080H
  108: 1	N	 81	SP	DATA	081H
  109: 1	N	 82	DP0L	DATA	082H
  110: 1	N	 83	DP0H	DATA	083H
  111: 1	N	 84	DP1L	DATA	084H
  112: 1	N	 85	DP1H	DATA	085H
  113: 1	N	 86	SPDR	DATA	086H
  114: 1	N	 87	PCON	DATA	087H
  115: 1	N	 88	TCON	DATA	088H
  116: 1	N	 89	TMOD	DATA	089H
  117: 1	N	 8A	TL0	DATA	08AH
  118: 1	N	 8B	TL1	DATA	08BH
  119: 1	N	 8C	TH0	DATA	08CH
  120: 1	N	 8D	TH1	DATA	08DH
  121: 1	N	 8E	AUXR	DATA	08EH
  122: 1	N	 8F	CLKREG	DATA	08FH
  123: 1	N	 90	P1	DATA	090H
  124: 1	N	 96	EECON	DATA	096H
  125: 1	N	 98	SCON	DATA	098H
  126: 1	N	 99	SBUF	DATA	099H
  127: 1	N	 A0	P2	DATA	0A0H
  128: 1	N	 A6	WDTRST	DATA	0A6H
  129: 1	N	 A7	WDTCON	DATA	0A7H
  130: 1	N	 A8	IE	DATA	0A8H
  131: 1	N	 A9	SADDR	DATA	0A9H
  132: 1	N	 AA	SPSR	DATA	0AAH
  133: 1	N	 B0	P3	DATA	0B0H
  134: 1	N	 B7	IPH	DATA	0B7H
  135: 1	N	 B8	IP	DATA	0B8H
  136: 1	N	 B9	SADEN	DATA	0B9H
  137: 1	N	 C8	T2CON	DATA	0C8H
  138: 1	N	 C9	T2MOD	DATA	0C9H
  139: 1	N	 CA	RCAP2L	DATA	0CAH
  140: 1	N	 CB	RCAP2H	DATA	0CBH
  141: 1	N	 CC	TL2	DATA	0CCH
  142: 1	N	 CD	TH2	DATA	0CDH
  143: 1	N	 D0	PSW	DATA	0D0H
  144: 1	N	 D5	SPCR	DATA	0D5H
  145: 1	N	 E0	ACC	DATA	0E0H
  146: 1	N	 F0	B	DATA	0F0H
  147: 1
  148: 1	N	 88	IT0	BIT	088H
  149: 1	N	 89	IE0	BIT	089H
  150: 1	N	 8A	IT1	BIT	08AH
  151: 1	N	 8B	IE1	BIT	08BH
  152: 1	N	 8C	TR0	BIT	08CH
  153: 1	N	 8D	TF0	BIT	08DH
  154: 1	N	 8E	TR1	BIT	08EH
  155: 1	N	 8F	TF1	BIT	08FH

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  156: 1	N	 90	T2	BIT	090H
  157: 1	N	 91	T2EX	BIT	091H
  158: 1	N	 94	SS	BIT	094H
  159: 1	N	 95	MOSI	BIT	095H
  160: 1	N	 96	MISO	BIT	096H
  161: 1	N	 97	SCK	BIT	097H
  162: 1	N	 98	RI	BIT	098H
  163: 1	N	 99	TI	BIT	099H
  164: 1	N	 9A	RB8	BIT	09AH
  165: 1	N	 9B	TB8	BIT	09BH
  166: 1	N	 9C	REN	BIT	09CH
  167: 1	N	 9D	SM2	BIT	09DH
  168: 1	N	 9E	SM1	BIT	09EH
  169: 1	N	 9F	SM0	BIT	09FH
  170: 1	N	 9F	FE	BIT	09FH
  171: 1	N	 A8	EX0	BIT	0A8H
  172: 1	N	 A9	ET0	BIT	0A9H
  173: 1	N	 AA	EX1	BIT	0AAH
  174: 1	N	 AB	ET1	BIT	0ABH
  175: 1	N	 AC	ES	BIT	0ACH
  176: 1	N	 AD	ET2	BIT	0ADH
  177: 1	N	 AF	EA	BIT	0AFH
  178: 1	N	 B0	RXD	BIT	0B0H
  179: 1	N	 B1	TXD	BIT	0B1H
  180: 1	N	 B2	INT0	BIT	0B2H
  181: 1	N	 B3	INT1	BIT	0B3H
  182: 1	N	 B4	T0	BIT	0B4H
  183: 1	N	 B5	T1	BIT	0B5H
  184: 1	N	 B6	WR	BIT	0B6H
  185: 1	N	 B7	RD	BIT	0B7H
  186: 1	N	 B8	PX0	BIT	0B8H
  187: 1	N	 B9	PT0	BIT	0B9H
  188: 1	N	 BA	PX1	BIT	0BAH
  189: 1	N	 BB	PT1	BIT	0BBH
  190: 1	N	 BC	PS	BIT	0BCH
  191: 1	N	 BD	PT2	BIT	0BDH
  192: 1	N	 C8	CPRL2	BIT	0C8H
  193: 1	N	 C9	CT2	BIT	0C9H
  194: 1	N	 CA	TR2	BIT	0CAH
  195: 1	N	 CB	EXEN2	BIT	0CBH
  196: 1	N	 CC	TCLK	BIT	0CCH
  197: 1	N	 CD	RCLK	BIT	0CDH
  198: 1	N	 CE	EXF2	BIT	0CEH
  199: 1	N	 CF	TF2	BIT	0CFH
  200: 1	N	 D0	P	BIT	0D0H
  201: 1	N	 D2	OV	BIT	0D2H
  202: 1	N	 D3	RS0	BIT	0D3H
  203: 1	N	 D4	RS1	BIT	0D4H
  204: 1	N	 D5	F0	BIT	0D5H
  205: 1	N	 D6	AC	BIT	0D6H
  206: 1	N	 D7	CY	BIT	0D7H
  207: 1
  208: 1	N      0000	RESET	CODE	000H
  209: 1	N      0003	EXTI0	CODE	003H
  210: 1	N      000B	TIMER0	CODE	00BH
  211: 1	N      0013	EXTI1	CODE	013H

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  212: 1	N      001B	TIMER1	CODE	01BH
  213: 1	N      0023	SINT	CODE	023H
  214: 1	N      002B	TIMER2	CODE	02BH
  215:
  216:				; System parameters
  217:
  218:		N      0000	ROM		EQU	0000h		; Monitor program storage
  219:		N      F780	MONRAM	EQU	0F780h		; MON51 reserved RAM (80 bytes)
  220:		N      3000	USERRAM	EQU	3000h		; USER/download RAM - starts at 12K
  221:		N      0001	BAUD	EQU	1			; Baudrate divisor for TIMER1 - 38400 baud with x2 clock
  222:
  223:				; Symbols below this point do not normally have to be changed
  224:		N      0020	MSSIZE	EQU	32			; Amount of internal memory to save
  225:		N      0004	NBREAK	EQU	4			; Number of breakpoints
  226:
  227:				; Internal memory locations
  228:		N      0008		ORG	0008h
  229:		N      007F	OUTFLAG	EQU	7Fh
  230:		N      0007	STACK	EQU	07h
  231:
  232:				; External (reserved) memory locations
  233:
  234:		N      F780		ORG	MONRAM
  235:
  236:				; Note: PCSAVE, SPSAVE and MRSAVE must occur together in this order
  237:	  F780	N      0002	PCSAVE:	DS	2			; Program Counter save area
  238:	  F782	N      0001	SPSAVE:	DS	1			; Stack Pointer save area
  239:	  F783	N      0025	MRSAVE:	DS	MSSIZE+5	; Memory & Register save area
  240:	  F7A8	N      0014	BRKTAB:	DS	NBREAK*5	; 5 bytes/breakpoint
  241:	  F7BC	N      0014	MBUFFER:	DS	20			; Temporary space
  242:		N      004D	MRSIZE	EQU	$-MRSAVE	; Size of monitor RAM
  243:				;
  244:				; Beginning of MON51 program code
  245:				;
  246:
  247:		N      0000		ORG	ROM				; Code goes here
  248:	  0000	02 10 06		LJMP	START		; Skip interrupt vectors
  249:				; Re-vector interrupts
  250:		N      0003		ORG	ROM+0003h		; EXT Interrupt 0
  251:	  0003	02 30 03		LJMP	USERRAM+03h
  252:	  0006	81 7E			AJMP	WRCHR
  253:	  0008	81 7C			AJMP	WRSPC
  254:		N      000B		ORG	ROM+000Bh		; Timer 0 overflow
  255:	  000B	02 30 0B		LJMP	USERRAM+0Bh
  256:	  000E	81 55			AJMP	WRLFCR
  257:	  0010	81 38			AJMP	WRHEX
  258:		N      0013		ORG	ROM+0013h		; EXT Interrupt 1
  259:	  0013	02 30 13		LJMP	USERRAM+13h
  260:	  0016	81 32			AJMP	WRDPTR
  261:	  0018	81 4C			AJMP	WRSTR
  262:		N      001B		ORG	ROM+001Bh		; Timer1 - Single step
  263:	  001B	02 07 D6		LJMP	SSINT
  264:	  001E	81 C8			AJMP	RDCHR
  265:	  0020	81 98			AJMP	RDNIB
  266:		N      0023		ORG	ROM+0023h		; RI+TI interrupt
  267:	  0023	02 30 23		LJMP	USERRAM+23h

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  268:	  0026	81 8C			AJMP	RDHEX
  269:	  0028	81 86			AJMP	RDWORD
  270:		N      002B		ORG	ROM+002Bh		; TF2+EXF2
  271:	  002B	02 30 2B		LJMP	USERRAM+2Bh
  272:				;
  273:	  002E	81 1C			AJMP	RDRANGE
  274:	  0030	81 0F			AJMP	RDADDR
  275:	  0032	81 E1			AJMP	CHKCHR
  276:	  0034	81 EA			AJMP	FLUSH
  277:	  0036	A1 85			AJMP	COMP
  278:	  0038	A1 15			AJMP	DLOAD
  279:				; Prompt for and execute commands
  280:	  003A			FPROMPT:
  281:	  003A	91 EA			ACALL	FLUSH		; Clear out serial port
  282:	  003C			PROMPT:
  283:	  003C	75 81 07		MOV	SP,#STACK		; Set up stack
  284:	  003F	75 7F 00		MOV	OUTFLAG,#0		; Clear output flag
  285:	  0042	91 55			ACALL	WRLFCR		; New line
  286:	  0044	74 2A			MOV	A,#'*'			; Prompt character
  287:	  0046	91 7E			ACALL	WRCHR		; Write it out
  288:	  0048	91 C8			ACALL	RDCHR		; Read the command charecter
  289:	  004A	FF			MOV	R7,A			; Save command for later
  290:	  004B	91 7E			ACALL	WRCHR		; Echo it
  291:	  004D	91 7C			ACALL	WRSPC		; Separator
  292:				;
  293:				; 'D'ump EXTERNAL memory command
  294:				;
  295:	  004F			DUMPO:
  296:	  004F	BF 44 48		CJNE	R7,#'D',DUMPI	; No, try next
  297:	  0052	91 0F			ACALL	RDADDR		; Get starting address
  298:	  0054	91 1C			ACALL	RDRANGE		; Get ending address
  299:				; Display one line
  300:	  0056			DUMP1:
  301:	  0056	91 55			ACALL	WRLFCR		; New line
  302:	  0058	91 32			ACALL	WRDPTR		; Output address
  303:	  005A	C0 83			PUSH	DP0H			; Save high
  304:	  005C	C0 82			PUSH	DP0L			; Save low
  305:	  005E	7F 10			MOV	R7,#16			; 16 bytes/line
  306:				; Display the HEX dump
  307:	  0060			DUMP1A:
  308:	  0060	EF			MOV	A,R7			; Get count
  309:	  0061	54 03			ANL	A,#00000011b	; Test lower two
  310:	  0063	70 02			JNZ	DUMP1B			; No extra space
  311:	  0065	91 7C			ACALL	WRSPC		; Output a space
  312:	  0067			DUMP1B:
  313:	  0067	91 7C			ACALL	WRSPC		; Output a space
  314:	  0069	E0			MOVX	A,@DPTR	; Get byte
  315:	  006A	91 38			ACALL	WRHEX		; Write in hex
  316:	  006C	A3			INC	DPTR			; Advance to next
  317:	  006D	DF F1			DJNZ	R7,DUMP1A	; Do em all
  318:	  006F	91 7C			ACALL	WRSPC		; Output a spave
  319:	  0071	91 7C			ACALL	WRSPC		; Another space
  320:				; Display the ASCII dump
  321:	  0073	D0 82			POP	DP0L				; Restore low
  322:	  0075	D0 83			POP	DP0H				; Restore high
  323:	  0077	7F 10			MOV	R7,#16			; Length of line

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  324:	  0079	7B 20			MOV	R3,#' '			; Low bounds
  325:	  007B	7C 7F			MOV	R4,#127			; High bounds
  326:	  007D			DUMP1C:
  327:	  007D	E0			MOVX	A,@DPTR	; Get byte
  328:	  007E	B1 85			ACALL	COMP		; Do the compare
  329:	  0080	50 02			JNC	DUMP1D			; OK to output
  330:	  0082	74 2E			MOV	A,#'.'			; Convert to '.'
  331:	  0084			DUMP1D:
  332:	  0084	91 7E			ACALL	WRCHR		; Write it out
  333:	  0086	A3			INC	DPTR			; Next location
  334:	  0087	DF F4			DJNZ	R7,DUMP1C	; Do them all
  335:				; Stop looking if we are over
  336:	  0089	C3			CLR	C				; Insure no borrow
  337:	  008A	ED			MOV	A,R5			; Get Low
  338:	  008B	95 82			SUBB	A,DP0L		; Convert
  339:	  008D	EE			MOV	A,R6			; Get high
  340:	  008E	95 83			SUBB	A,DP0H		; Test it
  341:	  0090	50 C4			JNC	DUMP1			; More to Go
  342:				; Return to the main command line
  343:	  0092			DUMP1E:
  344:	  0092	01 3C			AJMP	PROMPT		; Back for more
  345:				; Report an error
  346:	  0094			ERROR1:
  347:	  0094	74 3F			MOV	A,#'?'			; Error
  348:	  0096	91 7E			ACALL	WRCHR		; Output
  349:	  0098			PROMPT1:
  350:	  0098	01 3C			AJMP	PROMPT		; Next command
  351:				;
  352:				; 'I'internal memory dump
  353:				;
  354:	  009A			DUMPI:
  355:	  009A	BF 49 27		CJNE	R7,#'I',EDITE	; No, try next
  356:	  009D	91 8C			ACALL	RDHEX		; Get address
  357:	  009F	40 F3			JC	ERROR1			; Invalid
  358:	  00A1	F8			MOV	R0,A			; Save in index
  359:	  00A2	74 2C			MOV	A,#','			; Separator
  360:	  00A4	91 7E			ACALL	WRCHR		; Output it
  361:	  00A6	91 8C			ACALL	RDHEX		; Get end
  362:	  00A8	40 EA			JC	ERROR1			; Invalid
  363:	  00AA	FC			MOV	R4,A			; Write it
  364:				; Display one line
  365:	  00AB			DUMP2:
  366:	  00AB	91 55			ACALL	WRLFCR		; New line
  367:	  00AD	E8			MOV	A,R0			; Get high byte
  368:	  00AE	91 38			ACALL	WRHEX		; Output
  369:	  00B0	7D 08			MOV	R5,#8			; Size of line
  370:	  00B2	91 7C			ACALL	WRSPC		; Output a space
  371:				; Display the HEX dump
  372:	  00B4			DUMP2A:
  373:	  00B4	91 7C			ACALL	WRSPC		; Output a space
  374:	  00B6	F1 27			ACALL	RDINTM		; Read internal memory
  375:	  00B8	91 38			ACALL	WRHEX		; Write in hex
  376:	  00BA	E8			MOV	A,R0			; Get address
  377:	  00BB	C3			CLR	C				; Insure no borrow
  378:	  00BC	9C			SUBB	A,R4		; Calculate remaining
  379:	  00BD	50 D3			JNC	DUMP1E			; We are all done

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  380:	  00BF	08			INC	R0				; Advance to next
  381:	  00C0	DD F2			DJNZ	R5,DUMP2A	; Do em all
  382:	  00C2	80 E7			SJMP	DUMP2		; New line
  383:				;
  384:				; 'E'dit external memory
  385:				;
  386:	  00C4			EDITE:
  387:	  00C4	BF 45 27		CJNE	R7,#'E',EDITI	; No, try edit internl
  388:	  00C7	91 0F			ACALL	RDADDR		; Get a HEX value
  389:	  00C9			EDIT1:
  390:	  00C9	91 55			ACALL	WRLFCR		; New line
  391:	  00CB	91 32			ACALL	WRDPTR		; Output address
  392:	  00CD	91 7C			ACALL	WRSPC		; Output seperator
  393:	  00CF	E0			MOVX	A,@DPTR		; Get value
  394:	  00D0	91 38			ACALL	WRHEX		; Output
  395:	  00D2	74 2D			MOV	A,#'-'			; Prompt
  396:	  00D4	91 7E			ACALL	WRCHR		; Output
  397:	  00D6	91 8C			ACALL	RDHEX		; Get value
  398:	  00D8	40 04			JC	EDIT1B			; Error
  399:	  00DA	F0			MOVX	@DPTR,A		; Write it
  400:	  00DB			EDIT1A:
  401:	  00DB	A3			INC	DPTR			; Advance to next
  402:	  00DC	80 EB			SJMP	EDIT1		; And proceed
  403:	  00DE			EDIT1B:
  404:	  00DE	60 FB			JZ	EDIT1A			; Space, advance
  405:	  00E0	14			DEC	A				; Test for next
  406:	  00E1	70 B5			JNZ	PROMPT1			; And continue
  407:	  00E3	15 82			DEC	DP0L				; Reduce low
  408:	  00E5	E5 82			MOV	A,DP0L			; Get value
  409:	  00E7	B4 FF DF		CJNE	A,#0FFh,EDIT1	; No overflow
  410:	  00EA	15 83			DEC	DP0H				; Backspace
  411:	  00EC	80 DB			SJMP	EDIT1		; And proceed
  412:				;
  413:				; 'A'lter internal memory
  414:				;
  415:	  00EE			EDITI:
  416:	  00EE	BF 41 25		CJNE	R7,#'A',LOAD	; No, try next
  417:	  00F1	91 8C			ACALL	RDHEX		; Get a HEX value
  418:	  00F3	40 9F			JC	ERROR1			; Invalid
  419:	  00F5	F8			MOV	R0,A			; Save address
  420:	  00F6			EDIT2:
  421:	  00F6	91 55			ACALL	WRLFCR		; New line
  422:	  00F8	E8			MOV	A,R0			; Get address
  423:	  00F9	91 38			ACALL	WRHEX		; Output address
  424:	  00FB	91 7C			ACALL	WRSPC		; Output seperator
  425:	  00FD	F1 27			ACALL	RDINTM		; Read internal memory
  426:	  00FF	91 38			ACALL	WRHEX		; Output
  427:	  0101	74 2D			MOV	A,#'-'			; Prompt
  428:	  0103	91 7E			ACALL	WRCHR		; Output
  429:	  0105	91 8C			ACALL	RDHEX		; Get value
  430:	  0107	40 05			JC	EDIT2B			; Error
  431:	  0109	F1 40			ACALL	WRINTM		; Write internal memory
  432:	  010B			EDIT2A:
  433:	  010B	08			INC	R0				; Advance to next
  434:	  010C	80 E8			SJMP	EDIT2		; And proceed
  435:	  010E			EDIT2B:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  436:	  010E	60 FB			JZ	EDIT2A			; Space, advance
  437:	  0110	14			DEC	A				; Test for next
  438:	  0111	70 85			JNZ	PROMPT1			; And continue
  439:	  0113	18			DEC	R0				; Backspace
  440:	  0114	80 E0			SJMP	EDIT2		; And proceed
  441:				;
  442:				; Load an image from the serial port
  443:				;
  444:	  0116			LOAD:
  445:	  0116	BF 4C 16		CJNE	R7,#'L',GOCMD	; No, try next
  446:	  0119	91 55			ACALL	WRLFCR		; New line
  447:	  011B	E4			CLR	A				; Get zero
  448:	  011C	F9			MOV	R1,A			; Zero LOW
  449:	  011D	FA			MOV	R2,A			; Zero HIGH
  450:	  011E			LOAD1:
  451:	  011E	B1 15			ACALL	DLOAD		; Get a record
  452:	  0120	50 FC			JNC	LOAD1			; And keep getting em
  453:	  0122	EA			MOV	A,R2			; Get HIGH
  454:	  0123	91 38			ACALL	WRHEX		; Output
  455:	  0125	E9			MOV	A,R1			; Get LOW
  456:	  0126	91 38			ACALL	WRHEX		; Output
  457:	  0128	90 08 41		MOV	DPTR,#M_BYTES	; Point to ' Bytes' message
  458:	  012B	91 4C			ACALL	WRSTR		; Output string
  459:	  012D	01 3A			AJMP	FPROMPT		; End of the line
  460:				;
  461:				; Go (begin execution) at the specified address)
  462:				;
  463:	  012F			GOCMD:
  464:	  012F	BF 47 7C		CJNE	R7,#'G',STEP	; No, try next
  465:	  0132	71 F0			ACALL	GETPC		; Get address
  466:	  0134	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
  467:	  0137	E0			MOVX	A,@DPTR		; Get HIGH PC
  468:	  0138	FA			MOV	R2,A			; Save for later
  469:	  0139	A3			INC	DPTR			; Advance
  470:	  013A	E0			MOVX	A,@DPTR		; Get LOW PC
  471:	  013B	F9			MOV	R1,A			; Save for later
  472:	  013C	F1 A2			ACALL	TESTBRK		; Check for breakpoint conflict
  473:	  013E	91 55			ACALL	WRLFCR		; New line
  474:				; Insert breakpoints in user code
  475:	  0140	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint table
  476:	  0143	78 00			MOV	R0,#0			; Zero counter
  477:	  0145			GOC1:
  478:	  0145	E0			MOVX	A,@DPTR		; Get HIGH address
  479:	  0146	FC			MOV	R4,A			; Save for later
  480:	  0147	A3			INC	DPTR			; Advance
  481:	  0148	E0			MOVX	A,@DPTR		; Get LOW address
  482:	  0149	FB			MOV	R3,A			; Save for later
  483:	  014A	A3			INC	DPTR			; Advance
  484:	  014B	4C			ORL	A,R4			; Breakpoint set?
  485:	  014C	60 12			JZ	GOC2			; No, skip it
  486:	  014E	D1 F7			ACALL	SDP43		; R4:3 <> DPTR
  487:	  0150	7F 12			MOV	R7,#12h		; LCALL Instruction
  488:	  0152	31 A6			ACALL	PATCHBP		; Patch breakpoint
  489:	  0154	7F 07			MOV	R7,#HIGH(BREAKPT)	; HIGH address
  490:	  0156	31 A6			ACALL	PATCHBP		; Patch breakpoint
  491:	  0158	7F 5D			MOV	R7,#LOW(BREAKPT)		; LOW address

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  492:	  015A	31 A6			ACALL	PATCHBP		; Patch breakpoint
  493:	  015C	D1 F7			ACALL	SDP43		; Swap back
  494:	  015E	80 03			SJMP	GOC3		; And proceed
  495:	  0160			GOC2:
  496:	  0160	A3			INC	DPTR			; Skip 1
  497:	  0161	A3			INC	DPTR			; Skip 2
  498:	  0162	A3			INC	DPTR			; Skip 3
  499:	  0163			GOC3:
  500:	  0163	08			INC	R0				; Skip 4
  501:	  0164	B8 04 DE		CJNE	R0,#NBREAK,GOC1
  502:				; Restore the user registers & execute at user PC
  503:	  0167	90 F7 89		MOV	DPTR,#MRSAVE+6	; Point to memory save area
  504:	  016A	78 01			MOV	R0,#1			; Start at location1
  505:	  016C			GOC4:
  506:	  016C	E0			MOVX	A,@DPTR		; Get value
  507:	  016D	F6			MOV	@R0,A			; Save in memory
  508:	  016E	A3			INC	DPTR			; Advance to next
  509:	  016F	08			INC	R0				; Advance pointer
  510:	  0170	B8 20 F9		CJNE	R0,#MSSIZE,GOC4	; Do them all
  511:				; Restore users STACK pointer
  512:	  0173	90 F7 82		MOV	DPTR,#SPSAVE	; Point to SP save area
  513:	  0176	E0			MOVX	A,@DPTR		; Restore
  514:	  0177	F5 81			MOV	SP,A			; Set User SP
  515:				; Restore users program counter
  516:	  0179	90 F7 80		MOV	DPTR,#PCSAVE	; Point to save area
  517:	  017C	E0			MOVX	A,@DPTR		; Get HIGH pc
  518:	  017D	F5 F0			MOV	B,A				; Save for later
  519:	  017F	A3			INC	DPTR			; Advance
  520:	  0180	E0			MOVX	A,@DPTR		; Get LOW pc
  521:	  0181	C0 E0			PUSH	ACC			; Save LOW
  522:	  0183	C0 F0			PUSH	B			; Save HIGH
  523:				; Restore users registers
  524:	  0185	90 F7 83		MOV	DPTR,#MRSAVE	; Point to memory save area
  525:	  0188	E0			MOVX	A,@DPTR		; Restore 'A'
  526:	  0189	C0 E0			PUSH	ACC
  527:	  018B	A3			INC	DPTR
  528:	  018C	E0			MOVX	A,@DPTR		; Restore 'B'
  529:	  018D	F5 F0			MOV	B,A
  530:	  018F	A3			INC	DPTR
  531:	  0190	E0			MOVX	A,@DPTR		; Restore PSW
  532:	  0191	F5 D0			MOV	PSW,A
  533:	  0193	A3			INC	DPTR
  534:	  0194	E0			MOVX	A,@DPTR		; Restore DP0H
  535:	  0195	C0 E0			PUSH	ACC
  536:	  0197	A3			INC	DPTR
  537:	  0198	E0			MOVX	A,@DPTR		; Restore DP0L
  538:	  0199	C0 E0			PUSH	ACC
  539:	  019B	A3			INC	DPTR
  540:	  019C	E0			MOVX	A,@DPTR		; Restore R0
  541:	  019D	F5 00			MOV	0,A				; Restore memory
  542:	  019F	D0 82			POP	DP0L				; Restore DP0L
  543:	  01A1	D0 83			POP	DP0H				; Restore DP0H
  544:	  01A3	D0 E0			POP	ACC				; Restore ACC
  545:	  01A5	22			RET					; Dispatch to user program
  546:				; Patch user program with breakpoint
  547:	  01A6			PATCHBP:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  548:	  01A6	E4			CLR	A				; Zero offset
  549:	  01A7	93			MOVC	A,@A+DPTR	; Get byte of code
  550:	  01A8	D1 F3			ACALL	WR43		; Write to table
  551:	  01AA	EF			MOV	A,R7			; LCALL Instruction
  552:				; ??? Write to code memory
  553:	  01AB	F0			MOVX	@DPTR,A	; Patch code
  554:	  01AC	A3			INC	DPTR			; Skip to next
  555:	  01AD	22			RET
  556:				;
  557:				; Single step one instruction
  558:				;
  559:	  01AE			STEP:
  560:	  01AE	BF 53 62		CJNE	R7,#'S',RDUMP	; No, try next
  561:	  01B1	90 F7 80		MOV	DPTR,#PCSAVE	; Point to saved PC
  562:	  01B4	E0			MOVX	A,@DPTR		; Get HIGH
  563:	  01B5	A3			INC	DPTR			; Advance
  564:	  01B6	FA			MOV	R2,A			; Save
  565:	  01B7	E0			MOVX	A,@DPTR		; Get LOW
  566:	  01B8	F9			MOV	R1,A			; Save
  567:	  01B9	B1 94			ACALL	DODISS		; Display on screen
  568:	  01BB	91 EA			ACALL	FLUSH		; Wait for TX complete
  569:				; Setup timer-1 for single step interrupt
  570:	  01BD	C2 8E			CLR	TCON.6			; Stop timer1
  571:	  01BF	E5 89			MOV	A,TMOD			; Get timer mode
  572:	  01C1	54 0F			ANL	A,#00001111b	; Zero timer1 mode
  573:	  01C3	45 10			ORL	A,00010000b	; Timer1 16 bit
  574:	  01C5	F5 89			MOV	TMOD,A			; Resave new timer mode
  575:	  01C7	75 8D FF		MOV	TH1,#0FFh		; -1
  576:	  01CA	75 8B FE		MOV	TL1,#0FEh		; -2
  577:	  01CD	C2 8F			CLR	TCON.7			; Clear timer1 int pend
  578:				; Restore the user register memory
  579:	  01CF	90 F7 89		MOV	DPTR,#MRSAVE+6	; Point to memory save area
  580:	  01D2	78 01			MOV	R0,#1			; Start at location1
  581:	  01D4			STEP1:
  582:	  01D4	E0			MOVX	A,@DPTR		; Get value
  583:	  01D5	F6			MOV	@R0,A			; Save in memory
  584:	  01D6	A3			INC	DPTR			; Advance to next
  585:	  01D7	08			INC	R0				; Advance pointer
  586:	  01D8	B8 20 F9		CJNE	R0,#MSSIZE,STEP1 ; Do them all
  587:				; Restore users STACK pointer
  588:	  01DB	90 F7 82		MOV	DPTR,#SPSAVE	; Point to SP save area
  589:	  01DE	E0			MOVX	A,@DPTR		; Restore
  590:	  01DF	F5 81			MOV	SP,A			; Set User SP
  591:				; Restore users program counter
  592:	  01E1	90 F7 80		MOV	DPTR,#PCSAVE	; Point to save area
  593:	  01E4	E0			MOVX	A,@DPTR		; Get HIGH pc
  594:	  01E5	F5 F0			MOV	B,A				; Save for later
  595:	  01E7	A3			INC	DPTR			; Advance
  596:	  01E8	E0			MOVX	A,@DPTR		; Get LOW pc
  597:	  01E9	C0 E0			PUSH	ACC			; Save LOW
  598:	  01EB	C0 F0			PUSH	B			; Save HIGH
  599:				; Restore users registers
  600:	  01ED	90 F7 83		MOV	DPTR,#MRSAVE	; Point to memory save area
  601:	  01F0	E0			MOVX	A,@DPTR		; Restore 'A'
  602:	  01F1	C0 E0			PUSH	ACC
  603:	  01F3	A3			INC	DPTR

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  604:	  01F4	E0			MOVX	A,@DPTR		; Restore 'B'
  605:	  01F5	F5 F0			MOV	B,A
  606:	  01F7	A3			INC	DPTR
  607:	  01F8	E0			MOVX	A,@DPTR		; Restore PSW
  608:	  01F9	F5 D0			MOV	PSW,A
  609:	  01FB	A3			INC	DPTR
  610:	  01FC	E0			MOVX	A,@DPTR		; Restore DP0H
  611:	  01FD	C0 E0			PUSH	ACC
  612:	  01FF	A3			INC	DPTR
  613:	  0200	E0			MOVX	A,@DPTR		; Restore DP0L
  614:	  0201	C0 E0			PUSH	ACC
  615:	  0203	A3			INC	DPTR
  616:	  0204	E0			MOVX	A,@DPTR		; Restore R0
  617:	  0205	F5 00			MOV	0,A				; Restore memory
  618:	  0207	D0 82			POP	DP0L				; Restore DP0L
  619:	  0209	D0 83			POP	DP0H				; Restore DP0H
  620:	  020B	D0 E0			POP	ACC				; Restore ACC
  621:				; Activate the timer
  622:	  020D	43 A8 88		ORL	IE,#10001000b	; Enable Timer1 interrupt
  623:	  0210	D2 8E			SETB	TCON.6		; Enable timer1
  624:	  0212	22			RET					; Execute user program
  625:				;
  626:				; Dump user registers
  627:				;
  628:	  0213			RDUMP:
  629:	  0213	BF 52 2F		CJNE	R7,#'R',CHREG	; No, try next
  630:	  0216	90 F7 85		MOV	DPTR,#MRSAVE+2	; Point to user PSW
  631:	  0219	E0			MOVX	A,@DPTR		; Get user PSW
  632:	  021A	FE			MOV	R6,A			; Save for later
  633:	  021B	90 09 31		MOV	DPTR,#RNTABLE	; Point to register names
  634:	  021E	78 00			MOV	R0,#0			; Zero offset
  635:				; Display next register from bank
  636:	  0220			RDUMP1:
  637:	  0220	91 4C			ACALL	WRSTR		; Output value
  638:	  0222	C0 83			PUSH	DP0H			; Save HIGH
  639:	  0224	C0 82			PUSH	DP0L			; Save LOW
  640:	  0226	75 83 F7		MOV	DP0H,#HIGH(PCSAVE)	; Point to memory buffer
  641:	  0229	74 80			MOV	A,#LOW(PCSAVE)		; Point to low
  642:	  022B	28			ADD	A,R0			; Include offset
  643:	  022C	08			INC	R0				; Advance offset
  644:	  022D	F5 82			MOV	DP0L,A			; Save low value
  645:	  022F	E0			MOVX	A,@DPTR		; Get value
  646:	  0230	D0 82			POP	DP0L				; Restore LOW
  647:	  0232	D0 83			POP	DP0H				; Restore HIGH
  648:	  0234	91 38			ACALL	WRHEX		; Output value
  649:				; Test for second line... = Registers
  650:	  0236	E4			CLR	A				; Zero offset
  651:	  0237	93			MOVC	A,@A+DPTR	; More data?
  652:	  0238	B4 0A 05		CJNE	A,#0Ah,RDUMP2	; Not special case
  653:	  023B	EE			MOV	A,R6			; Get user PSW
  654:	  023C	54 18			ANL	A,#00011000b	; Save only rbank
  655:	  023E	28			ADD	A,R0			; Offset to bank
  656:	  023F	F8			MOV	R0,A			; Resave
  657:	  0240			RDUMP2:
  658:	  0240	30 E7 DD		JNB	ACC.7,RDUMP1		; Yes, output
  659:	  0243	01 3C			AJMP	PROMPT		; Next command

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  660:				;
  661:				; Change user register
  662:				;
  663:	  0245			CHREG:
  664:	  0245	BF 43 53		CJNE	R7,#'C',FILL	; Change resgister?
  665:	  0248	91 C8			ACALL	RDCHR		; Get register name
  666:	  024A	FF			MOV	R7,A			; Save for later
  667:	  024B	91 7E			ACALL	WRCHR		; Echo it
  668:	  024D	91 7C			ACALL	WRSPC		; Output
  669:	  024F	90 F7 80		MOV	DPTR,#PCSAVE	; Point to table
  670:	  0252	BF 50 02		CJNE	R7,#'P',$+5	; PC?
  671:	  0255	80 21			SJMP	CHRE2		; Save two bytes
  672:	  0257	A3			INC	DPTR
  673:	  0258	A3			INC	DPTR
  674:	  0259	BF 53 02		CJNE	R7,#'S',$+5	; SP?
  675:	  025C	80 37			SJMP	CHRE1		; Save one byte
  676:	  025E	A3			INC	DPTR
  677:	  025F	BF 41 02		CJNE	R7,#'A',$+5	; ACC?
  678:	  0262	80 31			SJMP	CHRE1		; Save one byte
  679:	  0264	A3			INC	DPTR
  680:	  0265	BF 42 02		CJNE	R7,#'B',$+5	; B?
  681:	  0268	80 2B			SJMP	CHRE1		; Save one byte
  682:	  026A	A3			INC	DPTR
  683:	  026B	E0			MOVX	A,@DPTR		; Get PSW
  684:	  026C	54 18			ANL	A,#00011000b	; Save Register bits
  685:	  026E	FE			MOV	R6,A			; Save PSW
  686:	  026F	BF 57 02		CJNE	R7,#'W',$+5	; PSW?
  687:	  0272	80 21			SJMP	CHRE1		; Save one byte
  688:	  0274	A3			INC	DPTR
  689:	  0275	BF 44 0D		CJNE	R7,#'D',CHRE4	; DPTR?
  690:				; Write a 16 bit register value
  691:	  0278			CHRE2:
  692:	  0278	91 86			ACALL	RDWORD		; Get WORD
  693:	  027A	40 1D			JC	ERROR2			; Error
  694:	  027C	C5 F0			XCH	A,B				; Get High
  695:	  027E	F0			MOVX	@DPTR,A		; Write to memory
  696:	  027F	A3			INC	DPTR			; Advance
  697:	  0280	E5 F0			MOV	A,B				; Get second byte
  698:	  0282			CHRE3:
  699:	  0282	F0			MOVX	@DPTR,A		; Save
  700:	  0283	01 3C			AJMP	PROMPT
  701:				; Set R0-R7 in current register bank
  702:	  0285			CHRE4:
  703:	  0285	EF			MOV	A,R7			; Get char back
  704:	  0286	7B 30			MOV	R3,#'0'			; Low bound
  705:	  0288	7C 38			MOV	R4,#'7'+1		; High bound
  706:	  028A	B1 85			ACALL	COMP		; In range?
  707:	  028C	40 0B			JC	ERROR2			; No, report error
  708:	  028E	94 30			SUBB	A,#'0'		; Convert to binary
  709:	  0290	4E			ORL	A,R6			; Offset to bank
  710:	  0291	24 88			ADD	A,#LOW(MRSAVE+5)		; Point to registers
  711:	  0293	F5 82			MOV	DP0L,A			; Set up DP0L
  712:				; Write an 8 bit register value
  713:	  0295			CHRE1:
  714:	  0295	91 8C			ACALL	RDHEX		; Get BYTE
  715:	  0297	50 E9			JNC	CHRE3			; Ok to write

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  716:				; Not a recognized command
  717:	  0299			ERROR2:
  718:	  0299	01 94			AJMP	ERROR1		; Report error
  719:				;
  720:				; Fill memory
  721:				;
  722:	  029B			FILL:
  723:	  029B	BF 46 19		CJNE	R7,#'F',UNASS	; Fill?
  724:	  029E	91 0F			ACALL	RDADDR		; Get address
  725:	  02A0	91 1C			ACALL	RDRANGE		; Get range
  726:	  02A2	91 7C			ACALL	WRSPC		; Output space
  727:	  02A4	91 8C			ACALL	RDHEX		; Get byte value
  728:	  02A6	40 F1			JC	ERROR2			; Report error
  729:	  02A8	FF			MOV	R7,A			; Save data
  730:	  02A9			FILL1:
  731:	  02A9	EF			MOV	A,R7			; Get byte
  732:	  02AA	F0			MOVX	@DPTR,A		; Write to data
  733:	  02AB	A3			INC	DPTR			; Advance to next
  734:	  02AC	C3			CLR	C				; Insure no borrow
  735:	  02AD	ED			MOV	A,R5			; Get Low
  736:	  02AE	95 82			SUBB	A,DP0L		; Convert
  737:	  02B0	EE			MOV	A,R6			; Get high
  738:	  02B1	95 83			SUBB	A,DP0H		; Test it
  739:	  02B3	50 F4			JNC	FILL1			; More to Go
  740:	  02B5	01 3C			AJMP	PROMPT		; Next command
  741:				;
  742:				; Un-assemble memory
  743:				;
  744:	  02B7			UNASS:
  745:	  02B7	BF 55 15		CJNE	R7,#'U',BRKPT	; No, try next
  746:	  02BA	91 0F			ACALL	RDADDR		; Get address
  747:	  02BC	AA 83			MOV	R2,DP0H			; Set high byte
  748:	  02BE	A9 82			MOV	R1,DP0L			; Set low byte
  749:	  02C0	91 1C			ACALL	RDRANGE		; Get ending address
  750:	  02C2			UNASS1:
  751:	  02C2	91 55			ACALL	WRLFCR		; New line
  752:	  02C4	B1 94			ACALL	DODISS		; Output text
  753:	  02C6	C3			CLR	C				; Insure no borrow
  754:	  02C7	ED			MOV	A,R5			; Get Low
  755:	  02C8	99			SUBB	A,R1		; Convert
  756:	  02C9	EE			MOV	A,R6			; Get high
  757:	  02CA	9A			SUBB	A,R2		; Test it
  758:	  02CB	50 F5			JNC	UNASS1			; More to Go
  759:	  02CD	01 3C			AJMP	PROMPT		; Back for more
  760:				;
  761:				; Examine/Change breakpoints
  762:				;
  763:	  02CF			BRKPT:
  764:	  02CF	BF 42 67		CJNE	R7,#'B',QUERY	; Breakpoint?
  765:	  02D2	91 C8			ACALL	RDCHR		; Get character
  766:	  02D4	B4 20 25		CJNE	A,#' ',BRKPT2	; Set breakpoint
  767:				; Display the breakpoints
  768:	  02D7	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to table
  769:	  02DA	7F 00			MOV	R7,#0			; Count
  770:	  02DC			BRKPT1:
  771:	  02DC	74 42			MOV	A,#'B'			; Get 'B'

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  772:	  02DE	91 7E			ACALL	WRCHR		; Output
  773:	  02E0	EF			MOV	A,R7			; Get number
  774:	  02E1	24 30			ADD	A,#'0'			; Convert to ASCII
  775:	  02E3	91 7E			ACALL	WRCHR		; Output
  776:	  02E5	74 3D			MOV	A,#'='			; Seperator
  777:	  02E7	91 7E			ACALL	WRCHR		; Output
  778:	  02E9	E0			MOVX	A,@DPTR		; Get address
  779:	  02EA	A3			INC	DPTR			; Skip to next
  780:	  02EB	91 38			ACALL	WRHEX		; Output
  781:	  02ED	E0			MOVX	A,@DPTR		; Get next address
  782:	  02EE	A3			INC	DPTR			; Skip to next
  783:	  02EF	91 38			ACALL	WRHEX		; Output
  784:	  02F1	A3			INC	DPTR			; Skip opcode
  785:	  02F2	A3			INC	DPTR			; ""
  786:	  02F3	A3			INC	DPTR			; ""
  787:	  02F4	91 7C			ACALL	WRSPC		; Space over
  788:	  02F6	0F			INC	R7				; Advance count
  789:	  02F7	BF 04 E2		CJNE	R7,#NBREAK,BRKPT1 ; Show them all
  790:	  02FA	01 3C			AJMP	PROMPT
  791:				; Set a breakpoint
  792:	  02FC			BRKPT2:
  793:	  02FC	7B 30			MOV	R3,#'0'			; Lower limit
  794:	  02FE	7C 34			MOV	R4,#'0'+NBREAK	; Upper limit
  795:	  0300	B1 85			ACALL	COMP		; In range?
  796:	  0302	40 95			JC	ERROR2			; Error
  797:	  0304	91 7E			ACALL	WRCHR		; Echo it
  798:	  0306	C3			CLR	C				; Zero carry
  799:	  0307	94 30			SUBB	A,#'0'		; Convert to binary
  800:	  0309	FE			MOV	R6,A			; Copy
  801:	  030A	91 7C			ACALL	WRSPC		; Space over
  802:	  030C	91 86			ACALL	RDWORD		; Get word
  803:	  030E	40 89			JC	ERROR2			; Report error
  804:	  0310	C0 E0			PUSH	ACC			; Save for later
  805:	  0312	C0 F0			PUSH	B			; Save for later
  806:	  0314	AA F0			MOV	R2,B			; Set HIGH
  807:	  0316	F9			MOV	R1,A			; Set LOW
  808:	  0317	F1 A2			ACALL	TESTBRK		; Check for conflicts
  809:	  0319	C9			XCH	A,R1			; Get value
  810:	  031A	24 02			ADD	A,#2			; Adjust for new break
  811:	  031C	C9			XCH	A,R1
  812:	  031D	CA			XCH	A,R2
  813:	  031E	34 00			ADDC	A,#0
  814:	  0320	CA			XCH	A,R2
  815:	  0321	F1 A2			ACALL	TESTBRK		; Check again
  816:	  0323	EE			MOV	A,R6			; Get
  817:	  0324	23			RL	A				; X2
  818:	  0325	23			RL	A				; X4
  819:	  0326	54 FC			ANL	A,#11111100b	; Mask wrap
  820:	  0328	2E			ADD	A,R6			; X5
  821:	  0329	24 A8			ADD	A,#LOW(BRKTAB)		; Point to breakpoint table
  822:	  032B	F5 82			MOV	DP0L,A			; Set LOW address
  823:	  032D	75 83 F7		MOV	DP0H,#HIGH(BRKTAB)	; Set HIGH address
  824:	  0330	D0 E0			POP	ACC				; Restore HIGH
  825:	  0332	F0			MOVX	@DPTR,A		; Set HIGH
  826:	  0333	A3			INC	DPTR			; Advance
  827:	  0334	D0 E0			POP	ACC				; Restore LOW

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  828:	  0336	F0			MOVX	@DPTR,A		; Set LOW
  829:	  0337	01 3C			AJMP	PROMPT
  830:				;
  831:				; Query SFR register
  832:				;
  833:	  0339			QUERY:
  834:	  0339	BF 51 21		CJNE	R7,#'Q',OUTPUT	; Query?
  835:	  033C	71 46			ACALL	GETSFR		; Get SFR address
  836:	  033E	78 E5			MOV	R0,#0E5h		; Indicate reading (MOV A,d)
  837:	  0340	71 6B			ACALL	DOXSUB		; Read the data
  838:	  0342	91 38			ACALL	WRHEX		; And display the value
  839:	  0344	01 3C			AJMP	PROMPT
  840:				; Get SFR address and display
  841:	  0346			GETSFR:
  842:	  0346	91 8C			ACALL	RDHEX		; Get address
  843:	  0348	F9			MOV	R1,A			; Save address
  844:	  0349	7C F7			MOV	R4,#HIGH(MBUFFER)	; Point to buffer
  845:	  034B	7B BC			MOV	R3,#LOW(MBUFFER)		; Point
  846:	  034D	D1 B3			ACALL	DIRECT		; Get value
  847:	  034F	E4			CLR	A				; Get zero
  848:	  0350	D1 F3			ACALL	WR43		; Zero terminate
  849:	  0352	91 7C			ACALL	WRSPC		; Space over
  850:	  0354	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
  851:	  0357	91 4C			ACALL	WRSTR		; Output
  852:	  0359	74 3D			MOV	A,#'='			; Indicator
  853:	  035B	81 7E			AJMP	WRCHR		; Output
  854:
  855:				;
  856:				; Write SFR register
  857:				;
  858:	  035D			OUTPUT:
  859:	  035D	BF 4F 1B		CJNE	R7,#'O',XLOOP	; Output request
  860:	  0360	71 46			ACALL	GETSFR		; Get address
  861:	  0362	91 8C			ACALL	RDHEX		; Get data
  862:	  0364	FA			MOV	R2,A			; Save data
  863:	  0365	78 F5			MOV	R0,#0F5h		; Indicate writing (MOV d,A)
  864:	  0367	71 6B			ACALL	DOXSUB		; Write the data
  865:	  0369	01 3C			AJMP	PROMPT
  866:				; ??? Build subroutine in code memory to Read/Write SFR
  867:				; ??? Entry: R0 = $E5/$F5 R1=Address R2=Data(write only)
  868:	  036B			DOXSUB:
  869:	  036B	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
  870:	  036E	E8			MOV	A,R0			; Get prefix
  871:	  036F	F0			MOVX	@DPTR,A		; Write it
  872:	  0370	A3			INC	DPTR			; Advance to next
  873:	  0371	E9			MOV	A,R1			; Get address
  874:	  0372	F0			MOVX	@DPTR,A		; Write it
  875:	  0373	A3			INC	DPTR			; Advance to next
  876:	  0374	74 22			MOV	A,#22h			; 'RET' instruction
  877:	  0376	F0			MOVX	@DPTR,A		; Write it
  878:	  0377	EA			MOV	A,R2			; Get value
  879:	  0378	02 F7 BC		LJMP	MBUFFER		; Execute subroutine
  880:				;
  881:				; LOOP commands
  882:				;
  883:	  037B			XLOOP:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

  884:	  037B	BF 58 33		CJNE	R7,#'X',WRITE	; No, try next
  885:	  037E	91 C8			ACALL	RDCHR		; Read the command charecter
  886:	  0380	FF			MOV	R7,A			; Save command for later
  887:	  0381	91 7E			ACALL	WRCHR		; Echo it
  888:	  0383	91 7C			ACALL	WRSPC		; Seperator
  889:	  0385	BF 52 0A		CJNE	R7,#'R',XLW
  890:	  0388	91 0F			ACALL	RDADDR		; Read address
  891:	  038A			XLR1:
  892:	  038A	E0			MOVX	A,@DPTR		; Read value
  893:	  038B	91 E1			ACALL	CHKCHR		; Check for character
  894:	  038D	B4 1B FA		CJNE	A,#1Bh,XLR1	; Do all
  895:	  0390	01 3C			AJMP	PROMPT
  896:	  0392			XLW:
  897:	  0392	BF 57 0E		CJNE	R7,#'W',XLC
  898:	  0395	91 0F			ACALL	RDADDR		; Get address
  899:	  0397	91 7C			ACALL	WRSPC		; Space over
  900:	  0399	91 8C			ACALL	RDHEX		; Get data
  901:	  039B			XLW1:
  902:	  039B	F0			MOVX	@DPTR,A		; Write value
  903:	  039C	91 E1			ACALL	CHKCHR		; Check for character
  904:	  039E	B4 1B FA		CJNE	A,#1Bh,XLW1	; Do all
  905:	  03A1	01 3C			AJMP	PROMPT
  906:	  03A3			XLC:
  907:	  03A3	BF 43 1D		CJNE	R7,#'C',ERROR3
  908:	  03A6	91 0F			ACALL	RDADDR		; Get address
  909:	  03A8			XLC1:
  910:	  03A8	E4			CLR	A				; Zero offset
  911:	  03A9	93			MOVC	A,@A+DPTR	; Read it
  912:	  03AA	91 E1			ACALL	CHKCHR		; Character?
  913:	  03AC	B4 1B F9		CJNE	A,#1Bh,XLC1	; Do all
  914:	  03AF	01 3C			AJMP	PROMPT
  915:				;
  916:				; Single write to memory
  917:				;
  918:	  03B1			WRITE:
  919:	  03B1	BF 57 11		CJNE	R7,#'W',help
  920:	  03B4	12 04 0F		LCALL	RDADDR		; Get a HEX value
  921:	  03B7	12 04 7C		LCALL	WRSPC
  922:	  03BA	12 04 8C		LCALL	RDHEX
  923:	  03BD	40 04			JC	error3
  924:	  03BF	F0			MOVX	@DPTR,A
  925:	  03C0	02 00 3C		LJMP	PROMPT
  926:	  03C3			ERROR3:
  927:	  03C3	01 94			AJMP	ERROR1
  928:				;
  929:				; Help request
  930:				;
  931:	  03C5	BF 3F FB	HELP:	CJNE	R7,#'?',ERROR3	; Help?
  932:	  03C8	90 0E 3D		MOV	DPTR,#HTEXT		; Point to help text
  933:	  03CB			HELP1:
  934:	  03CB	91 55			ACALL	WRLFCR		; New line
  935:	  03CD	7F 19			MOV	R7,#25			; Width of screen
  936:	  03CF			HELP2:
  937:	  03CF	E4			CLR	A				; Zero offset
  938:	  03D0	93			MOVC	A,@A+DPTR	; Get char
  939:	  03D1	A3			INC	DPTR			; Advance

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

  940:	  03D2	60 0F			JZ	HELP4			; No suffix
  941:	  03D4	B4 7C 11		CJNE	A,#'|',HELP5	; Normal char
  942:	  03D7			HELP3:
  943:	  03D7	91 7C			ACALL	WRSPC		; Output a space
  944:	  03D9	DF FC			DJNZ	R7,HELP3	; And proceed
  945:	  03DB	74 2D			MOV	A,#'-'			; Seperator
  946:	  03DD	91 7E			ACALL	WRCHR		; Output
  947:	  03DF	91 7C			ACALL	WRSPC		; Another space
  948:	  03E1	91 4C			ACALL	WRSTR		; Output rest of
  949:	  03E3			HELP4:
  950:	  03E3	93			MOVC	A,@A+DPTR	; Get char (A already zero)
  951:	  03E4	70 E5			JNZ	HELP1			; Do all lines
  952:	  03E6	01 3C			AJMP	PROMPT		; Next command
  953:	  03E8			HELP5:
  954:	  03E8	91 7E			ACALL	WRCHR		; Echo character
  955:	  03EA	1F			DEC	R7				; Reduce count
  956:	  03EB	80 E2			SJMP	HELP2		; Handle next
  957:	  03ED			WGO:
  958:	  03ED	02 03 B1		LJMP	WRITE
  959:				;
  960:				; Get PC value... SP = current
  961:				;
  962:	  03F0			GETPC:
  963:	  03F0	91 86			ACALL	RDWORD		; Get value
  964:	  03F2	40 0B			JC	GETP1			; Its OK
  965:	  03F4	90 F7 80		MOV	DPTR,#PCSAVE	; Get value
  966:	  03F7	C5 F0			XCH	A,B				; A = high
  967:	  03F9	F0			MOVX	@DPTR,A		; Write HIGH
  968:	  03FA	A3			INC	DPTR			; Advance
  969:	  03FB	E5 F0			MOV	A,B				; Get LOW
  970:	  03FD	F0			MOVX	@DPTR,A		; Set it
  971:	  03FE	22			RET
  972:	  03FF			GETP1:
  973:	  03FF	70 C2			JNZ	ERROR3			; Not space
  974:	  0401	90 08 48		MOV	DPTR,#M_PC		; Point to '->' message
  975:	  0404	91 4C			ACALL	WRSTR		; Output
  976:	  0406	90 F7 80		MOV	DPTR,#PCSAVE	; Point to it
  977:	  0409	91 0B			ACALL	GETP2		; Output first byte
  978:	  040B			GETP2:
  979:	  040B	E0			MOVX	A,@DPTR		; Get value
  980:	  040C	A3			INC	DPTR			; Advance
  981:	  040D	81 38			AJMP	WRHEX		; And proceed
  982:				;
  983:				; Read an address, abort on error
  984:				;
  985:	  040F			RDADDR:
  986:	  040F	91 8C			ACALL	RDHEX		; Read high byte
  987:	  0411	40 B0			JC	ERROR3			; Report error
  988:	  0413	F5 83			MOV	DP0H,A			; Set DP0H
  989:	  0415	91 8C			ACALL	RDHEX		; Read low byte
  990:	  0417	40 AA			JC	ERROR3			; Report error
  991:	  0419	F5 82			MOV	DP0L,A			; Set DP0L
  992:	  041B	22			RET
  993:				;
  994:				; Read closing portion of range
  995:				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

  996:	  041C			RDRANGE:
  997:	  041C	74 2C			MOV	A,#','			; Seperator
  998:	  041E	91 7E			ACALL	WRCHR		; Output
  999:	  0420	91 86			ACALL	RDWORD		; Get byte
 1000:	  0422	FD			MOV	R5,A			; Save LOW
 1001:	  0423	AE F0			MOV	R6,B			; Save HIGH
 1002:	  0425	50 5E			JNC	RET1			; Its OK
 1003:	  0427	70 9A			JNZ	ERROR3			; Report error
 1004:	  0429	74 FF			MOV	A,#0FFh			; Get FF
 1005:	  042B	FD			MOV	R5,A			; Assume END
 1006:	  042C	FE			MOV	R6,A			; Assume END
 1007:	  042D	91 38			ACALL	WRHEX		; Output
 1008:	  042F	ED			MOV	A,R5			; Get FF back
 1009:	  0430	80 06			SJMP	WRHEX		; Output
 1010:				;
 1011:				; Write the value of DPTR in hex
 1012:				;
 1013:	  0432			WRDPTR:
 1014:	  0432	E5 83			MOV	A,DP0H			; Get high
 1015:	  0434	91 38			ACALL	WRHEX		; Output if
 1016:	  0436	E5 82			MOV	A,DP0L			; Get low
 1017:				;
 1018:				; Write byte in A to the serial port in HEX
 1019:				;
 1020:	  0438			WRHEX:
 1021:	  0438	C0 E0			PUSH	ACC			; Save value
 1022:	  043A	C4			SWAP	A			; Get high nibble
 1023:	  043B	91 3F			ACALL	WRHEX1		; Output it
 1024:	  043D	D0 E0			POP	ACC				; Get low nibble
 1025:	  043F			WRHEX1:
 1026:	  043F	54 0F			ANL	A,#00001111b	; Use low digit only
 1027:	  0441	24 30			ADD	A,#'0'			; Convert to ASCII
 1028:	  0443	B4 3A 00		CJNE	A,#'0'+10,$+3	; Non-Destructive compare
 1029:	  0446	40 36			JC	WRCHR			; A = 0-9
 1030:	  0448	24 07			ADD	A,#7			; Convert HEX digits
 1031:	  044A	80 32			SJMP	WRCHR		; And write the character
 1032:				;
 1033:				; Write the string (DPTR) to the serial port
 1034:				;
 1035:	  044C			WRSTR:
 1036:	  044C	E4			CLR	A				; Zero offset
 1037:	  044D	93			MOVC	A,@A+DPTR	; Get character (From ROM)
 1038:	  044E	A3			INC	DPTR			; Advance to next
 1039:	  044F	60 34			JZ	RET1			; End of string
 1040:	  0451	91 7E			ACALL	WRCHR		; Write it out
 1041:	  0453	80 F7			SJMP	WRSTR		; And go again
 1042:				;
 1043:				; Write a newline (LFCR) to the serial port
 1044:				;
 1045:	  0455			WRLFCR:
 1046:	  0455	91 E1			ACALL	CHKCHR		; Any characters received?
 1047:	  0457	B4 1B 02		CJNE	A,#1Bh,WRLFCR1	; Escape?
 1048:	  045A	01 3C			AJMP	PROMPT		; Yes, abort command
 1049:	  045C			WRLFCR1:
 1050:	  045C	B4 20 0A		CJNE	A,#' ',WRLFCR2	; Halt output
 1051:	  045F	E5 7F			MOV	A,OUTFLAG		; Get output flag

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1052:	  0461	20 E7 10		JB	ACC.7,WRLFCR4		; Already set
 1053:	  0464	43 7F 80		ORL	OUTFLAG,#80h	; Set flag
 1054:	  0467	80 EC			SJMP	WRLFCR		; And proceed
 1055:	  0469			WRLFCR2:
 1056:	  0469	B4 0D 03		CJNE	A,#0Dh,WRLFCR3	; No, wait for it
 1057:	  046C	53 7F 7F		ANL	OUTFLAG,#7Fh	; Clear flag
 1058:	  046F			WRLFCR3:
 1059:	  046F	E5 7F			MOV	A,OUTFLAG		; Get output flag
 1060:	  0471	20 E7 E1		JB	ACC.7,WRLFCR		; Inhibited
 1061:	  0474			WRLFCR4:
 1062:	  0474	74 0A			MOV	A,#'J'-40h		; Get LINE-FEED
 1063:	  0476	91 7E			ACALL	WRCHR		; Output it
 1064:	  0478	74 0D			MOV	A,#'M'-40h		; Get CARRIAGE RETURN
 1065:	  047A	80 02			SJMP	WRCHR		; And output it
 1066:				;
 1067:				; Write a space to the serial port
 1068:				;
 1069:	  047C			WRSPC:
 1070:	  047C	74 20			MOV	A,#' '			; Get a space
 1071:				;
 1072:				; Write a character to the serial port
 1073:				;
 1074:	  047E			WRCHR:
 1075:	  047E	30 99 FD		JNB	SCON.1,$		; Wait for the bit
 1076:	  0481	C2 99			CLR	SCON.1			; Indicte we are sending
 1077:	  0483	F5 99			MOV	SBUF,A			; Write out char
 1078:	  0485			RET1:
 1079:	  0485	22			RET
 1080:				;
 1081:				; Read a word into B:A from the serial port
 1082:				;
 1083:	  0486			RDWORD:
 1084:	  0486	91 8C			ACALL	RDHEX		; Get a byte
 1085:	  0488	40 FB			JC	RET1			; Error, exit
 1086:	  048A	F5 F0			MOV	B,A				; Save high byte
 1087:				;
 1088:				; Read a byte from the serial port
 1089:				;
 1090:	  048C			RDHEX:
 1091:	  048C	91 98			ACALL	RDNIB		; Read a nibble
 1092:	  048E	40 F5			JC	RET1			; Error, exit
 1093:	  0490	C4			SWAP	A			; Get in high nibble
 1094:	  0491	FF			MOV	R7,A			; Save for later
 1095:	  0492	91 98			ACALL	RDNIB		; Read next nibble
 1096:	  0494	40 EF			JC	RET1			; Error, exit
 1097:	  0496	4F			ORL	A,R7			; Include high nibble
 1098:	  0497	22			RET
 1099:				;
 1100:				; Read a nibble in HEX from the serial port
 1101:				;
 1102:	  0498			RDNIB:
 1103:	  0498	91 C8			ACALL	RDCHR		; Get character
 1104:				; Handle numeric digits '0'-'9'
 1105:	  049A	7B 30			MOV	R3,#'0'			; Lower bound
 1106:	  049C	7C 3A			MOV	R4,#'9'+1		; Higher bound
 1107:	  049E	B1 85			ACALL	COMP		; Do the compare

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1108:	  04A0	40 05			JC	RDNIB1			; Failed
 1109:	  04A2	91 7E			ACALL	WRCHR		; Echo it
 1110:	  04A4	94 30			SUBB	A,#'0'		; Convert
 1111:	  04A6	22			RET
 1112:				; Handle HEX digits 'A'-'F'
 1113:	  04A7			RDNIB1:
 1114:	  04A7	7B 41			MOV	R3,#'A'			; Lower bound
 1115:	  04A9	7C 47			MOV	R4,#'F'+1		; Higher bound
 1116:	  04AB	B1 85			ACALL	COMP		; Do the compare
 1117:	  04AD	40 05			JC	RDNIB2			; Report error
 1118:	  04AF	91 7E			ACALL	WRCHR		; Echo the character
 1119:	  04B1	94 37			SUBB	A,#'0'+7	; Convert
 1120:	  04B3	22			RET
 1121:				; Not valid, return with ERROR only if SPACE or CR
 1122:	  04B4			RDNIB2:
 1123:	  04B4	B4 20 03		CJNE	A,#' ',RDNIB3	; Not space, continue
 1124:	  04B7	E4			CLR	A				; Zero = space
 1125:	  04B8	D3			SETB	C			; Indicate special condtion
 1126:	  04B9	22			RET
 1127:	  04BA			RDNIB3:
 1128:	  04BA	B4 08 04		CJNE	A,#08h,RDNIB4	; Not BS, continue
 1129:	  04BD	74 01			MOV	A,#1			; One = Backspace
 1130:	  04BF	D3			SETB	C			; Indicate special condition
 1131:	  04C0	22			RET
 1132:	  04C1			RDNIB4:
 1133:	  04C1	B4 0D D4		CJNE	A,#0Dh,RDNIB	; Not CR, continue
 1134:	  04C4	74 02			MOV	A,#2			; Two = Carriage return
 1135:	  04C6			RDNIB5:
 1136:	  04C6	D3			SETB	C			; Indicate special condition
 1137:	  04C7	22			RET
 1138:				;
 1139:				; Read a character from the serial port
 1140:				;
 1141:	  04C8			RDCHR:
 1142:	  04C8	30 98 FD		JNB	SCON.0,$		; Wait for the bit
 1143:	  04CB	C2 98			CLR	SCON.0			; Indicate we receved it
 1144:	  04CD	E5 99			MOV	A,SBUF			; Read the data
 1145:				; Convert the data to upper case
 1146:	  04CF	C0 E0			PUSH	ACC			; Save original
 1147:	  04D1	24 9F			ADD	A,#-'a'			; First test
 1148:	  04D3	50 09			JNC	RDCHR1			; < 'a', leave alone
 1149:	  04D5	94 19			SUBB	A,#25		; Second test
 1150:	  04D7	50 05			JNC	RDCHR1			; > 'z', leave alone
 1151:	  04D9	D0 E0			POP	ACC				; Restore char
 1152:	  04DB	94 1F			SUBB	A,#1Fh		; Convert to UPPER
 1153:	  04DD	22			RET
 1154:	  04DE			RDCHR1:
 1155:	  04DE	D0 E0			POP	ACC				; Restore
 1156:	  04E0	22			RET
 1157:				;
 1158:				; Check for a character received
 1159:				;
 1160:	  04E1			CHKCHR:
 1161:	  04E1	E4			CLR	A				; Assume zero
 1162:	  04E2	30 98 04		JNB	SCON.0,CHKC1	; No data, return
 1163:	  04E5	C2 98			CLR	SCON.0			; Indicate we received it

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1164:	  04E7	E5 99			MOV	A,SBUF			; Read the data
 1165:	  04E9			CHKC1:
 1166:	  04E9	22			RET
 1167:				;
 1168:				; Flush the serial port (Wait till all chars received/sent)
 1169:				;
 1170:	  04EA			FLUSH:
 1171:	  04EA	7F 00			MOV	R7,#0			; Delay count
 1172:	  04EC			FLUSH1:
 1173:	  04EC	91 E1			ACALL	CHKCHR		; Any data?
 1174:	  04EE	70 FA			JNZ	FLUSH			; Reset the timer
 1175:	  04F0	30 99 F7		JNB	SCON.1,FLUSH	; Wait for TX complete
 1176:	  04F3	DF F7			DJNZ	R7,FLUSH1	; Wait for expiry
 1177:	  04F5	22			RET
 1178:				;
 1179:				; Read a byte without echo
 1180:				;
 1181:	  04F6			DLBYTE:
 1182:	  04F6	91 FE			ACALL	DLNIB		; Get first digit
 1183:	  04F8	C4			SWAP	A			; Get in high digit
 1184:	  04F9	FD			MOV	R5,A			; Save for later
 1185:	  04FA	91 FE			ACALL	DLNIB		; Get low digit
 1186:	  04FC	4D			ORL	A,R5			; Include high
 1187:	  04FD	22			RET
 1188:				;
 1189:				; Read a nibble without echo
 1190:				;
 1191:	  04FE			DLNIB:
 1192:	  04FE	91 C8			ACALL	RDCHR		; Read a character
 1193:	  0500	7B 30			MOV	R3,#'0'			; Lower bound
 1194:	  0502	7C 3A			MOV	R4,#'9'+1		; Upper bound
 1195:	  0504	B1 85			ACALL	COMP		; Perform the compare
 1196:	  0506	50 0A			JNC	DLNIB1			; Invalid
 1197:	  0508	7B 41			MOV	R3,#'A'			; Lower bound
 1198:	  050A	7C 47			MOV	R4,#'F'+1		; Upper bound
 1199:	  050C	B1 85			ACALL	COMP		; Perform the compare
 1200:	  050E	40 18			JC	DLERR			; Report error
 1201:	  0510	94 07			SUBB	A,#7		; Convert HEX
 1202:	  0512			DLNIB1:
 1203:	  0512	94 30			SUBB	A,#'0'		; Convert NUMBERS
 1204:	  0514	22			RET
 1205:				;
 1206:				; Read a MHX record from the serial port
 1207:				;
 1208:	  0515			DLOAD:
 1209:	  0515	91 C8			ACALL	RDCHR		; Read a character
 1210:	  0517	B4 53 3D		CJNE	A,#'S',DLINT	; Try intel record
 1211:				; Download a MOTOROLA HEX format record
 1212:	  051A			DLMOT:
 1213:	  051A	91 C8			ACALL	RDCHR		; Read another char
 1214:	  051C	C3			CLR	C				; No borrow in
 1215:	  051D	94 30			SUBB	A,#'0'		; Header record
 1216:	  051F	60 F4			JZ	DLOAD			; Yes, ignore it
 1217:	  0521	14			DEC	A				; Type 1 (data record)
 1218:	  0522	60 0B			JZ	DLMOT1			; Yes, grab it
 1219:	  0524	94 08			SUBB	A,#8		; Type 9 (EOF)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1220:	  0526			DLEOF:
 1221:	  0526	60 9E			JZ	RDNIB5			; Yes end of file (Set C)
 1222:				; Error in download
 1223:	  0528			DLERR:
 1224:	  0528	90 08 4B		MOV	DPTR,#M_LOAD	; Point to '?Load error' message
 1225:	  052B	91 4C			ACALL	WRSTR		; Output
 1226:	  052D	01 3A			AJMP	FPROMPT		; And continue
 1227:	  052F			DLMOT1:
 1228:	  052F	91 F6			ACALL	DLBYTE		; Get length
 1229:	  0531	FE			MOV	R6,A			; Start checksum
 1230:	  0532	24 FD			ADD	A,#-3			; Convert to actual length
 1231:	  0534	FF			MOV	R7,A			; Save length
 1232:	  0535	29			ADD	A,R1			; Add to LOW length
 1233:	  0536	F9			MOV	R1,A			; Save
 1234:	  0537	EA			MOV	A,R2			; Get HIGH length
 1235:	  0538	34 00			ADDC	A,#0		; Adjust for carry
 1236:	  053A	FA			MOV	R2,A			; Resave
 1237:	  053B	91 F6			ACALL	DLBYTE		; Get byte of address
 1238:	  053D	F5 83			MOV	DP0H,A			; Save high
 1239:	  053F	2E			ADD	A,R6			; Include in checksum
 1240:	  0540	FE			MOV	R6,A			; Resave checksum
 1241:	  0541	91 F6			ACALL	DLBYTE		; Get low byte of address
 1242:	  0543	F5 82			MOV	DP0L,A			; Save low
 1243:	  0545	2E			ADD	A,R6			; Include in checksum
 1244:	  0546	FE			MOV	R6,A			; And re-save
 1245:	  0547			DLMOT2:
 1246:	  0547	91 F6			ACALL	DLBYTE		; Get a byte
 1247:				; ??? Write to code memory
 1248:	  0549	F0			MOVX	@DPTR,A	; Write to memory
 1249:	  054A	A3			INC	DPTR			; Advance to next
 1250:	  054B	2E			ADD	A,R6			; Include in checksum
 1251:	  054C	FE			MOV	R6,A			; And re-save
 1252:	  054D	DF F8			DJNZ	R7,DLMOT2	; Do whole record
 1253:	  054F	91 F6			ACALL	DLBYTE		; Get checksum
 1254:	  0551	2E			ADD	A,R6			; Include calculated value
 1255:	  0552	04			INC	A				; Convert
 1256:	  0553	70 D3			JNZ	DLERR			; Failed!
 1257:	  0555	C3			CLR	C				; Indicte RX OK
 1258:	  0556	22			RET
 1259:				; Download an INTEL format record
 1260:	  0557			DLINT:
 1261:	  0557	B4 3A BB		CJNE	A,#':',DLOAD	; Not INTEL, ignore
 1262:	  055A	91 F6			ACALL	DLBYTE		; Get count
 1263:	  055C	FE			MOV	R6,A			; Start checksum
 1264:	  055D	FF			MOV	R7,A			; Record length
 1265:	  055E	60 C6			JZ	DLEOF			; End of file
 1266:	  0560	29			ADD	A,R1			; Add LOW length
 1267:	  0561	F9			MOV	R1,A			; Resave
 1268:	  0562	EA			MOV	A,R2			; Get HIGH length
 1269:	  0563	34 00			ADDC	A,#0		; Adjust for high
 1270:	  0565	FA			MOV	R2,A			; Resave
 1271:	  0566	91 F6			ACALL	DLBYTE		; Get HIGH address
 1272:	  0568	F5 83			MOV	DP0H,A			; Set up DPTR
 1273:	  056A	2E			ADD	A,R6			; Include in checksum
 1274:	  056B	FE			MOV	R6,A			; Resave
 1275:	  056C	91 F6			ACALL	DLBYTE		; Get LOW address

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1276:	  056E	F5 82			MOV	DP0L,A			; Set up DPTR
 1277:	  0570	2E			ADD	A,R6			; Include checksum
 1278:	  0571	FE			MOV	R6,A			; Resave
 1279:	  0572	91 F6			ACALL	DLBYTE		; Read RECORD type
 1280:	  0574	2E			ADD	A,R6			; Incldue in checksum
 1281:	  0575	FE			MOV	R6,A			; Resave
 1282:	  0576			DLINT1:
 1283:	  0576	91 F6			ACALL	DLBYTE		; Read a data byte
 1284:				; ??? Write to code memory
 1285:	  0578	F0			MOVX	@DPTR,A	; Write to memory
 1286:	  0579	A3			INC	DPTR			; Advance to next
 1287:	  057A	2E			ADD	A,R6			; Include in checksum
 1288:	  057B	FE			MOV	R6,A			; Resave
 1289:	  057C	DF F8			DJNZ	R7,DLINT1	; Do them all
 1290:	  057E	91 F6			ACALL	DLBYTE		; Get record checksum
 1291:	  0580	2E			ADD	A,R6			; Include in checksum
 1292:	  0581	70 A5			JNZ	DLERR			; Report error
 1293:	  0583	C3			CLR	C				; Indicate success
 1294:	  0584	22			RET
 1295:				;
 1296:				; Compare the ACCUMULATOR with R3&R4
 1297:				; Sets the C flag if ACC <R3 or >=R4
 1298:				;
 1299:	  0585			COMP:
 1300:	  0585	C0 E0			PUSH	ACC			; Save ACC
 1301:	  0587	C3			CLR	C				; Clear carry
 1302:	  0588	9B			SUBB	A,R3		; Test
 1303:	  0589	40 06			JC	COMP1			; < R3, report no
 1304:	  058B	D0 E0			POP	ACC				; Restore A
 1305:	  058D	C0 E0			PUSH	ACC			; And re-stack
 1306:	  058F	9C			SUBB	A,R4		; Test
 1307:	  0590	B3			CPL	C				; C = A >= R4
 1308:	  0591			COMP1:
 1309:	  0591	D0 E0			POP	ACC				; Restore A
 1310:	  0593			RET2:
 1311:	  0593	22			RET
 1312:				;
 1313:				; Disassemble to screen
 1314:				;
 1315:	  0594			DODISS:
 1316:	  0594	7C F7			MOV	R4,#HIGH(MBUFFER)	; Get HIGH output address
 1317:	  0596	7B BC			MOV	R3,#LOW(MBUFFER)		; Get LOW output address
 1318:	  0598	C0 02			PUSH	2			; Save HIGH output
 1319:	  059A	C0 01			PUSH	1			; Save LOW output
 1320:	  059C	B1 C9			ACALL	DISASS		; Do dis-assembly
 1321:	  059E	D0 82			POP	DP0L				; Get LOW
 1322:	  05A0	D0 83			POP	DP0H				; Get HIGH
 1323:	  05A2	91 32			ACALL	WRDPTR		; Output address
 1324:	  05A4	7F 05			MOV	R7,#5			; Max # spaces
 1325:	  05A6			DODISS1:
 1326:	  05A6	91 7C			ACALL	WRSPC		; Space over
 1327:	  05A8	E4			CLR	A				; Zero OFFSET
 1328:	  05A9	93			MOVC	A,@A+DPTR	; Get value
 1329:	  05AA	A3			INC	DPTR			; Advance
 1330:	  05AB	91 38			ACALL	WRHEX		; Output
 1331:	  05AD	1F			DEC	R7				; Reduce count

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1332:	  05AE	E9			MOV	A,R1			; Get LOW
 1333:	  05AF	B5 82 F4		CJNE	A,DP0L,DODISS1	; More...
 1334:	  05B2	EA			MOV	A,R2			; Get HIGH
 1335:	  05B3	B5 83 F0		CJNE	A,DP0H,DODISS1	; More...
 1336:	  05B6			DODISS2:
 1337:	  05B6	91 7C			ACALL	WRSPC		; Space
 1338:	  05B8	91 7C			ACALL	WRSPC		; Space
 1339:	  05BA	91 7C			ACALL	WRSPC		; Space
 1340:	  05BC	DF F8			DJNZ	R7,DODISS2	; Do them ALL
 1341:	  05BE	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to buffer
 1342:	  05C1			DODISS3:
 1343:	  05C1	E0			MOVX	A,@DPTR	; Get character
 1344:	  05C2	A3			INC	DPTR			; Advance
 1345:	  05C3	60 CE			JZ	RET2			; Exit
 1346:	  05C5	91 7E			ACALL	WRCHR		; Output char
 1347:	  05C7	80 F8			SJMP	DODISS3		; Continue
 1348:				;
 1349:				; Disassemble opcode
 1350:				; R2:1 = Input pointer, R4:3 = Output pointer R5:7 = Temp locs
 1351:	  05C9			DISASS:
 1352:	  05C9	C0 83			PUSH	DP0H			; Save DP0H
 1353:	  05CB	C0 82			PUSH	DP0L			; Save DP0L
 1354:	  05CD	C0 05			PUSH	5			; Save R5
 1355:	  05CF	C0 07			PUSH	7			; Save R7
 1356:	  05D1	F1 00			ACALL	LAR21Z		; Read opcode
 1357:	  05D3	90 09 7C		MOV	DPTR,#OTABLE	; Point to lookup table
 1358:	  05D6	FD			MOV	R5,A			; Save for later
 1359:				; Look for instruction in table
 1360:	  05D7			dis1:
 1361:	  05D7	E4			CLR	A				; Zero offset
 1362:	  05D8	93			MOVC	A,@A+DPTR	; Get value from table
 1363:	  05D9	5D			ANL	A,R5			; Mask for variables
 1364:	  05DA	F5 F0			MOV	B,A				; Save for compare
 1365:	  05DC	A3			INC	DPTR			; Advance to test
 1366:	  05DD	E4			CLR	A				; Zero offset
 1367:	  05DE	93			MOVC	A,@A+DPTR	; Get byte from table
 1368:	  05DF	A3			INC	DPTR			; Advance
 1369:	  05E0	B5 F0 0E		CJNE	A,B,dis2	; Not correct instruction
 1370:				; This is the instruction
 1371:	  05E3			dis3:
 1372:	  05E3	7F 06			MOV	R7,#6			; Counter
 1373:	  05E5			dis4:
 1374:	  05E5	E4			CLR	A				; Zero offset
 1375:	  05E6	93			MOVC	A,@A+DPTR	; Get byte to output
 1376:	  05E7	A3			INC	DPTR			; Advance to next
 1377:	  05E8	B4 20 0D		CJNE	A,#' ',dis5	; Not space, its OK
 1378:	  05EB			dis41:
 1379:	  05EB	D1 F3			ACALL	WR43		; Output to string
 1380:	  05ED	DF FC			DJNZ	R7,dis41	; Do them all
 1381:	  05EF	80 F4			SJMP	dis4		; next byte
 1382:				; Not it, try next
 1383:	  05F1			dis2:
 1384:	  05F1	E4			CLR	A				; Zero offset
 1385:	  05F2	93			MOVC	A,@A+DPTR	; Get byte
 1386:	  05F3	A3			INC	DPTR			; Advance
 1387:	  05F4	70 FB			JNZ	dis2			; No, keep looking

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1388:	  05F6	80 DF			SJMP	dis1		; Go again
 1389:				; Test for 'r'egister ID
 1390:	  05F8			dis5:
 1391:	  05F8	B4 72 0D		CJNE	A,#'r',dis6	; Register?
 1392:	  05FB	74 52			MOV	A,#'R'			; Stuff in 'R'
 1393:	  05FD	D1 F3			ACALL	WR43		; Output it
 1394:	  05FF	ED			MOV	A,R5			; Get opcode back
 1395:	  0600			dis51:
 1396:	  0600	54 07			ANL	A,#07h			; Save 'R' bits
 1397:	  0602	24 30			ADD	A,#'0'			; Convert to ASCII
 1398:	  0604	D1 F3			ACALL	WR43		; Write it
 1399:	  0606	80 DD			SJMP	dis4		; And proceed
 1400:				; Test for 'i'ndirect id
 1401:	  0608			dis6:
 1402:	  0608	B4 69 15		CJNE	A,#'i',dis7	; Indirect?
 1403:	  060B	74 5B			MOV	A,#'['			; Opening brace
 1404:	  060D	D1 F3			ACALL	WR43		; Output
 1405:	  060F	74 52			MOV	A,#'R'			; Register indicator
 1406:	  0611	D1 F3			ACALL	WR43		; Output
 1407:	  0613	ED			MOV	A,R5			; Get opcode
 1408:	  0614	54 01			ANL	A,#01h			; Save ID
 1409:	  0616	24 30			ADD	A,#'0'			; Convert to ASCII
 1410:	  0618	D1 F3			ACALL	WR43		; Output
 1411:	  061A	74 5D			MOV	A,#']'			; Closing brace
 1412:	  061C	D1 F3			ACALL	WR43		; Output
 1413:	  061E	80 C5			SJMP	dis4		; Save
 1414:				; Test for 'm'emory reference
 1415:	  0620			dis7:
 1416:	  0620	B4 6D 0A		CJNE	A,#'m',dis8	; Memory reference?
 1417:	  0623	74 23			MOV	A,#'#'			; Indicate immediiate
 1418:	  0625	D1 F3			ACALL	WR43		; Output
 1419:	  0627	F1 00			ACALL	LAR21Z		; Get value
 1420:	  0629	D1 DE			ACALL	WRHEXS		; Output in hex
 1421:	  062B	80 B8			SJMP	dis4		; And proceed
 1422:				; Test for 'x'tended address
 1423:	  062D			dis8:
 1424:	  062D	B4 78 0A		CJNE	A,#'x',dis9	; Xtended?
 1425:	  0630	F1 00			ACALL	LAR21Z		; Get value
 1426:	  0632	D1 DE			ACALL	WRHEXS		; Output in hex
 1427:	  0634	F1 00			ACALL	LAR21Z		; Get value
 1428:	  0636	D1 DE			ACALL	WRHEXS		; Output
 1429:	  0638	80 AB			SJMP	dis4		; And proceed
 1430:				; Test for 'j' relative jump address
 1431:	  063A			dis9:
 1432:	  063A	B4 6A 10		CJNE	A,#'j',dis10	; Jump address?
 1433:	  063D	F1 00			ACALL	LAR21Z		; Get value
 1434:	  063F	F1 1E			ACALL	CBW			; Sign extend
 1435:	  0641	29			ADD	A,R1			; Add LOW
 1436:	  0642	C5 F0			XCH	A,B				; B = low
 1437:	  0644	3A			ADDC	A,R2		; Add HIGH
 1438:	  0645			dis91:
 1439:	  0645	D1 DE			ACALL	WRHEXS		; Output HIGH
 1440:	  0647	E5 F0			MOV	A,B				; Get LOW
 1441:	  0649	D1 DE			ACALL	WRHEXS		; output
 1442:	  064B	80 98			SJMP	dis4		; And proceed
 1443:				; Test for 'a' absolute address

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1444:	  064D			dis10:
 1445:	  064D	B4 61 17		CJNE	A,#'a',dis11	; ABS address?
 1446:	  0650	F1 00			ACALL	LAR21Z		; Get value
 1447:	  0652	C0 E0			PUSH	ACC			; Save LOW
 1448:	  0654	EA			MOV	A,R2			; Get high address
 1449:	  0655	54 F8			ANL	A,#0F8h			; Save high bits
 1450:	  0657	F5 F0			MOV	B,A				; Save for later
 1451:	  0659	ED			MOV	A,R5			; Get opcode
 1452:	  065A	03			RR	A				; Shift
 1453:	  065B	03			RR	A				; To
 1454:	  065C	03			RR	A				; Get
 1455:	  065D	03			RR	A				; Insert
 1456:	  065E	03			RR	A				; Bits
 1457:	  065F	54 07			ANL	A,#00000111b	; Save only lower three
 1458:	  0661	45 F0			ORL	A,B				; Include extra bits
 1459:	  0663	D0 F0			POP	B				; Restore LOW
 1460:	  0665	80 DE			SJMP	dis91		; Display
 1461:				; Test for 'd' direct memory address
 1462:	  0667			dis11:
 1463:	  0667	B4 64 06		CJNE	A,#'d',dis12	; Direct memory address?
 1464:	  066A	F1 00			ACALL	LAR21Z		; Get address
 1465:	  066C			dis111:
 1466:	  066C	D1 B3			ACALL	DIRECT		; display direct address
 1467:	  066E			dis112:
 1468:	  066E	A1 E5			AJMP	dis4		; And proceed
 1469:				; Test for 'b' bit address
 1470:	  0670			dis12:
 1471:	  0670	B4 62 1A		CJNE	A,#'b',dis13	; No, try next
 1472:	  0673	F1 00			ACALL	LAR21Z		; Get value
 1473:	  0675	C0 E0			PUSH	ACC			; Save for later
 1474:	  0677	54 F8			ANL	A,#0F8h			; Remove bit position
 1475:	  0679	20 E7 07		JB	ACC.7,dis121		; Negative, its ok
 1476:	  067C	03			RR	A				; Over
 1477:	  067D	03			RR	A				; To low bit
 1478:	  067E	03			RR	A				; address range
 1479:	  067F	54 1F			ANL	A,#00011111b	; Mask bits
 1480:	  0681	24 20			ADD	A,#20h			; Convert
 1481:	  0683			dis121:
 1482:	  0683	D1 B3			ACALL	DIRECT		; Write address
 1483:	  0685	74 2E			MOV	A,#'.'			; Separator
 1484:	  0687	D1 F3			ACALL	WR43		; write it
 1485:	  0689	D0 E0			POP	ACC				; Restore
 1486:	  068B	C1 00			AJMP	dis51		; Write & return
 1487:				; Test for 'e' - special direct
 1488:	  068D			dis13:
 1489:	  068D	B4 65 09		CJNE	A,#'e',dis14	; Special direct?
 1490:	  0690	75 F0 00		MOV	B,#0			; High = 0
 1491:	  0693	74 01			MOV	A,#1			; Offset = 1
 1492:	  0695	F1 03			ACALL	LAR21		; Get value
 1493:	  0697	80 D3			SJMP	dis111		; And proceed
 1494:				; Test for 'f' - special direct
 1495:	  0699			dis14:
 1496:	  0699	B4 66 09		CJNE	A,#'f',dis15	; Special direct?
 1497:	  069C	74 FF			MOV	A,#-1			; Offset -1
 1498:	  069E	75 F0 FF		MOV	B,#-1			; Offset -1
 1499:	  06A1	F1 03			ACALL	LAR21		; Get data

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1500:	  06A3	80 C7			SJMP	dis111		; and prcoeed
 1501:				; Normal data, output to buffer
 1502:	  06A5			dis15:
 1503:	  06A5	D1 F3			ACALL	WR43		; Output
 1504:	  06A7	1F			DEC	R7				; Reduce count
 1505:	  06A8	70 C4			JNZ	dis112			; Go till end
 1506:	  06AA	D0 07			POP	7				; Restore R7
 1507:	  06AC	D0 05			POP	5				; Restore R5
 1508:	  06AE	D0 82			POP	DP0L				; Restore DP0L
 1509:	  06B0	D0 83			POP	DP0H				; Restore DP0H
 1510:	  06B2	22			RET
 1511:				;
 1512:				; Look up opcode in the direct memory access table
 1513:				; Write to R4:3+
 1514:				;
 1515:	  06B3			DIRECT:
 1516:	  06B3	F5 F0			MOV	B,A				; Save a copy
 1517:	  06B5	C0 83			PUSH	DP0H			; Save LOW
 1518:	  06B7	C0 82			PUSH	DP0L			; Save HIGH
 1519:	  06B9	90 0D D2		MOV	DPTR,#DTABLE	; Point to table
 1520:	  06BC			dir1:
 1521:	  06BC	E4			CLR	A				; Zero offset
 1522:	  06BD	93			MOVC	A,@A+DPTR	; Get value
 1523:	  06BE	A3			INC	DPTR			; Advance
 1524:	  06BF	60 17			JZ	dir4			; End of list
 1525:	  06C1	30 E7 F8		JNB	ACC.7,dir1		; Still in entry
 1526:	  06C4	B5 F0 F5		CJNE	A,B,dir1	; This is not it
 1527:	  06C7			dir2:
 1528:	  06C7	E4			CLR	A				; Zero offset
 1529:	  06C8	93			MOVC	A,@A+DPTR	; Get data
 1530:	  06C9	A3			INC	DPTR			; Advance to next
 1531:	  06CA	60 07			JZ	dir3			; End of list
 1532:	  06CC	20 E7 04		JB	ACC.7,dir3		; End of list
 1533:	  06CF	D1 F3			ACALL	WR43		; Write to buffer
 1534:	  06D1	80 F4			SJMP	dir2		; Do them all
 1535:	  06D3			dir3:
 1536:	  06D3	D0 82			POP	DP0L				; Restore LOW
 1537:	  06D5	D0 83			POP	DP0H				; Restore HIGH
 1538:	  06D7	22			RET
 1539:	  06D8			dir4:
 1540:	  06D8	D0 82			POP	DP0L				; Restore LOW
 1541:	  06DA	D0 83			POP	DP0H				; Restore HIGH
 1542:	  06DC	E5 F0			MOV	A,B				; Get value back
 1543:				;
 1544:				; Write byte in AL to [R4:3+] in hex
 1545:				;
 1546:	  06DE			WRHEXS:
 1547:	  06DE	C0 E0			PUSH	ACC			; Save for later
 1548:	  06E0	03			RR	A				; Shift high nibble
 1549:	  06E1	03			RR	A				; Into low nibble
 1550:	  06E2	03			RR	A				; For output
 1551:	  06E3	03			RR	A				; first
 1552:	  06E4	D1 E8			ACALL	WRHEXS1		; Output it
 1553:	  06E6	D0 E0			POP	ACC				; Restore LOW
 1554:	  06E8			WRHEXS1:
 1555:	  06E8	54 0F			ANL	A,#00001111b	; Save only high digit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1556:	  06EA	24 30			ADD	A,#'0'			; Convert to ASCII
 1557:	  06EC	B4 3A 00		CJNE	A,#'0'+10,$+3	; In range?
 1558:	  06EF	40 02			JC	WR43			; Yes, its OK
 1559:	  06F1	24 07			ADD	A,#7			; Convert alphas
 1560:				; Write byte to [R4:3+]
 1561:	  06F3			WR43:
 1562:	  06F3	D1 F7			ACALL	SDP43		; Swap into DPTR
 1563:	  06F5	F0			MOVX	@DPTR,A		; Write data
 1564:	  06F6	A3			INC	DPTR			; Advance
 1565:	  06F7			SDP43:
 1566:	  06F7	CC			XCH	A,R4			; Get R4
 1567:	  06F8	C5 83			XCH	A,DP0H			; Swap with DP0H
 1568:	  06FA	CC			XCH	A,R4			; Replace R4
 1569:	  06FB	CB			XCH	A,R3			; Get R3
 1570:	  06FC	C5 82			XCH	A,DP0L			; Swap with DP0H
 1571:	  06FE	CB			XCH	A,R3			; Replace R3
 1572:	  06FF	22			RET
 1573:				; Load 0[R2:3+]
 1574:	  0700			LAR21Z:
 1575:	  0700	E4			CLR	A				; Zero LOW
 1576:	  0701	F5 F0			MOV	B,A				; Zero HIGH
 1577:				; Load BA[R2:3+]
 1578:	  0703			LAR21:
 1579:	  0703	C0 83			PUSH	DP0H			; Save DP0H
 1580:	  0705	C0 82			PUSH	DP0L			; Save DP0L
 1581:	  0707	29			ADD	A,R1			; Get low value
 1582:	  0708	F5 82			MOV	DP0L,A			; Resave
 1583:	  070A	EA			MOV	A,R2			; Get high
 1584:	  070B	35 F0			ADDC	A,B			; Adjust for overflow
 1585:	  070D	F5 83			MOV	DP0H,A			; Resave
 1586:	  070F	E4			CLR	A				; Zero offset
 1587:	  0710	93			MOVC	A,@A+DPTR	; Load value
 1588:	  0711	D0 82			POP	DP0L				; Restore DP0L
 1589:	  0713	D0 83			POP	DP0H				; Restore DP0H
 1590:	  0715			INC23:
 1591:	  0715	C9			XCH	A,R1			; Get LOW
 1592:	  0716	24 01			ADD	A,#1			; Advance
 1593:	  0718	C9			XCH	A,R1			; Replace
 1594:	  0719	CA			XCH	A,R2			; Get HIGH
 1595:	  071A	34 00			ADDC	A,#0		; Cary high
 1596:	  071C	CA			XCH	A,R2			; Replace
 1597:	  071D	22			RET
 1598:				; Convert a byte to word
 1599:	  071E			CBW:
 1600:	  071E	75 F0 00		MOV	B,#0			; Assume zero
 1601:	  0721	30 E7 02		JNB	ACC.7,$+5			; Its OK
 1602:	  0724	15 F0			DEC	B				; Convert to -1
 1603:	  0726	22			RET
 1604:				;
 1605:				; Read user internal memory @R0
 1606:				;
 1607:	  0727			RDINTM:
 1608:	  0727	B8 20 00		CJNE	R0,#MSSIZE,$+3	; Non-destruction compare
 1609:	  072A	40 02			JC	RDINTM1			; Special case
 1610:	  072C	E6			MOV	A,@R0			; Read it
 1611:	  072D	22			RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1612:	  072E			RDINTM1:
 1613:	  072E	C0 83			PUSH	DP0H			; Save Data pointer
 1614:	  0730	C0 82			PUSH	DP0L
 1615:	  0732	75 83 F7		MOV	DP0H,#HIGH(MRSAVE)	; Point to high address
 1616:	  0735	74 88			MOV	A,#LOW(MRSAVE)+5		; Set up low address
 1617:	  0737	28			ADD	A,R0			; Offset to desired location
 1618:	  0738	F5 82			MOV	DP0L,A			; Set up low
 1619:	  073A	E0			MOVX	A,@DPTR	; Read value
 1620:	  073B	D0 82			POP	DP0L
 1621:	  073D	D0 83			POP	DP0H
 1622:	  073F	22			RET
 1623:				;
 1624:				; Write user internal memory @R0
 1625:				;
 1626:	  0740			WRINTM:
 1627:	  0740	B8 20 00		CJNE	R0,#MSSIZE,$+3	; Non-destruction compare
 1628:	  0743	40 02			JC	WRINTM1			; Special case
 1629:	  0745	F6			MOV	@R0,A			; Write it
 1630:	  0746	22			RET
 1631:	  0747			WRINTM1:
 1632:	  0747	C0 83			PUSH	DP0H			; Save data pointer
 1633:	  0749	C0 82			PUSH	DP0L
 1634:	  074B	C0 E0			PUSH	ACC			; Save value to write
 1635:	  074D	75 83 F7		MOV	DP0H,#HIGH(MRSAVE)	; Point to high address
 1636:	  0750	74 88			MOV	A,#LOW(MRSAVE)+5		; Set up low address
 1637:	  0752	28			ADD	A,R0			; Offset to desired location
 1638:	  0753	F5 82			MOV	DP0L,A			; Set up low
 1639:	  0755	D0 E0			POP	ACC				; Get value to write
 1640:	  0757	F0			MOVX	@DPTR,A	; Write value
 1641:	  0758	D0 82			POP	DP0L
 1642:	  075A	D0 83			POP	DP0H
 1643:	  075C	22			RET
 1644:				;
 1645:				; Breakpoint has been encountered
 1646:				;
 1647:	  075D			BREAKPT:
 1648:	  075D	F1 EF			ACALL	SAVEREG		; Save user registers
 1649:				; Replace any breakpointed code
 1650:	  075F	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint
 1651:	  0762	78 00			MOV	R0,#0			; Set to zero
 1652:	  0764			BREAK1:
 1653:	  0764	E0			MOVX	A,@DPTR	; Get HIGH address
 1654:	  0765	A3			INC	DPTR			; Advance
 1655:	  0766	FC			MOV	R4,A			; Save
 1656:	  0767	E0			MOVX	A,@DPTR	; Get LOW address
 1657:	  0768	A3			INC	DPTR			; Advance
 1658:	  0769	FB			MOV	R3,A			; Save
 1659:	  076A	4C			ORL	A,R4			; Is this one used?
 1660:	  076B	60 0A			JZ	BREAK3			; No, skip it
 1661:				; Breakpoint... Replace user code
 1662:	  076D	7F 03			MOV	R7,#3			; Move three bytes
 1663:	  076F			BREAK2:
 1664:	  076F	E0			MOVX	A,@DPTR	; Get code byte
 1665:	  0770	A3			INC	DPTR			; Advance
 1666:				; ??? Write to code memory
 1667:	  0771	D1 F3			ACALL	WR43		; Write to code

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1668:	  0773	DF FA			DJNZ	R7,BREAK2	; Write it all
 1669:	  0775	80 03			SJMP	BREAK4		; And proceed
 1670:				; No breakpoint set... skip to next
 1671:	  0777			BREAK3:
 1672:	  0777	A3			INC	DPTR			; Skip code
 1673:	  0778	A3			INC	DPTR
 1674:	  0779	A3			INC	DPTR
 1675:	  077A			BREAK4:
 1676:	  077A	08			INC	R0				; Advance code
 1677:	  077B	B8 04 E6		CJNE	R0,#NBREAK,BREAK1 ; Do them all
 1678:				; Continue with breakpoint processing
 1679:	  077E	90 08 57		MOV	DPTR,#M_BREAK	; Point to 'Break at ' message
 1680:	  0781	91 4C			ACALL	WRSTR		; Output
 1681:				; Adjust PC by -3 to compensate for breakpoint return address
 1682:	  0783	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1683:	  0786	E0			MOVX	A,@DPTR	; Get HIGH value
 1684:	  0787	A3			INC	DPTR			; Advance
 1685:	  0788	F5 F0			MOV	B,A				; B = HIGH
 1686:	  078A	E0			MOVX	A,@DPTR	; Get LOW value
 1687:	  078B	C3			CLR	C				; Zero carry
 1688:	  078C	94 03			SUBB	A,#3		; Backup by 3
 1689:	  078E	C5 F0			XCH	A,B				; Get HIGH
 1690:	  0790	94 00			SUBB	A,#0		; Include carry
 1691:	  0792	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1692:	  0795	F0			MOVX	@DPTR,A	; Write new HIGH
 1693:	  0796	91 38			ACALL	WRHEX		; Output
 1694:	  0798	A3			INC	DPTR			; Advance
 1695:	  0799	E5 F0			MOV	A,B				; Get LOW
 1696:	  079B	C5 F0			XCH	A,B				; Get LOW
 1697:	  079D	F0			MOVX	@DPTR,A	; Write new LOW
 1698:	  079E	91 38			ACALL	WRHEX		; Output
 1699:	  07A0	01 3C			AJMP	PROMPT
 1700:				;
 1701:				; Test for see if breakpoint conflict at address R2:1
 1702:				;
 1703:	  07A2			TESTBRK:
 1704:	  07A2	90 F7 A8		MOV	DPTR,#BRKTAB	; Point to breakpoint table
 1705:	  07A5	78 00			MOV	R0,#0			; Init count
 1706:	  07A7			TSTBR1:
 1707:	  07A7	E0			MOVX	A,@DPTR	; Get HIGH value
 1708:	  07A8	A3			INC	DPTR			; Advance
 1709:	  07A9	FC			MOV	R4,A			; Save HIGH
 1710:	  07AA	E0			MOVX	A,@DPTR	; Get LOW value
 1711:	  07AB	A3			INC	DPTR			; ; Advance
 1712:	  07AC	FB			MOV	R3,A			; Continue
 1713:	  07AD	A3			INC	DPTR			; Skip
 1714:	  07AE	A3			INC	DPTR			; Code
 1715:	  07AF	A3			INC	DPTR			; Bytes
 1716:	  07B0	4C			ORL	A,R4			; Breakpoint set?
 1717:	  07B1	60 17			JZ	TSTBR3			; No, skip it
 1718:	  07B3	7F 03			MOV	R7,#3			; Test three times
 1719:	  07B5			TSTBR2:
 1720:	  07B5	C3			CLR	C				; Zero carry
 1721:	  07B6	E9			MOV	A,R1			; Get LOW
 1722:	  07B7	9B			SUBB	A,R3		; Do LOW
 1723:	  07B8	F5 F0			MOV	B,A				; Save for later

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1724:	  07BA	EA			MOV	A,R2			; Get HIGH
 1725:	  07BB	9C			SUBB	A,R4		; Do HIGH
 1726:	  07BC	45 F0			ORL	A,B				; Same?
 1727:	  07BE	60 0F			JZ	TSTBR4			; We found a collision
 1728:	  07C0	EB			MOV	A,R3			; Get LOW BP address
 1729:	  07C1	24 01			ADD	A,#1			; Advance
 1730:	  07C3	FB			MOV	R3,A			; Resave
 1731:	  07C4	EC			MOV	A,R4			; Get HIGH BP address
 1732:	  07C5	34 00			ADDC	A,#0		; Include carry
 1733:	  07C7	FC			MOV	R4,A			; Resave
 1734:	  07C8	DF EB			DJNZ	R7,TSTBR2	; Keep going
 1735:	  07CA			TSTBR3:
 1736:	  07CA	08			INC	R0				; Advance count
 1737:	  07CB	B8 04 D9		CJNE	R0,#NBREAK,TSTBR1 ; Do them all
 1738:	  07CE	22			RET
 1739:	  07CF			TSTBR4:
 1740:	  07CF	90 08 61		MOV	DPTR,#M_CONFL	; Point to 'Breakpoint Conflict!' message
 1741:	  07D2	91 4C			ACALL	WRSTR		; Output
 1742:	  07D4	01 3C			AJMP	PROMPT		; Abort command
 1743:				;
 1744:				; Single step interrupt has been encounted
 1745:				;
 1746:	  07D6			SSINT:
 1747:	  07D6	C2 AB			CLR	IE.3			; Disable timer-1 interrupt
 1748:	  07D8	F1 EF			ACALL	SAVEREG		; Save user registers
 1749:				; Reset timer1 for baud rate generation
 1750:	  07DA	E5 89			MOV	A,TMOD			; Get timer mode
 1751:	  07DC	54 0F			ANL	A,#00001111b	; Zero timer1 mode
 1752:	  07DE	44 20			ORL	A,#00100000b	; T1 = 8 bit auto-reload
 1753:	  07E0	F5 89			MOV	TMOD,A			; Resave new timer mode
 1754:	  07E2	75 8D FF		MOV	TH1,#-BAUD		; Timer1 reload value
 1755:	  07E5	75 8B FF		MOV	TL1,#-BAUD		; Timer1 initial value
 1756:	  07E8	C2 8F			CLR	TCON.7			; Clear timer1 int pend
 1757:	  07EA	F1 EE			ACALL	IRET		; Reset interrupt system
 1758:	  07EC	01 3C			AJMP	PROMPT		; Re-enter monitor
 1759:	  07EE			IRET:
 1760:	  07EE	32			RETI
 1761:				;
 1762:				; Save the user registers & switch to montor stack
 1763:				;
 1764:	  07EF			SAVEREG:
 1765:	  07EF	C0 82			PUSH	DP0L			; Save DPTR
 1766:	  07F1	C0 83			PUSH	DP0H			; ""
 1767:				; Save A,B PSW & DPTR
 1768:	  07F3	90 F7 83		MOV	DPTR,#MRSAVE	; Point to save area
 1769:	  07F6	F0			MOVX	@DPTR,A	; Save ACC
 1770:	  07F7	A3			INC	DPTR
 1771:	  07F8	E5 F0			MOV	A,B				; Save 'B'
 1772:	  07FA	F0			MOVX	@DPTR,A
 1773:	  07FB	A3			INC	DPTR
 1774:	  07FC	E5 D0			MOV	A,PSW			; Save PSW
 1775:	  07FE	F0			MOVX	@DPTR,A
 1776:	  07FF	A3			INC	DPTR
 1777:	  0800	53 D0 E7		ANL	PSW,#11100111b	; Insure RB=0
 1778:	  0803	D0 E0			POP	ACC				; Save DP0H
 1779:	  0805	F0			MOVX	@DPTR,A

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1780:	  0806	A3			INC	DPTR
 1781:	  0807	D0 E0			POP	ACC				; Save DP0L
 1782:	  0809	F0			MOVX	@DPTR,A
 1783:				; Save the return address so we can get back to monitor
 1784:	  080A	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to temp space
 1785:	  080D	D0 E0			POP	ACC				; Get HIGH ret addr
 1786:	  080F	F0			MOVX	@DPTR,A	; Save it
 1787:	  0810	A3			INC	DPTR			; Advance
 1788:	  0811	D0 E0			POP	ACC				; Get LOW ret addr
 1789:	  0813	F0			MOVX	@DPTR,A	; Save it
 1790:				; Save R0-R7 + n bytes of stack space
 1791:	  0814	90 F7 88		MOV	DPTR,#MRSAVE+5	; Point to registers
 1792:	  0817	E8			MOV	A,R0			; Save R0
 1793:	  0818	F0			MOVX	@DPTR,A
 1794:	  0819	A3			INC	DPTR
 1795:	  081A	78 01			MOV	R0,#1			; Point to R1
 1796:	  081C			SAVER1:
 1797:	  081C	E6			MOV	A,@R0			; Get data
 1798:	  081D	F0			MOVX	@DPTR,A		; Write to memory
 1799:	  081E	A3			INC	DPTR			; Advance pointer
 1800:	  081F	08			INC	R0				; Next internal
 1801:	  0820	B8 20 F9		CJNE	R0,#MSSIZE,SAVER1 ; Do them all
 1802:				; Save the users PC
 1803:	  0823	90 F7 80		MOV	DPTR,#PCSAVE	; Point to PC save area
 1804:	  0826	D0 E0			POP	ACC				; Get HIGH pc
 1805:	  0828	F0			MOVX	@DPTR,A	; Save PC
 1806:	  0829	A3			INC	DPTR			; Advance
 1807:	  082A	D0 E0			POP	ACC				; Get LOW PC
 1808:	  082C	F0			MOVX	@DPTR,A	; Advance
 1809:	  082D	A3			INC	DPTR			; Advance
 1810:				; Save the users stack pointer
 1811:	  082E	E5 81			MOV	A,SP			; Get SP
 1812:	  0830	F0			MOVX	@DPTR,A	; Save for later
 1813:				; Return to caller by jumping to original routine
 1814:	  0831	75 81 07		MOV	SP,#STACK		; Reset to our stack pointer
 1815:	  0834	90 F7 BC		MOV	DPTR,#MBUFFER	; Point to temporary location
 1816:	  0837	E0			MOVX	A,@DPTR	; Get value
 1817:	  0838	F5 F0			MOV	B,A				; Save for later
 1818:	  083A	A3			INC	DPTR			; Advance
 1819:	  083B	E0			MOVX	A,@DPTR	; Get rest of value
 1820:	  083C	C0 E0			PUSH	ACC			; Save for return
 1821:	  083E	C0 F0			PUSH	B			; ""
 1822:	  0840	22			RET					; Back to caller
 1823:				;
 1824:				; Text Messages
 1825:				;
 1826:	  0841	20 42 79 74	M_BYTES:	DB	' Bytes',0
	  0845	65 73 00
 1827:	  0848	2D 3E 00	M_PC:		DB	'->',0
 1828:	  084B	3F 4C 6F 61	M_LOAD:		DB	'?Load error',0
	  084F	64 20 65 72
	  0853	72 6F 72 00
 1829:	  0857	42 72 65 61	M_BREAK:	DB	'Break at ',0
	  085B	6B 20 61 74
	  085F	20 00
 1830:	  0861	0A 0D 42 72	M_CONFL:	DB	0Ah,0Dh,'Breakpoint conflict!',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

	  0865	65 61 6B 70
	  0869	6F 69 6E 74
	  086D	20 63 6F 6E
	  0871	66 6C 69 63
	  0875	74 21 00
 1831:	  0878	0A 0D 4D 4F	M_HELLO:	DB	0Ah,0Dh,'MON51 v1.1 (c) Dave Dunfield',0Ah,0Dh
	  087C	4E 35 31 20
	  0880	76 31 2E 31
	  0884	20 28 63 29
	  0888	20 44 61 76
	  088C	65 20 44 75
	  0890	6E 66 69 65
	  0894	6C 64 0A 0D
 1832:	  0898	4F 72 69 67				DB	'Original code at https://dunfield.themindfactory.com',0Ah,0Dh
	  089C	69 6E 61 6C
	  08A0	20 63 6F 64
	  08A4	65 20 61 74
	  08A8	20 68 74 74
	  08AC	70 73 3A 2F
	  08B0	2F 64 75 6E
	  08B4	66 69 65 6C
	  08B8	64 2E 74 68
	  08BC	65 6D 69 6E
	  08C0	64 66 61 63
	  08C4	74 6F 72 79
	  08C8	2E 63 6F 6D
	  08CC	0A 0D
 1833:	  08CE	53 65 65 20				DB	'See COPY.TXT at the above address for more information.',0Ah,0Dh
	  08D2	43 4F 50 59
	  08D6	2E 54 58 54
	  08DA	20 61 74 20
	  08DE	74 68 65 20
	  08E2	61 62 6F 76
	  08E6	65 20 61 64
	  08EA	64 72 65 73
	  08EE	73 20 66 6F
	  08F2	72 20 6D 6F
	  08F6	72 65 20 69
	  08FA	6E 66 6F 72
	  08FE	6D 61 74 69
	  0902	6F 6E 2E 0A
	  0906	0D
 1834:	  0907	0A 0D 55 73				DB	0Ah,0Dh,'User Program space starts at address 0x',0
	  090B	65 72 20 50
	  090F	72 6F 67 72
	  0913	61 6D 20 73
	  0917	70 61 63 65
	  091B	20 73 74 61
	  091F	72 74 73 20
	  0923	61 74 20 61
	  0927	64 64 72 65
	  092B	73 73 20 30
	  092F	78 00
 1835:				;
 1836:				; Table of register names to output
 1837:				;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 1838:	  0931			RNTABLE:
 1839:	  0931	50 43 3D 00		DB	'PC=',0
 1840:	  0935	00			DB	'',0
 1841:	  0936	20 53 50 3D		DB	' SP=',0
	  093A	00
 1842:	  093B	20 41 3D 00		DB	' A=',0
 1843:	  093F	20 42 3D 00		DB	' B=',0
 1844:	  0943	20 50 53 57		DB	' PSW=',0
	  0947	3D 00
 1845:	  0949	20 44 50 54		DB	' DPTR=',0
	  094D	52 3D 00
 1846:	  0950	00			DB	'',0
 1847:				; Note 'RDUMP' keys on a leading $0A to detect register bank
 1848:	  0951	0A 0D 00		DB	0Ah,0Dh,0
 1849:	  0954	52 30 3D 00		DB	'R0=',0
 1850:	  0958	20 52 31 3D		DB	' R1=',0
	  095C	00
 1851:	  095D	20 52 32 3D		DB	' R2=',0
	  0961	00
 1852:	  0962	20 52 33 3D		DB	' R3=',0
	  0966	00
 1853:	  0967	20 52 34 3D		DB	' R4=',0
	  096B	00
 1854:	  096C	20 52 35 3D		DB	' R5=',0
	  0970	00
 1855:	  0971	20 52 36 3D		DB	' R6=',0
	  0975	00
 1856:	  0976	20 52 37 3D		DB	' R7=',0
	  097A	00
 1857:	  097B	FF			DB	0FFh		; End of list
 1858:				;
 1859:				; Dissassembly opcode table
 1860:				;
 1861:	  097C			OTABLE:
 1862:	  097C	1F 11 41 43		DB	1Fh,11h,'A','C','A','L','L',' ','a',0
	  0980	41 4C 4C 20
	  0984	61 00
 1863:	  0986	F8 28 41 44		DB	0F8h,28h,'A','D','D',' ','A',',','r',0
	  098A	44 20 41 2C
	  098E	72 00
 1864:	  0990	FF 25 41 44		DB	0FFh,25h,'A','D','D',' ','A',',','d',0
	  0994	44 20 41 2C
	  0998	64 00
 1865:	  099A	FE 26 41 44		DB	0FEh,26h,'A','D','D',' ','A',',','i',0
	  099E	44 20 41 2C
	  09A2	69 00
 1866:	  09A4	FF 24 41 44		DB	0FFh,24h,'A','D','D',' ','A',',','m',0
	  09A8	44 20 41 2C
	  09AC	6D 00
 1867:	  09AE	F8 38 41 44		DB	0F8h,38h,'A','D','D','C',' ','A',',','r',0
	  09B2	44 43 20 41
	  09B6	2C 72 00
 1868:	  09B9	FF 35 41 44		DB	0FFh,35h,'A','D','D','C',' ','A',',','d',0
	  09BD	44 43 20 41
	  09C1	2C 64 00
 1869:	  09C4	FE 36 41 44		DB	0FEh,36h,'A','D','D','C',' ','A',',','i',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

	  09C8	44 43 20 41
	  09CC	2C 69 00
 1870:	  09CF	FF 34 41 44		DB	0FFh,34h,'A','D','D','C',' ','A',',','m',0
	  09D3	44 43 20 41
	  09D7	2C 6D 00
 1871:	  09DA	1F 01 41 4A		DB	1Fh,01h,'A','J','M','P',' ','a',0
	  09DE	4D 50 20 61
	  09E2	00
 1872:	  09E3	F8 58 41 4E		DB	0F8h,58h,'A','N','L',' ','A',',','r',0
	  09E7	4C 20 41 2C
	  09EB	72 00
 1873:	  09ED	FF 55 41 4E		DB	0FFh,55h,'A','N','L',' ','A',',','d',0
	  09F1	4C 20 41 2C
	  09F5	64 00
 1874:	  09F7	FE 56 41 4E		DB	0FEh,56h,'A','N','L',' ','A',',','i',0
	  09FB	4C 20 41 2C
	  09FF	69 00
 1875:	  0A01	FF 54 41 4E		DB	0FFh,54h,'A','N','L',' ','A',',','m',0
	  0A05	4C 20 41 2C
	  0A09	6D 00
 1876:	  0A0B	FF 52 41 4E		DB	0FFh,52h,'A','N','L',' ','d',',','A',0
	  0A0F	4C 20 64 2C
	  0A13	41 00
 1877:	  0A15	FF 53 41 4E		DB	0FFh,53h,'A','N','L',' ','d',',','m',0
	  0A19	4C 20 64 2C
	  0A1D	6D 00
 1878:	  0A1F	FF 82 41 4E		DB	0FFh,82h,'A','N','L',' ','C',',','b',0
	  0A23	4C 20 43 2C
	  0A27	62 00
 1879:	  0A29	FF B0 41 4E		DB	0FFh,0B0h,'A','N','L',' ','C',',','/','b',0
	  0A2D	4C 20 43 2C
	  0A31	2F 62 00
 1880:	  0A34	FF B5 43 4A		DB	0FFh,0B5h,'C','J','N','E',' ','A',',','d',',','j',0
	  0A38	4E 45 20 41
	  0A3C	2C 64 2C 6A
	  0A40	00
 1881:	  0A41	FF B4 43 4A		DB	0FFh,0B4h,'C','J','N','E',' ','A',',','m',',','j',0
	  0A45	4E 45 20 41
	  0A49	2C 6D 2C 6A
	  0A4D	00
 1882:	  0A4E	F8 B8 43 4A		DB	0F8h,0B8h,'C','J','N','E',' ','r',',','m',',','j',0
	  0A52	4E 45 20 72
	  0A56	2C 6D 2C 6A
	  0A5A	00
 1883:	  0A5B	FE B6 43 4A		DB	0FEh,0B6h,'C','J','N','E',' ','i',',','m',',','j',0
	  0A5F	4E 45 20 69
	  0A63	2C 6D 2C 6A
	  0A67	00
 1884:	  0A68	FF E4 43 4C		DB	0FFh,0E4h,'C','L','R',' ','A',0
	  0A6C	52 20 41 00
 1885:	  0A70	FF C3 43 4C		DB	0FFh,0C3h,'C','L','R',' ','C',0
	  0A74	52 20 43 00
 1886:	  0A78	FF C2 43 4C		DB	0FFh,0C2h,'C','L','R',' ','b',0
	  0A7C	52 20 62 00
 1887:	  0A80	FF F4 43 50		DB	0FFh,0F4h,'C','P','L',' ','A',0
	  0A84	4C 20 41 00

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 1888:	  0A88	FF B3 43 50		DB	0FFh,0B3h,'C','P','L',' ','C',0
	  0A8C	4C 20 43 00
 1889:	  0A90	FF B2 43 50		DB	0FFh,0B2h,'C','P','L',' ','b',0
	  0A94	4C 20 62 00
 1890:	  0A98	FF D4 44 41		DB	0FFh,0D4h,'D','A',' ','A',0
	  0A9C	20 41 00
 1891:	  0A9F	FF 14 44 45		DB	0FFh,14h,'D','E','C',' ','A',0
	  0AA3	43 20 41 00
 1892:	  0AA7	F8 18 44 45		DB	0F8h,18h,'D','E','C',' ','r',0
	  0AAB	43 20 72 00
 1893:	  0AAF	FF 15 44 45		DB	0FFh,15h,'D','E','C',' ','d',0
	  0AB3	43 20 64 00
 1894:	  0AB7	FE 16 44 45		DB	0FEh,16h,'D','E','C',' ','i',0
	  0ABB	43 20 69 00
 1895:	  0ABF	FF 84 44 49		DB	0FFh,84h,'D','I','V',' ','A','B',0
	  0AC3	56 20 41 42
	  0AC7	00
 1896:	  0AC8	F8 D8 44 4A		DB	0F8h,0D8h,'D','J','N','Z',' ','r',',','j',0
	  0ACC	4E 5A 20 72
	  0AD0	2C 6A 00
 1897:	  0AD3	FF D5 44 4A		DB	0FFh,0D5h,'D','J','N','Z',' ','d',',','j',0
	  0AD7	4E 5A 20 64
	  0ADB	2C 6A 00
 1898:	  0ADE	FF 04 49 4E		DB	0FFh,04h,'I','N','C',' ','A',0
	  0AE2	43 20 41 00
 1899:	  0AE6	F8 08 49 4E		DB	0F8h,08h,'I','N','C',' ','r',0
	  0AEA	43 20 72 00
 1900:	  0AEE	FF 05 49 4E		DB	0FFh,05h,'I','N','C',' ','d',0
	  0AF2	43 20 64 00
 1901:	  0AF6	FE 06 49 4E		DB	0FEh,06h,'I','N','C',' ','i',0
	  0AFA	43 20 69 00
 1902:	  0AFE	FF A3 49 4E		DB	0FFh,0A3h,'I','N','C',' ','D','P','T','R',0
	  0B02	43 20 44 50
	  0B06	54 52 00
 1903:	  0B09	FF 20 4A 42		DB	0FFh,20h,'J','B',' ','b',',','j',0
	  0B0D	20 62 2C 6A
	  0B11	00
 1904:	  0B12	FF 10 4A 42		DB	0FFh,10h,'J','B','C',' ','b',',','j',0
	  0B16	43 20 62 2C
	  0B1A	6A 00
 1905:	  0B1C	FF 40 4A 43		DB	0FFh,40h,'J','C',' ','j',0
	  0B20	20 6A 00
 1906:	  0B23	FF 73 4A 4D		DB	0FFh,73h,'J','M','P',' ','[','A','+','D','P','T','R',']',0
	  0B27	50 20 5B 41
	  0B2B	2B 44 50 54
	  0B2F	52 5D 00
 1907:	  0B32	FF 30 4A 4E		DB	0FFh,30h,'J','N','B',' ','b',',','j',0
	  0B36	42 20 62 2C
	  0B3A	6A 00
 1908:	  0B3C	FF 50 4A 4E		DB	0FFh,50h,'J','N','C',' ','j',0
	  0B40	43 20 6A 00
 1909:	  0B44	FF 70 4A 4E		DB	0FFh,70h,'J','N','Z',' ','j',0
	  0B48	5A 20 6A 00
 1910:	  0B4C	FF 60 4A 5A		DB	0FFh,60h,'J','Z',' ','j',0
	  0B50	20 6A 00
 1911:	  0B53	FF 12 4C 43		DB	0FFh,12h,'L','C','A','L','L',' ','x',0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

	  0B57	41 4C 4C 20
	  0B5B	78 00
 1912:	  0B5D	FF 02 4C 4A		DB	0FFh,02h,'L','J','M','P',' ','x',0
	  0B61	4D 50 20 78
	  0B65	00
 1913:	  0B66	F8 E8 4D 4F		DB	0F8h,0E8h,'M','O','V',' ','A',',','r',0
	  0B6A	56 20 41 2C
	  0B6E	72 00
 1914:	  0B70	FF E5 4D 4F		DB	0FFh,0E5h,'M','O','V',' ','A',',','d',0
	  0B74	56 20 41 2C
	  0B78	64 00
 1915:	  0B7A	FE E6 4D 4F		DB	0FEh,0E6h,'M','O','V',' ','A',',','i',0
	  0B7E	56 20 41 2C
	  0B82	69 00
 1916:	  0B84	FF 74 4D 4F		DB	0FFh,74h,'M','O','V',' ','A',',','m',0
	  0B88	56 20 41 2C
	  0B8C	6D 00
 1917:	  0B8E	F8 F8 4D 4F		DB	0F8h,0F8h,'M','O','V',' ','r',',','A',0
	  0B92	56 20 72 2C
	  0B96	41 00
 1918:	  0B98	F8 A8 4D 4F		DB	0F8h,0A8h,'M','O','V',' ','r',',','d',0
	  0B9C	56 20 72 2C
	  0BA0	64 00
 1919:	  0BA2	F8 78 4D 4F		DB	0F8h,78h,'M','O','V',' ','r',',','m',0
	  0BA6	56 20 72 2C
	  0BAA	6D 00
 1920:	  0BAC	FF F5 4D 4F		DB	0FFh,0F5h,'M','O','V',' ','d',',','A',0
	  0BB0	56 20 64 2C
	  0BB4	41 00
 1921:	  0BB6	F8 88 4D 4F		DB	0F8h,88h,'M','O','V',' ','d',',','r',0
	  0BBA	56 20 64 2C
	  0BBE	72 00
 1922:	  0BC0	FF 85 4D 4F		DB	0FFh,85h,'M','O','V',' ','e',',','f',0
	  0BC4	56 20 65 2C
	  0BC8	66 00
 1923:	  0BCA	FE 86 4D 4F		DB	0FEh,86h,'M','O','V',' ','d',',','i',0
	  0BCE	56 20 64 2C
	  0BD2	69 00
 1924:	  0BD4	FF 75 4D 4F		DB	0FFh,75h,'M','O','V',' ','d',',','m',0
	  0BD8	56 20 64 2C
	  0BDC	6D 00
 1925:	  0BDE	FE F6 4D 4F		DB	0FEh,0F6h,'M','O','V',' ','i',',','A',0
	  0BE2	56 20 69 2C
	  0BE6	41 00
 1926:	  0BE8	FE A6 4D 4F		DB	0FEh,0A6h,'M','O','V',' ','i',',','d',0
	  0BEC	56 20 69 2C
	  0BF0	64 00
 1927:	  0BF2	FE 76 4D 4F		DB	0FEh,76h,'M','O','V',' ','i',',','m',0
	  0BF6	56 20 69 2C
	  0BFA	6D 00
 1928:	  0BFC	FF A2 4D 4F		DB	0FFh,0A2h,'M','O','V',' ','C',',','b',0
	  0C00	56 20 43 2C
	  0C04	62 00
 1929:	  0C06	FF 92 4D 4F		DB	0FFh,92h,'M','O','V',' ','b',',','C',0
	  0C0A	56 20 62 2C
	  0C0E	43 00

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 1930:	  0C10	FF 90 4D 4F		DB	0FFh,90h,'M','O','V',' ','D','P','T','R',',','#','x',0
	  0C14	56 20 44 50
	  0C18	54 52 2C 23
	  0C1C	78 00
 1931:	  0C1E	FF 93 4D 4F		DB	0FFh,93h,'M','O','V','C',' ','A',',','[','A','+','D','P','T','R',']',0
	  0C22	56 43 20 41
	  0C26	2C 5B 41 2B
	  0C2A	44 50 54 52
	  0C2E	5D 00
 1932:	  0C30	FF 83 4D 4F		DB	0FFh,83h,'M','O','V','C',' ','A',',','[','A','+','P','C',']',0
	  0C34	56 43 20 41
	  0C38	2C 5B 41 2B
	  0C3C	50 43 5D 00
 1933:	  0C40	FE E2 4D 4F		DB	0FEh,0E2h,'M','O','V','X',' ','A',',','i',0
	  0C44	56 58 20 41
	  0C48	2C 69 00
 1934:	  0C4B	FF E0 4D 4F		DB	0FFh,0E0h,'M','O','V','X',' ','A',',','[','D','P','T','R',']',0
	  0C4F	56 58 20 41
	  0C53	2C 5B 44 50
	  0C57	54 52 5D 00
 1935:	  0C5B	FE F2 4D 4F		DB	0FEh,0F2h,'M','O','V','X',' ','i',',','A',0
	  0C5F	56 58 20 69
	  0C63	2C 41 00
 1936:	  0C66	FF F0 4D 4F		DB	0FFh,0F0h,'M','O','V','X',' ','[','D','P','T','R',']',',','A',0
	  0C6A	56 58 20 5B
	  0C6E	44 50 54 52
	  0C72	5D 2C 41 00
 1937:	  0C76	FF A4 4D 55		DB	0FFh,0A4h,'M','U','L',' ','A','B',0
	  0C7A	4C 20 41 42
	  0C7E	00
 1938:	  0C7F	FF 00 4E 4F		DB	0FFh,00h,'N','O','P',0
	  0C83	50 00
 1939:	  0C85	F8 48 4F 52		DB	0F8h,48h,'O','R','L',' ','A',',','r',0
	  0C89	4C 20 41 2C
	  0C8D	72 00
 1940:	  0C8F	FF 45 4F 52		DB	0FFh,45h,'O','R','L',' ','A',',','d',0
	  0C93	4C 20 41 2C
	  0C97	64 00
 1941:	  0C99	FE 46 4F 52		DB	0FEh,46h,'O','R','L',' ','A',',','i',0
	  0C9D	4C 20 41 2C
	  0CA1	69 00
 1942:	  0CA3	FF 44 4F 52		DB	0FFh,44h,'O','R','L',' ','A',',','m',0
	  0CA7	4C 20 41 2C
	  0CAB	6D 00
 1943:	  0CAD	FF 42 4F 52		DB	0FFh,42h,'O','R','L',' ','d',',','A',0
	  0CB1	4C 20 64 2C
	  0CB5	41 00
 1944:	  0CB7	FF 43 4F 52		DB	0FFh,43h,'O','R','L',' ','d',',','m',0
	  0CBB	4C 20 64 2C
	  0CBF	6D 00
 1945:	  0CC1	FF 72 4F 52		DB	0FFh,72h,'O','R','L',' ','C',',','b',0
	  0CC5	4C 20 43 2C
	  0CC9	62 00
 1946:	  0CCB	FF A0 4F 52		DB	0FFh,0A0h,'O','R','L',' ','C',',','/','b',0
	  0CCF	4C 20 43 2C
	  0CD3	2F 62 00

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 1947:	  0CD6	FF D0 50 4F		DB	0FFh,0D0h,'P','O','P',' ','d',0
	  0CDA	50 20 64 00
 1948:	  0CDE	FF C0 50 55		DB	0FFh,0C0h,'P','U','S','H',' ','d',0
	  0CE2	53 48 20 64
	  0CE6	00
 1949:	  0CE7	FF 22 52 45		DB	0FFh,22h,'R','E','T',0
	  0CEB	54 00
 1950:	  0CED	FF 32 52 45		DB	0FFh,32h,'R','E','T','I',0
	  0CF1	54 49 00
 1951:	  0CF4	FF 23 52 4C		DB	0FFh,23h,'R','L',' ','A',0
	  0CF8	20 41 00
 1952:	  0CFB	FF 33 52 4C		DB	0FFh,33h,'R','L','C',' ','A',0
	  0CFF	43 20 41 00
 1953:	  0D03	FF 03 52 52		DB	0FFh,03h,'R','R',' ','A',0
	  0D07	20 41 00
 1954:	  0D0A	FF 13 52 52		DB	0FFh,13h,'R','R','C',' ','A',0
	  0D0E	43 20 41 00
 1955:	  0D12	FF D3 53 45		DB	0FFh,0D3h,'S','E','T','B',' ','C',0
	  0D16	54 42 20 43
	  0D1A	00
 1956:	  0D1B	FF D2 53 45		DB	0FFh,0D2h,'S','E','T','B',' ','b',0
	  0D1F	54 42 20 62
	  0D23	00
 1957:	  0D24	FF 80 53 4A		DB	0FFh,80h,'S','J','M','P',' ','j',0
	  0D28	4D 50 20 6A
	  0D2C	00
 1958:	  0D2D	F8 98 53 55		DB	0F8h,98h,'S','U','B','B',' ','A',',','r',0
	  0D31	42 42 20 41
	  0D35	2C 72 00
 1959:	  0D38	FF 95 53 55		DB	0FFh,95h,'S','U','B','B',' ','A',',','d',0
	  0D3C	42 42 20 41
	  0D40	2C 64 00
 1960:	  0D43	FE 96 53 55		DB	0FEh,96h,'S','U','B','B',' ','A',',','i',0
	  0D47	42 42 20 41
	  0D4B	2C 69 00
 1961:	  0D4E	FF 94 53 55		DB	0FFh,94h,'S','U','B','B',' ','A',',','m',0
	  0D52	42 42 20 41
	  0D56	2C 6D 00
 1962:	  0D59	FF C4 53 57		DB	0FFh,0C4h,'S','W','A','P',' ','A',0
	  0D5D	41 50 20 41
	  0D61	00
 1963:	  0D62	F8 C8 58 43		DB	0F8h,0C8h,'X','C','H',' ','A',',','r',0
	  0D66	48 20 41 2C
	  0D6A	72 00
 1964:	  0D6C	FF C5 58 43		DB	0FFh,0C5h,'X','C','H',' ','A',',','d',0
	  0D70	48 20 41 2C
	  0D74	64 00
 1965:	  0D76	FE C6 58 43		DB	0FEh,0C6h,'X','C','H',' ','A',',','i',0
	  0D7A	48 20 41 2C
	  0D7E	69 00
 1966:	  0D80	FE D6 58 43		DB	0FEh,0D6h,'X','C','H','D',' ','A',',','i',0
	  0D84	48 44 20 41
	  0D88	2C 69 00
 1967:	  0D8B	F8 68 58 52		DB	0F8h,68h,'X','R','L',' ','A',',','r',0
	  0D8F	4C 20 41 2C
	  0D93	72 00

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 1968:	  0D95	FF 65 58 52		DB	0FFh,65h,'X','R','L',' ','A',',','d',0
	  0D99	4C 20 41 2C
	  0D9D	64 00
 1969:	  0D9F	FE 66 58 52		DB	0FEh,66h,'X','R','L',' ','A',',','i',0
	  0DA3	4C 20 41 2C
	  0DA7	69 00
 1970:	  0DA9	FF 64 58 52		DB	0FFh,64h,'X','R','L',' ','A',',','m',0
	  0DAD	4C 20 41 2C
	  0DB1	6D 00
 1971:	  0DB3	FF 62 58 52		DB	0FFh,62h,'X','R','L',' ','d',',','A',0
	  0DB7	4C 20 64 2C
	  0DBB	41 00
 1972:	  0DBD	FF 63 58 52		DB	0FFh,63h,'X','R','L',' ','d',',','m',0
	  0DC1	4C 20 64 2C
	  0DC5	6D 00
 1973:	  0DC7	00 00 3F 49		DB	0,0,'?','I','L','L','E','G','A','L',0
	  0DCB	4C 4C 45 47
	  0DCF	41 4C 00
 1974:				;
 1975:				; Direct memory address table
 1976:				;
 1977:	  0DD2			DTABLE:
 1978:	  0DD2	E0 41			DB	0E0h,'A'
 1979:	  0DD4	F0 42			DB	0F0h,'B'
 1980:	  0DD6	D0 50 53 57		DB	0D0h,'P','S','W'
 1981:	  0DDA	81 53 50		DB	81h,'S','P'
 1982:	  0DDD	82 44 50 4C		DB	82h,'D','P','L'
 1983:	  0DE1	83 44 50 48		DB	83h,'D','P','H'
 1984:	  0DE5	80 50 30		DB	80h,'P','0'
 1985:	  0DE8	90 50 31		DB	90h,'P','1'
 1986:	  0DEB	A0 50 32		DB	0A0h,'P','2'
 1987:	  0DEE	B0 50 33		DB	0B0h,'P','3'
 1988:	  0DF1	B8 49 50		DB	0B8h,'I','P'
 1989:	  0DF4	A8 49 45		DB	0A8h,'I','E'
 1990:	  0DF7	89 54 4D 4F		DB	89h,'T','M','O','D'
	  0DFB	44
 1991:	  0DFC	C8 54 32 43		DB	0C8h,'T','2','C','O','N'
	  0E00	4F 4E
 1992:	  0E02	88 54 43 4F		DB	88h,'T','C','O','N'
	  0E06	4E
 1993:	  0E07	8C 54 48 30		DB	8Ch,'T','H','0'
 1994:	  0E0B	8A 54 4C 30		DB	8Ah,'T','L','0'
 1995:	  0E0F	8D 54 48 31		DB	8Dh,'T','H','1'
 1996:	  0E13	8B 54 4C 31		DB	8Bh,'T','L','1'
 1997:	  0E17	CD 54 48 32		DB	0CDh,'T','H','2'
 1998:	  0E1B	CC 54 4C 32		DB	0CCh,'T','L','2'
 1999:	  0E1F	CB 52 43 41		DB	0CBh,'R','C','A','P','2','H'
	  0E23	50 32 48
 2000:	  0E26	CA 52 43 41		DB	0CAh,'R','C','A','P','2','L'
	  0E2A	50 32 4C
 2001:	  0E2D	98 53 43 4F		DB	98h,'S','C','O','N'
	  0E31	4E
 2002:	  0E32	99 53 42 55		DB	99h,'S','B','U','F'
	  0E36	46
 2003:	  0E37	87 50 43 4F		DB	87h,'P','C','O','N'
	  0E3B	4E

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2004:	  0E3C	00			DB	0
 2005:				;
 2006:				; Help text
 2007:				;
 2008:	  0E3D			HTEXT:
 2009:	  0E3D	4D 4F 4E 35		DB	'MON51 Commands:'
	  0E41	31 20 43 6F
	  0E45	6D 6D 61 6E
	  0E49	64 73 3A
 2010:	  0E4C	0A 00			DB	0Ah,0
 2011:	  0E4E	41 20 3C 61		DB	'A <aa>|Alter internal',0
	  0E52	61 3E 7C 41
	  0E56	6C 74 65 72
	  0E5A	20 69 6E 74
	  0E5E	65 72 6E 61
	  0E62	6C 00
 2012:	  0E64	42 20 5B 6E		DB	'B [n aaaa]|Breakpoints',0
	  0E68	20 61 61 61
	  0E6C	61 5D 7C 42
	  0E70	72 65 61 6B
	  0E74	70 6F 69 6E
	  0E78	74 73 00
 2013:	  0E7B	43 20 3C 72		DB	'C <r> <data>|Change register',0
	  0E7F	3E 20 3C 64
	  0E83	61 74 61 3E
	  0E87	7C 43 68 61
	  0E8B	6E 67 65 20
	  0E8F	72 65 67 69
	  0E93	73 74 65 72
	  0E97	00
 2014:	  0E98	44 20 3C 61		DB	'D <aaaa>,[aaaa]|Dump external',0
	  0E9C	61 61 61 3E
	  0EA0	2C 5B 61 61
	  0EA4	61 61 5D 7C
	  0EA8	44 75 6D 70
	  0EAC	20 65 78 74
	  0EB0	65 72 6E 61
	  0EB4	6C 00
 2015:	  0EB6	45 20 3C 61		DB	'E <aaaa>|Edit external',0
	  0EBA	61 61 61 3E
	  0EBE	7C 45 64 69
	  0EC2	74 20 65 78
	  0EC6	74 65 72 6E
	  0ECA	61 6C 00
 2016:	  0ECD	46 20 3C 61		DB	'F <aaaa>,[aaaa] <dd>|Fill external',0
	  0ED1	61 61 61 3E
	  0ED5	2C 5B 61 61
	  0ED9	61 61 5D 20
	  0EDD	3C 64 64 3E
	  0EE1	7C 46 69 6C
	  0EE5	6C 20 65 78
	  0EE9	74 65 72 6E
	  0EED	61 6C 00
 2017:	  0EF0	47 20 5B 61		DB	'G [aaaa]|Go (execute)',0
	  0EF4	61 61 61 5D
	  0EF8	7C 47 6F 20

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

	  0EFC	28 65 78 65
	  0F00	63 75 74 65
	  0F04	29 00
 2018:	  0F06	49 20 3C 61		DB	'I <aa>,<aa>|dump Internal',0
	  0F0A	61 3E 2C 3C
	  0F0E	61 61 3E 7C
	  0F12	64 75 6D 70
	  0F16	20 49 6E 74
	  0F1A	65 72 6E 61
	  0F1E	6C 00
 2019:	  0F20	4C 7C 64 6F		DB	'L|downLoad',0
	  0F24	77 6E 4C 6F
	  0F28	61 64 00
 2020:	  0F2B	4F 20 3C 61		DB	'O <aa> <data>|Output to SFR',0
	  0F2F	61 3E 20 3C
	  0F33	64 61 74 61
	  0F37	3E 7C 4F 75
	  0F3B	74 70 75 74
	  0F3F	20 74 6F 20
	  0F43	53 46 52 00
 2021:	  0F47	51 20 3C 61		DB	'Q <aa>|Query SFR',0
	  0F4B	61 3E 7C 51
	  0F4F	75 65 72 79
	  0F53	20 53 46 52
	  0F57	00
 2022:	  0F58	52 7C 64 75		DB	'R|dump Registers',0
	  0F5C	6D 70 20 52
	  0F60	65 67 69 73
	  0F64	74 65 72 73
	  0F68	00
 2023:	  0F69	53 7C 53 69		DB	'S|Single-Step',0
	  0F6D	6E 67 6C 65
	  0F71	2D 53 74 65
	  0F75	70 00
 2024:	  0F77	55 20 3C 61		DB	'U <aaaa>,[aaaa]|Un-assemble',0
	  0F7B	61 61 61 3E
	  0F7F	2C 5B 61 61
	  0F83	61 61 5D 7C
	  0F87	55 6E 2D 61
	  0F8B	73 73 65 6D
	  0F8F	62 6C 65 00
 2025:	  0F93	57 20 3C 61		DB	'W <aaaa> <data>|Single write',0
	  0F97	61 61 61 3E
	  0F9B	20 3C 64 61
	  0F9F	74 61 3E 7C
	  0FA3	53 69 6E 67
	  0FA7	6C 65 20 77
	  0FAB	72 69 74 65
	  0FAF	00
 2026:	  0FB0	58 20 43 20		DB	'X C <aaaa>|LoopRead Code',0
	  0FB4	3C 61 61 61
	  0FB8	61 3E 7C 4C
	  0FBC	6F 6F 70 52
	  0FC0	65 61 64 20
	  0FC4	43 6F 64 65
	  0FC8	00

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2027:	  0FC9	58 20 52 20		DB	'X R <aaaa>|LoopRead XDATA',0
	  0FCD	3C 61 61 61
	  0FD1	61 3E 7C 4C
	  0FD5	6F 6F 70 52
	  0FD9	65 61 64 20
	  0FDD	58 44 41 54
	  0FE1	41 00
 2028:	  0FE3	58 20 57 20		DB	'X W <aaaa> <data>|LoopWrite XDATA',0
	  0FE7	3C 61 61 61
	  0FEB	61 3E 20 3C
	  0FEF	64 61 74 61
	  0FF3	3E 7C 4C 6F
	  0FF7	6F 70 57 72
	  0FFB	69 74 65 20
	  0FFF	58 44 41 54
	  1003	41 00
 2029:	  1005	00			DB	0
 2030:				;
 2031:				; Initialize the timer 1 for auto-reload at 32xN
 2032:				;
 2033:	  1006			START:
 2034:	  1006	75 89 20		MOV	TMOD,#00100000b	; T1=8 bit auto-reload
 2035:	  1009	75 8D FF		MOV	TH1,#-BAUD		; Timer 1 reload value
 2036:	  100C	75 8B FF		MOV	TL1,#-BAUD		; Timer 1 initial value
 2037:	  100F	75 88 49		MOV	TCON,#01001001b	; Run 1, Hold 0
 2038:				; Initialize the serial port
 2039:	  1012	75 98 52		MOV	SCON,#01010010b	; Mode 1, REN, TXRDY, RXEMPTY
 2040:				; Main program - First, initialize memory
 2041:	  1015			MAIN:
 2042:	  1015	90 F7 80		MOV	DPTR,#PCSAVE	; Point to monitor RAM
 2043:	  1018	74 30			MOV	A,#HIGH(USERRAM)		; High default PC
 2044:	  101A	F0			MOVX	@DPTR,A	; Set it
 2045:	  101B	A3			INC	DPTR			; Advance
 2046:	  101C	74 00			MOV	A,#LOW(USERRAM)		; Low default PC
 2047:	  101E	F0			MOVX	@DPTR,A	; Set it
 2048:	  101F	A3			INC	DPTR			; Advance
 2049:	  1020	74 07			MOV	A,#7			; Default stack
 2050:	  1022	F0			MOVX	@DPTR,A	; Set it
 2051:	  1023	A3			INC	DPTR			; Advance
 2052:	  1024	7F 4D			MOV	R7,#MRSIZE		; Indicate size
 2053:	  1026	E4			CLR	A				; Zero
 2054:	  1027			CLEAR1:
 2055:	  1027	F0			MOVX	@DPTR,A	; Zero location
 2056:	  1028	A3			INC	DPTR			; Advance
 2057:	  1029	DF FC			DJNZ	R7,CLEAR1	; Keep going
 2058:	  102B	90 08 78		MOV	DPTR,#M_HELLO	; Point to startup message
 2059:	  102E	12 04 4C		LCALL	WRSTR		; Write it
 2060:	  1031	90 30 00		MOV	DPTR,#USERRAM	; Get start of USER program space
 2061:	  1034	12 04 32		LCALL	WRDPTR		; Write it
 2062:	  1037	02 00 3A		LJMP	FPROMPT		; And execute
 2063:
 2064:					END
 2065:




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 205
ACC				  DATA	      E0	 145
AUXR				  DATA	      8E	 121
B				  DATA	      F0	 146
BAUD				  NUMBER    0001	 221
BREAK1				  CODE	    0764	1652
BREAK2				  CODE	    076F	1663
BREAK3				  CODE	    0777	1671
BREAK4				  CODE	    077A	1675
BREAKPT				  CODE	    075D	1647
BRKPT				  CODE	    02CF	 763
BRKPT1				  CODE	    02DC	 770
BRKPT2				  CODE	    02FC	 792
BRKTAB				  CODE	    F7A8	 240
CBW				  CODE	    071E	1599
CHKC1				  CODE	    04E9	1165
CHKCHR				  CODE	    04E1	1160
CHRE1				  CODE	    0295	 713
CHRE2				  CODE	    0278	 691
CHRE3				  CODE	    0282	 698
CHRE4				  CODE	    0285	 702
CHREG				  CODE	    0245	 663
CLEAR1				  CODE	    1027	2054
CLKREG				  DATA	      8F	 122
COMP				  CODE	    0585	1299
COMP1				  CODE	    0591	1308
CPRL2				  BIT	      C8	 192
CT2				  BIT	      C9	 193
CY				  BIT	      D7	 206
DIR1				  CODE	    06BC	1520
DIR2				  CODE	    06C7	1527
DIR3				  CODE	    06D3	1535
DIR4				  CODE	    06D8	1539
DIRECT				  CODE	    06B3	1515
DIS1				  CODE	    05D7	1360
DIS10				  CODE	    064D	1444
DIS11				  CODE	    0667	1462
DIS111				  CODE	    066C	1465
DIS112				  CODE	    066E	1467
DIS12				  CODE	    0670	1470
DIS121				  CODE	    0683	1481
DIS13				  CODE	    068D	1488
DIS14				  CODE	    0699	1495
DIS15				  CODE	    06A5	1502
DIS2				  CODE	    05F1	1383
DIS3				  CODE	    05E3	1371
DIS4				  CODE	    05E5	1373
DIS41				  CODE	    05EB	1378

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIS5				  CODE	    05F8	1390
DIS51				  CODE	    0600	1395
DIS6				  CODE	    0608	1401
DIS7				  CODE	    0620	1415
DIS8				  CODE	    062D	1423
DIS9				  CODE	    063A	1431
DIS91				  CODE	    0645	1438
DISASS				  CODE	    05C9	1351
DLBYTE				  CODE	    04F6	1181
DLEOF				  CODE	    0526	1220
DLERR				  CODE	    0528	1223
DLINT				  CODE	    0557	1260
DLINT1				  CODE	    0576	1282
DLMOT				  CODE	    051A	1212
DLMOT1				  CODE	    052F	1227
DLMOT2				  CODE	    0547	1245
DLNIB				  CODE	    04FE	1191
DLNIB1				  CODE	    0512	1202
DLOAD				  CODE	    0515	1208
DODISS				  CODE	    0594	1315
DODISS1				  CODE	    05A6	1325
DODISS2				  CODE	    05B6	1336
DODISS3				  CODE	    05C1	1342
DOXSUB				  CODE	    036B	 868
DP0H				  DATA	      83	 110
DP0L				  DATA	      82	 109
DP1H				  DATA	      85	 112
DP1L				  DATA	      84	 111
DTABLE				  CODE	    0DD2	1977
DUMP1				  CODE	    0056	 300
DUMP1A				  CODE	    0060	 307
DUMP1B				  CODE	    0067	 312
DUMP1C				  CODE	    007D	 326
DUMP1D				  CODE	    0084	 331
DUMP1E				  CODE	    0092	 343
DUMP2				  CODE	    00AB	 365
DUMP2A				  CODE	    00B4	 372
DUMPI				  CODE	    009A	 354
DUMPO				  CODE	    004F	 295
EA				  BIT	      AF	 177
EDIT1				  CODE	    00C9	 389
EDIT1A				  CODE	    00DB	 400
EDIT1B				  CODE	    00DE	 403
EDIT2				  CODE	    00F6	 420
EDIT2A				  CODE	    010B	 432
EDIT2B				  CODE	    010E	 435
EDITE				  CODE	    00C4	 386
EDITI				  CODE	    00EE	 415
EECON				  DATA	      96	 124
ERROR1				  CODE	    0094	 346
ERROR2				  CODE	    0299	 717
ERROR3				  CODE	    03C3	 926
ES				  BIT	      AC	 175
ET0				  BIT	      A9	 172
ET1				  BIT	      AB	 174
ET2				  BIT	      AD	 176

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
EX0				  BIT	      A8	 171
EX1				  BIT	      AA	 173
EXEN2				  BIT	      CB	 195
EXF2				  BIT	      CE	 198
EXTI0				  CODE	    0003	 209
EXTI1				  CODE	    0013	 211
F0				  BIT	      D5	 204
FE				  BIT	      9F	 170
FILL				  CODE	    029B	 722
FILL1				  CODE	    02A9	 730
FLUSH				  CODE	    04EA	1170
FLUSH1				  CODE	    04EC	1172
FPROMPT				  CODE	    003A	 280
GETP1				  CODE	    03FF	 972
GETP2				  CODE	    040B	 978
GETPC				  CODE	    03F0	 962
GETSFR				  CODE	    0346	 841
GOC1				  CODE	    0145	 477
GOC2				  CODE	    0160	 495
GOC3				  CODE	    0163	 499
GOC4				  CODE	    016C	 505
GOCMD				  CODE	    012F	 463
HELP				  CODE	    03C5	 931
HELP1				  CODE	    03CB	 933
HELP2				  CODE	    03CF	 936
HELP3				  CODE	    03D7	 942
HELP4				  CODE	    03E3	 949
HELP5				  CODE	    03E8	 953
HTEXT				  CODE	    0E3D	2008
IE				  DATA	      A8	 130
IE0				  BIT	      89	 149
IE1				  BIT	      8B	 151
INC23				  CODE	    0715	1590
INT0				  BIT	      B2	 180
INT1				  BIT	      B3	 181
IP				  DATA	      B8	 135
IPH				  DATA	      B7	 134
IRET				  CODE	    07EE	1759
IT0				  BIT	      88	 148
IT1				  BIT	      8A	 150
LAR21				  CODE	    0703	1578
LAR21Z				  CODE	    0700	1574
LOAD				  CODE	    0116	 444
LOAD1				  CODE	    011E	 450
MAIN				  CODE	    1015	2041
MBUFFER				  CODE	    F7BC	 241
MISO				  BIT	      96	 160
MONRAM				  NUMBER    F780	 219
MOSI				  BIT	      95	 159
MRSAVE				  CODE	    F783	 239
MRSIZE				  NUMBER    004D	 242
MSSIZE				  NUMBER    0020	 224
M_BREAK				  CODE	    0857	1829
M_BYTES				  CODE	    0841	1826
M_CONFL				  CODE	    0861	1830
M_HELLO				  CODE	    0878	1831

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
M_LOAD				  CODE	    084B	1828
M_PC				  CODE	    0848	1827
NBREAK				  NUMBER    0004	 225
OTABLE				  CODE	    097C	1861
OUTFLAG				  NUMBER    007F	 229
OUTPUT				  CODE	    035D	 858
OV				  BIT	      D2	 201
P				  BIT	      D0	 200
P0				  DATA	      80	 107
P1				  DATA	      90	 123
P2				  DATA	      A0	 127
P3				  DATA	      B0	 133
PATCHBP				  CODE	    01A6	 547
PCON				  DATA	      87	 114
PCSAVE				  CODE	    F780	 237
PROMPT				  CODE	    003C	 282
PROMPT1				  CODE	    0098	 349
PS				  BIT	      BC	 190
PSW				  DATA	      D0	 143
PT0				  BIT	      B9	 187
PT1				  BIT	      BB	 189
PT2				  BIT	      BD	 191
PX0				  BIT	      B8	 186
PX1				  BIT	      BA	 188
QUERY				  CODE	    0339	 833
RB8				  BIT	      9A	 164
RCAP2H				  DATA	      CB	 140
RCAP2L				  DATA	      CA	 139
RCLK				  BIT	      CD	 197
RD				  BIT	      B7	 185
RDADDR				  CODE	    040F	 985
RDCHR				  CODE	    04C8	1141
RDCHR1				  CODE	    04DE	1154
RDHEX				  CODE	    048C	1090
RDINTM				  CODE	    0727	1607
RDINTM1				  CODE	    072E	1612
RDNIB				  CODE	    0498	1102
RDNIB1				  CODE	    04A7	1113
RDNIB2				  CODE	    04B4	1122
RDNIB3				  CODE	    04BA	1127
RDNIB4				  CODE	    04C1	1132
RDNIB5				  CODE	    04C6	1135
RDRANGE				  CODE	    041C	 996
RDUMP				  CODE	    0213	 628
RDUMP1				  CODE	    0220	 636
RDUMP2				  CODE	    0240	 657
RDWORD				  CODE	    0486	1083
REN				  BIT	      9C	 166
RESET				  CODE	    0000	 208
RET1				  CODE	    0485	1078
RET2				  CODE	    0593	1310
RI				  BIT	      98	 162
RNTABLE				  CODE	    0931	1838
ROM				  NUMBER    0000	 218
RS0				  BIT	      D3	 202
RS1				  BIT	      D4	 203

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
RXD				  BIT	      B0	 178
SADDR				  DATA	      A9	 131
SADEN				  DATA	      B9	 136
SAVER1				  CODE	    081C	1796
SAVEREG				  CODE	    07EF	1764
SBUF				  DATA	      99	 126
SCK				  BIT	      97	 161
SCON				  DATA	      98	 125
SDP43				  CODE	    06F7	1565
SINT				  CODE	    0023	 213
SM0				  BIT	      9F	 169
SM1				  BIT	      9E	 168
SM2				  BIT	      9D	 167
SP				  DATA	      81	 108
SPCR				  DATA	      D5	 144
SPDR				  DATA	      86	 113
SPSAVE				  CODE	    F782	 238
SPSR				  DATA	      AA	 132
SS				  BIT	      94	 158
SSINT				  CODE	    07D6	1746
STACK				  NUMBER    0007	 230
START				  CODE	    1006	2033
STEP				  CODE	    01AE	 559
STEP1				  CODE	    01D4	 581
T0				  BIT	      B4	 182
T1				  BIT	      B5	 183
T2				  BIT	      90	 156
T2CON				  DATA	      C8	 137
T2EX				  BIT	      91	 157
T2MOD				  DATA	      C9	 138
TB8				  BIT	      9B	 165
TCLK				  BIT	      CC	 196
TCON				  DATA	      88	 115
TESTBRK				  CODE	    07A2	1703
TF0				  BIT	      8D	 153
TF1				  BIT	      8F	 155
TF2				  BIT	      CF	 199
TH0				  DATA	      8C	 119
TH1				  DATA	      8D	 120
TH2				  DATA	      CD	 142
TI				  BIT	      99	 163
TIMER0				  CODE	    000B	 210
TIMER1				  CODE	    001B	 212
TIMER2				  CODE	    002B	 214
TL0				  DATA	      8A	 117
TL1				  DATA	      8B	 118
TL2				  DATA	      CC	 141
TMOD				  DATA	      89	 116
TR0				  BIT	      8C	 152
TR1				  BIT	      8E	 154
TR2				  BIT	      CA	 194
TSTBR1				  CODE	    07A7	1706
TSTBR2				  CODE	    07B5	1719
TSTBR3				  CODE	    07CA	1735
TSTBR4				  CODE	    07CF	1739
TXD				  BIT	      B1	 179

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
UNASS				  CODE	    02B7	 744
UNASS1				  CODE	    02C2	 750
USERRAM				  NUMBER    3000	 220
WDTCON				  DATA	      A7	 129
WDTRST				  DATA	      A6	 128
WGO				  CODE	    03ED	 957
WR				  BIT	      B6	 184
WR43				  CODE	    06F3	1561
WRCHR				  CODE	    047E	1074
WRDPTR				  CODE	    0432	1013
WRHEX				  CODE	    0438	1020
WRHEX1				  CODE	    043F	1025
WRHEXS				  CODE	    06DE	1546
WRHEXS1				  CODE	    06E8	1554
WRINTM				  CODE	    0740	1626
WRINTM1				  CODE	    0747	1631
WRITE				  CODE	    03B1	 918
WRLFCR				  CODE	    0455	1045
WRLFCR1				  CODE	    045C	1049
WRLFCR2				  CODE	    0469	1055
WRLFCR3				  CODE	    046F	1058
WRLFCR4				  CODE	    0474	1061
WRSPC				  CODE	    047C	1069
WRSTR				  CODE	    044C	1035
XLC				  CODE	    03A3	 906
XLC1				  CODE	    03A8	 909
XLOOP				  CODE	    037B	 883
XLR1				  CODE	    038A	 891
XLW				  CODE	    0392	 896
XLW1				  CODE	    039B	 901
